// <auto-generated>
// Unity Shared - Main Thread Dispatcher
// SSOT: skills/devian-upm/10-unity-main-thread/SKILL.md
// </auto-generated>

using System;
using System.Collections.Concurrent;
using UnityEngine;

namespace Devian
{
    /// <summary>
    /// Log item for main thread dispatch queue.
    /// </summary>
    internal readonly struct LogItem
    {
        public readonly LogLevel Level;
        public readonly string Tag;
        public readonly string Message;
        public readonly string? ExceptionText;

        public LogItem(LogLevel level, string tag, string message, string? exceptionText = null)
        {
            Level = level;
            Tag = tag;
            Message = message;
            ExceptionText = exceptionText;
        }
    }

    /// <summary>
    /// Main thread dispatcher for logging.
    /// Queues log items from background threads and processes them on the main thread.
    /// </summary>
    internal sealed class UnityMainThreadDispatcher : MonoBehaviour
    {
        /// <summary>
        /// Maximum number of log items to process per frame.
        /// Prevents frame drops from log flooding.
        /// </summary>
        private const int MaxPerFrame = 500;

        private static UnityMainThreadDispatcher? _instance;
        private static readonly ConcurrentQueue<LogItem> _queue = new();

        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
        private static void Initialize()
        {
            if (_instance != null)
            {
                return;
            }

            var go = new GameObject("[UnityMainThreadDispatcher]");
            go.hideFlags = HideFlags.HideAndDontSave;
            DontDestroyOnLoad(go);
            _instance = go.AddComponent<UnityMainThreadDispatcher>();
        }

        /// <summary>
        /// Enqueues a log item for main thread processing.
        /// Thread-safe. Can be called from any thread.
        /// </summary>
        public static void Enqueue(LogItem item)
        {
            _queue.Enqueue(item);
        }

        private void Update()
        {
            int processed = 0;
            while (processed < MaxPerFrame && _queue.TryDequeue(out var item))
            {
                OutputLog(item);
                processed++;
            }
        }

        private static void OutputLog(LogItem item)
        {
            var formatted = $"[{GetLevelString(item.Level)}] {item.Tag} - {item.Message}";

            switch (item.Level)
            {
                case LogLevel.Debug:
                case LogLevel.Info:
                    Debug.Log(formatted);
                    break;

                case LogLevel.Warn:
                    Debug.LogWarning(formatted);
                    break;

                case LogLevel.Error:
                    if (!string.IsNullOrEmpty(item.ExceptionText))
                    {
                        Debug.LogError(formatted + "\n" + item.ExceptionText);
                    }
                    else
                    {
                        Debug.LogError(formatted);
                    }
                    break;

                default:
                    Debug.Log(formatted);
                    break;
            }
        }

        private static string GetLevelString(LogLevel level)
        {
            return level switch
            {
                LogLevel.Debug => "DEBUG",
                LogLevel.Info => "INFO",
                LogLevel.Warn => "WARN",
                LogLevel.Error => "ERROR",
                _ => "UNKNOWN",
            };
        }

        private void OnDestroy()
        {
            if (_instance == this)
            {
                _instance = null;
            }
        }
    }
}

// <auto-generated>
// Unity Pool - Pool<T>
// SSOT: skills/devian-unity/30-unity-components/02-pool-manager/SKILL.md
// </auto-generated>

using System;
using System.Collections.Generic;
using UnityEngine;

namespace Devian
{
    /// <summary>
    /// Generic object pool for a specific component type and pool name.
    /// Pool identity: PoolId assigned by PoolManager on registration.
    /// Each Pool manages a single prefab name (poolName).
    /// Debug hierarchy: [PoolManager]/{Type}/{PoolName}/Inactive
    /// </summary>
    /// <typeparam name="T">The poolable component type</typeparam>
    public sealed class Pool<T> : IPool where T : Component, IPoolable<T>
    {
        private readonly Queue<T> _inactiveQueue = new Queue<T>();
        private readonly IPoolFactory _factory;
        private readonly int _maxSize;
        private readonly Transform _root;
        private readonly Transform _inactiveRoot;
        private readonly string _poolName;

        private GameObject _prefab;

        public Type ComponentType => typeof(T);

        /// <summary>
        /// The pool name this pool manages.
        /// </summary>
        public string PoolName => _poolName;

        public Pool(IPoolFactory factory, string poolName, PoolOptions options)
        {
            _factory = factory ?? throw new ArgumentNullException(nameof(factory));
            _poolName = PoolManager.NormalizePoolName(poolName);
            _maxSize = options.MaxSize > 0 ? options.MaxSize : 512;
            _root = options.Root;
            _inactiveRoot = options.InactiveRoot;
        }
        
        /// <summary>
        /// Spawns a pooled instance by prefab name.
        /// The name should match this pool's poolName.
        /// </summary>
        public T Spawn(string name, Vector3 position = default, Quaternion rotation = default, Transform parent = null)
        {
            UnityMainThread.EnsureOrThrow("Pool.Spawn");
            
            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentException("Prefab name cannot be null or empty.", nameof(name));
            }

            // Get or cache prefab (first time only)
            if (_prefab == null)
            {
                _prefab = _factory.GetPrefab(name);
                if (_prefab == null)
                {
                    throw new InvalidOperationException($"Prefab '{name}' not found by factory.");
                }
                
                // Verify pool type matches
                var poolType = _factory.GetPoolType(_prefab);
                if (poolType != typeof(T))
                {
                    throw new InvalidOperationException(
                        $"Prefab '{name}' pool type is {poolType.Name}, expected {typeof(T).Name}.");
                }
            }
            
            T instance = null;
            
            // Remove destroyed entries from inactive queue and get first valid instance
            while (_inactiveQueue.Count > 0 && instance == null)
            {
                instance = _inactiveQueue.Dequeue();
            }
            
            if (instance == null)
            {
                // Create new instance
                var component = _factory.CreateInstance(_prefab);
                instance = component as T;
                if (instance == null)
                {
                    throw new InvalidOperationException(
                        $"Factory created instance of type {component.GetType().Name}, expected {typeof(T).Name}.");
                }
            }
            
            // Activate and position
            var go = instance.gameObject;
            go.SetActive(true);
            
            var t = instance.transform;

            // Parent policy: if parent is null, use Root; otherwise use provided parent
            if (parent != null)
            {
                t.SetParent(parent, false);
            }
            else if (_root != null)
            {
                t.SetParent(_root, false);
            }

            t.position = position;
            t.rotation = rotation;

            // Track with PoolManager (attaches/updates PoolTag, marks IsSpawned)
            PoolManager.Instance._TrackSpawned(this, instance, _poolName);
            
            // Notify
            instance.OnPoolSpawned();
            
            return instance;
        }
        
        Component IPool.Spawn(string name, Vector3 position, Quaternion rotation, Transform parent)
        {
            return Spawn(name, position, rotation, parent);
        }
        
        /// <summary>
        /// Returns an instance to the pool.
        /// Instance is always moved under InactiveRoot for debug hierarchy.
        /// Order: OnPoolDespawned() -> SetActive(false) -> reparent
        /// </summary>
        public void Despawn(T instance)
        {
            UnityMainThread.EnsureOrThrow("Pool.Despawn");

            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }

            // Check PoolTag.IsSpawned to prevent double-despawn
            var tag = instance.GetComponent<PoolTag>();
            if (tag == null)
            {
                throw new InvalidOperationException(
                    $"Cannot despawn '{instance.name}': No PoolTag found. Was this instance spawned from a registered pool?");
            }

            if (!tag.IsSpawned)
            {
                // Already despawned, ignore
                return;
            }

            // Mark as despawned first to prevent re-entry
            tag.MarkDespawned();

            // Notify first (user code)
            instance.OnPoolDespawned();
            
            // If user destroyed pooled object during callback, fail fast with clear message
            if (instance == null || instance.gameObject == null)
            {
                throw new InvalidOperationException(
                    "Pooled object was destroyed during OnPoolDespawned(). " +
                    "Destroying pooled objects is forbidden. Use Despawn only.");
            }
            
            // Deactivate (only if still active)
            var go = instance.gameObject;
            if (go.activeSelf)
            {
                go.SetActive(false);
            }
            
            // Reparent to InactiveRoot
            if (_inactiveRoot != null)
            {
                instance.transform.SetParent(_inactiveRoot, false);
            }
            
            // Add to inactive queue or destroy if over capacity
            if (_inactiveQueue.Count < _maxSize)
            {
                _inactiveQueue.Enqueue(instance);
            }
            else
            {
                _factory.DestroyInstance(instance);
            }
        }
        
        void IPool.Despawn(Component instance)
        {
            Despawn(instance as T);
        }
        
        /// <summary>
        /// Clears all inactive instances (destroys them).
        /// Spawned instances are not affected.
        /// </summary>
        public void Clear()
        {
            UnityMainThread.EnsureOrThrow("Pool.Clear");
            
            while (_inactiveQueue.Count > 0)
            {
                var instance = _inactiveQueue.Dequeue();
                if (instance != null)
                {
                    _factory.DestroyInstance(instance);
                }
            }
        }
    }
}

// <auto-generated>
// Unity Pool - PoolManager (AutoSingleton Registry)
// SSOT: skills/devian-unity/30-unity-components/02-pool-manager/SKILL.md
// </auto-generated>

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using UnityEngine;

namespace Devian
{
    /// <summary>
    /// Central registry for object pools.
    /// AutoSingleton-based MonoBehaviour that manages:
    /// - Pool registration by (factory, type, poolName) key
    /// - Debug hierarchy: [PoolManager]/Type/PoolName/Inactive
    /// - PoolTag-based despawn routing
    ///
    /// Usage: Use IPoolFactory extension methods (factory.Spawn/Despawn),
    /// not PoolManager directly for spawning.
    /// </summary>
    public sealed class PoolManager : AutoSingleton<PoolManager>
    {
        // === Pool Registry (by PoolId) ===
        private readonly Dictionary<int, IPool> _poolsById = new Dictionary<int, IPool>();
        private readonly Dictionary<IPool, int> _idByPool = new Dictionary<IPool, int>();
        private int _nextPoolId = 1;
        
        // === Pool Registry (by PoolKey for factory.Spawn lookup) ===
        private readonly Dictionary<PoolKey, IPool> _poolsByKey = new Dictionary<PoolKey, IPool>();
        
        // === Debug Hierarchy Roots ===
        private readonly Dictionary<Type, Transform> _typeRoots = new Dictionary<Type, Transform>();
        private readonly Dictionary<Type, Dictionary<string, NameRoots>> _nameRootsByType = 
            new Dictionary<Type, Dictionary<string, NameRoots>>();
        
        /// <summary>
        /// Holds Root and Inactive root transforms for a pool name.
        /// </summary>
        internal readonly struct NameRoots
        {
            public readonly Transform Root;
            public readonly Transform Inactive;

            public NameRoots(Transform root, Transform inactive)
            {
                Root = root;
                Inactive = inactive;
            }
        }
        
        // === Internal: Pool Name Normalization ===
        
        /// <summary>
        /// Normalizes a pool name for hierarchy display.
        /// - null/empty/whitespace -> "Default"
        /// - Truncate to 64 chars
        /// - Replace path chars with underscore
        /// </summary>
        internal static string NormalizePoolName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                return "Default";
            
            // Truncate if too long
            if (name.Length > 64)
                name = name.Substring(0, 64);
            
            // Replace path characters
            name = name.Replace('/', '_').Replace('\\', '_');
            
            return name;
        }
        
        // === Internal: Get or Create Type Root ===
        
        /// <summary>
        /// Gets or creates a type root Transform under PoolManager.
        /// Structure: [PoolManager]/{TypeName}
        /// </summary>
        internal Transform _GetTypeRoot(Type componentType)
        {
            if (_typeRoots.TryGetValue(componentType, out var root))
            {
                return root;
            }
            
            // Create type root
            var go = new GameObject(componentType.Name);
            go.transform.SetParent(transform, false);
            
            _typeRoots[componentType] = go.transform;
            
            // Initialize name roots dictionary for this type
            if (!_nameRootsByType.ContainsKey(componentType))
            {
                _nameRootsByType[componentType] = new Dictionary<string, NameRoots>();
            }
            
            return go.transform;
        }
        
        // === Internal: Get or Create Name Roots (Root/Inactive) ===

        /// <summary>
        /// Gets or creates Root and Inactive root transforms for a pool name.
        /// Structure: [PoolManager]/{TypeName}/{PoolName}/Inactive
        /// Spawned instances go under {PoolName} (Root), despawned go under Inactive.
        /// </summary>
        internal NameRoots _GetNameRoots(Type componentType, string poolName)
        {
            var normalizedName = NormalizePoolName(poolName);

            // Ensure type root exists
            var typeRoot = _GetTypeRoot(componentType);

            // Get or create name roots dictionary
            if (!_nameRootsByType.TryGetValue(componentType, out var nameRootsDict))
            {
                nameRootsDict = new Dictionary<string, NameRoots>();
                _nameRootsByType[componentType] = nameRootsDict;
            }

            // Check cache
            if (nameRootsDict.TryGetValue(normalizedName, out var roots))
            {
                return roots;
            }

            // Create pool name root: [PoolManager]/{TypeName}/{PoolName}
            var nameRootGo = new GameObject(normalizedName);
            nameRootGo.transform.SetParent(typeRoot, false);

            // Create Inactive root (deactivated)
            var inactiveGo = new GameObject("Inactive");
            inactiveGo.transform.SetParent(nameRootGo.transform, false);
            inactiveGo.SetActive(false);

            roots = new NameRoots(nameRootGo.transform, inactiveGo.transform);
            nameRootsDict[normalizedName] = roots;

            return roots;
        }
        
        // === Internal: Get or Create Pool by Key ===
        
        /// <summary>
        /// Gets an existing pool or creates a new one for the given factory, type, and pool name.
        /// </summary>
        internal IPool _GetOrCreatePool<T>(IPoolFactory factory, string poolName, PoolOptions options) 
            where T : Component, IPoolable<T>
        {
            var normalizedName = NormalizePoolName(poolName);
            var key = new PoolKey(factory, typeof(T), normalizedName);
            
            if (_poolsByKey.TryGetValue(key, out var existingPool))
            {
                return existingPool;
            }
            
            // Get name roots for debug hierarchy
            var nameRoots = _GetNameRoots(typeof(T), normalizedName);

            // Set options with roots
            var optionsWithRoots = options;
            optionsWithRoots.Root = nameRoots.Root;
            optionsWithRoots.InactiveRoot = nameRoots.Inactive;
            
            // Create new pool
            var pool = new Pool<T>(factory, normalizedName, optionsWithRoots);
            
            // Register with PoolId
            var poolId = _nextPoolId++;
            _poolsById[poolId] = pool;
            _idByPool[pool] = poolId;
            
            // Register with PoolKey
            _poolsByKey[key] = pool;
            
            return pool;
        }
        
        // === Internal: Register Pool (for advanced usage) ===
        
        /// <summary>
        /// Registers a pool and returns its assigned PoolId.
        /// If the pool is already registered, returns the existing id.
        /// Internal use only - users should use factory.Spawn instead.
        /// </summary>
        internal int _RegisterPool(IPool pool)
        {
            if (pool == null)
            {
                throw new ArgumentNullException(nameof(pool));
            }
            
            // Check if already registered
            if (_idByPool.TryGetValue(pool, out var existingId))
            {
                return existingId;
            }
            
            // Assign new id
            var poolId = _nextPoolId++;
            _poolsById[poolId] = pool;
            _idByPool[pool] = poolId;
            
            return poolId;
        }
        
        /// <summary>
        /// Unregisters a pool by its id.
        /// </summary>
        internal bool _UnregisterPool(int poolId)
        {
            if (!_poolsById.TryGetValue(poolId, out var pool))
            {
                return false;
            }
            
            _poolsById.Remove(poolId);
            _idByPool.Remove(pool);
            
            // Also remove from _poolsByKey if present
            PoolKey? keyToRemove = null;
            foreach (var kvp in _poolsByKey)
            {
                if (ReferenceEquals(kvp.Value, pool))
                {
                    keyToRemove = kvp.Key;
                    break;
                }
            }
            if (keyToRemove.HasValue)
            {
                _poolsByKey.Remove(keyToRemove.Value);
            }
            
            return true;
        }
        
        // === Internal: Track Spawned Instance ===
        
        /// <summary>
        /// Tracks a spawned instance by attaching/updating PoolTag.
        /// Called by Pool.Spawn after positioning, before callback.
        /// </summary>
        internal void _TrackSpawned(IPool pool, Component instance, string poolName)
        {
            UnityMainThread.EnsureOrThrow("PoolManager.TrackSpawned");
            
            if (!_idByPool.TryGetValue(pool, out var poolId))
            {
                throw new InvalidOperationException(
                    "Pool is not registered with PoolManager. Use factory.Spawn instead of manual pool creation.");
            }
            
            var tag = instance.GetComponent<PoolTag>();
            if (tag == null)
            {
                tag = instance.gameObject.AddComponent<PoolTag>();
            }
            
            tag.SetPoolInfo(poolId, NormalizePoolName(poolName));
            tag.MarkSpawned();
        }
        
        // === Public API: Despawn ===
        
        /// <summary>
        /// Despawns an instance back to its pool.
        /// Uses PoolTag to determine which pool the instance belongs to.
        /// </summary>
        public void Despawn(Component instance)
        {
            UnityMainThread.EnsureOrThrow("PoolManager.Despawn");
            
            if (instance == null)
            {
                throw new ArgumentNullException(nameof(instance));
            }
            
            var tag = instance.GetComponent<PoolTag>();
            if (tag == null)
            {
                throw new InvalidOperationException(
                    $"Cannot despawn '{instance.name}': No PoolTag found. Was this instance spawned from a registered pool?");
            }
            
            if (!_poolsById.TryGetValue(tag.PoolId, out var pool))
            {
                throw new InvalidOperationException(
                    $"Cannot despawn '{instance.name}': Pool with id {tag.PoolId} not found. Was the pool unregistered?");
            }
            
            pool.Despawn(instance);
        }
        
        // === Public API: Clear ===
        
        /// <summary>
        /// Clears the pool with the specified id.
        /// </summary>
        public void Clear(int poolId)
        {
            UnityMainThread.EnsureOrThrow("PoolManager.Clear");
            
            if (_poolsById.TryGetValue(poolId, out var pool))
            {
                pool.Clear();
            }
        }
        
        /// <summary>
        /// Clears all registered pools.
        /// </summary>
        public void ClearAll()
        {
            UnityMainThread.EnsureOrThrow("PoolManager.ClearAll");
            
            foreach (var pool in _poolsById.Values)
            {
                pool.Clear();
            }
        }
        
        // === Internal: PoolKey for (factory, type, poolName) lookup ===
        
        private readonly struct PoolKey : IEquatable<PoolKey>
        {
            private readonly IPoolFactory _factory;
            private readonly Type _componentType;
            private readonly string _poolName;
            
            public PoolKey(IPoolFactory factory, Type componentType, string poolName)
            {
                _factory = factory;
                _componentType = componentType;
                _poolName = poolName ?? string.Empty;
            }
            
            public bool Equals(PoolKey other)
            {
                return ReferenceEquals(_factory, other._factory) 
                    && _componentType == other._componentType
                    && string.Equals(_poolName, other._poolName, StringComparison.Ordinal);
            }
            
            public override bool Equals(object obj)
            {
                return obj is PoolKey other && Equals(other);
            }
            
            public override int GetHashCode()
            {
                unchecked
                {
                    var factoryHash = _factory != null ? RuntimeHelpers.GetHashCode(_factory) : 0;
                    var typeHash = _componentType?.GetHashCode() ?? 0;
                    var nameHash = _poolName?.GetHashCode() ?? 0;
                    return ((factoryHash * 397) ^ typeHash) * 397 ^ nameHash;
                }
            }
        }
    }
}

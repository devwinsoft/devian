// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System v10
// </auto-generated>

#nullable enable

using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Devian;
using Devian.Module.Common;

namespace Devian.Protocol.Game
{
    // Direction: client_to_server

    /// <summary>
    /// C2Game protocol container.
    /// </summary>
    public static partial class C2Game
    {
        /// <summary>
        /// Frame helper for protocol framing.
        /// Frame format: [opcode:int32LE][payload...]
        /// </summary>
        internal static class Frame
        {
            public static int ReadOpcode(ReadOnlySpan<byte> frame)
            {
                if (frame.Length < 4) throw new ArgumentException("Frame too short");
                return BitConverter.ToInt32(frame.Slice(0, 4));
            }

            public static ReadOnlySpan<byte> ReadPayload(ReadOnlySpan<byte> frame)
            {
                if (frame.Length < 4) return ReadOnlySpan<byte>.Empty;
                return frame.Slice(4);
            }

            public static byte[] Pack(int opcode, ReadOnlySpan<byte> payload)
            {
                var frame = new byte[4 + payload.Length];
                BitConverter.TryWriteBytes(frame.AsSpan(0, 4), opcode);
                payload.CopyTo(frame.AsSpan(4));
                return frame;
            }
        }

        /// <summary>Envelope metadata (sessionId 등)</summary>
        public readonly struct EnvelopeMeta
        {
            public int SessionId { get; }

            public EnvelopeMeta(int sessionId)
            {
                SessionId = sessionId;
            }
        }

        /// <summary>
        /// Packet envelope (ref struct - 복사/할당 방지)
        /// </summary>
        public ref struct PacketEnvelope
        {
            public int Opcode { get; }
            public ReadOnlySpan<byte> Payload { get; }
            public EnvelopeMeta Meta { get; }

            public PacketEnvelope(int opcode, ReadOnlySpan<byte> payload, EnvelopeMeta meta)
            {
                Opcode = opcode;
                Payload = payload;
                Meta = meta;
            }
        }

        /// <summary>
        /// Generic packet pool for message object reuse.
        /// </summary>
        internal sealed class PacketPool<T> where T : class, new()
        {
            private readonly Stack<T> _stack;
            private readonly int _max;

            public PacketPool(int max = 256)
            {
                _max = max;
                _stack = new Stack<T>(Math.Min(max, 32));
            }

            public T Rent()
            {
                lock (_stack)
                {
                    return _stack.Count > 0 ? _stack.Pop() : new T();
                }
            }

            public void Return(T item)
            {
                lock (_stack)
                {
                    if (_stack.Count < _max) _stack.Push(item);
                }
            }
        }

        /// <summary>
        /// Span-based protobuf reader (zero-copy)
        /// </summary>
        internal ref struct ProtoReader
        {
            private ReadOnlySpan<byte> _data;
            private int _pos;

            public ProtoReader(ReadOnlySpan<byte> data)
            {
                _data = data;
                _pos = 0;
            }

            public bool HasMore => _pos < _data.Length;

            public (int tag, int wireType) ReadTag()
            {
                var varint = ReadVarint();
                return ((int)(varint >> 3), (int)(varint & 0x7));
            }

            public long ReadVarint()
            {
                long result = 0;
                int shift = 0;
                while (_pos < _data.Length)
                {
                    byte b = _data[_pos++];
                    result |= (long)(b & 0x7F) << shift;
                    if ((b & 0x80) == 0) break;
                    shift += 7;
                }
                return result;
            }

            public int ReadInt32() => (int)ReadVarint();
            public long ReadInt64() => ReadVarint();
            public uint ReadUInt32() => (uint)ReadVarint();
            public ulong ReadUInt64() => (ulong)ReadVarint();
            public bool ReadBool() => ReadVarint() != 0;

            public int ReadSInt32()
            {
                var n = (uint)ReadVarint();
                return (int)((n >> 1) ^ -(int)(n & 1));
            }

            public long ReadSInt64()
            {
                var n = (ulong)ReadVarint();
                return (long)(n >> 1) ^ -(long)(n & 1);
            }

            public float ReadFloat()
            {
                var bytes = _data.Slice(_pos, 4);
                _pos += 4;
                return BitConverter.ToSingle(bytes);
            }

            public double ReadDouble()
            {
                var bytes = _data.Slice(_pos, 8);
                _pos += 8;
                return BitConverter.ToDouble(bytes);
            }

            public string ReadString()
            {
                var len = (int)ReadVarint();
                if (len == 0) return string.Empty;
                var bytes = _data.Slice(_pos, len);
                _pos += len;
                return Encoding.UTF8.GetString(bytes);
            }

            public byte[] ReadBytes()
            {
                var len = (int)ReadVarint();
                if (len == 0) return Array.Empty<byte>();
                var bytes = _data.Slice(_pos, len).ToArray();
                _pos += len;
                return bytes;
            }

            public void Skip(int wireType)
            {
                switch (wireType)
                {
                    case 0: ReadVarint(); break;
                    case 1: _pos += 8; break;
                    case 2: _pos += (int)ReadVarint(); break;
                    case 5: _pos += 4; break;
                }
            }
        }

        /// <summary>
        /// Protobuf wire format writer helper
        /// </summary>
        private static class ProtoWriter
        {
            public static void WriteVarint(MemoryStream ms, long value)
            {
                var uval = (ulong)value;
                while (uval >= 0x80)
                {
                    ms.WriteByte((byte)(uval | 0x80));
                    uval >>= 7;
                }
                ms.WriteByte((byte)uval);
            }

            public static void WriteTag(MemoryStream ms, int tag, int wireType)
            {
                WriteVarint(ms, (tag << 3) | wireType);
            }

            public static void WriteString(MemoryStream ms, int tag, string? value)
            {
                if (string.IsNullOrEmpty(value)) return;
                WriteTag(ms, tag, 2);
                var bytes = Encoding.UTF8.GetBytes(value);
                WriteVarint(ms, bytes.Length);
                ms.Write(bytes, 0, bytes.Length);
            }

            public static void WriteInt32(MemoryStream ms, int tag, int value)
            {
                if (value == 0) return;
                WriteTag(ms, tag, 0);
                WriteVarint(ms, value);
            }

            public static void WriteInt64(MemoryStream ms, int tag, long value)
            {
                if (value == 0) return;
                WriteTag(ms, tag, 0);
                WriteVarint(ms, value);
            }

            public static void WriteBool(MemoryStream ms, int tag, bool value)
            {
                if (!value) return;
                WriteTag(ms, tag, 0);
                ms.WriteByte(1);
            }

            public static void WriteBytes(MemoryStream ms, int tag, byte[]? value)
            {
                if (value == null || value.Length == 0) return;
                WriteTag(ms, tag, 2);
                WriteVarint(ms, value.Length);
                ms.Write(value, 0, value.Length);
            }

            public static void WriteFloat(MemoryStream ms, int tag, float value)
            {
                if (value == 0) return;
                WriteTag(ms, tag, 5);
                var bytes = BitConverter.GetBytes(value);
                ms.Write(bytes, 0, 4);
            }

            public static void WriteDouble(MemoryStream ms, int tag, double value)
            {
                if (value == 0) return;
                WriteTag(ms, tag, 1);
                var bytes = BitConverter.GetBytes(value);
                ms.Write(bytes, 0, 8);
            }
        }

        /// <summary>LoginRequest message</summary>
        public sealed class LoginRequest
        {
            public string UserId { get; set; } = string.Empty;
            public string Token { get; set; } = string.Empty;
            public int Version { get; set; }

            internal void _Reset()
            {
                UserId = string.Empty;
                Token = string.Empty;
                Version = default;
            }
        }

        /// <summary>JoinRoomRequest message</summary>
        public sealed class JoinRoomRequest
        {
            public int RoomId { get; set; }
            public string? Password { get; set; } = string.Empty;

            internal void _Reset()
            {
                RoomId = default;
                Password = string.Empty;
            }
        }

        /// <summary>ChatMessage message</summary>
        public sealed class ChatMessage
        {
            public int Channel { get; set; }
            public string Message { get; set; } = string.Empty;
            public List<long>? TargetUserIds { get; set; }

            internal void _Reset()
            {
                Channel = default;
                Message = string.Empty;
                TargetUserIds = null;
            }
        }

        /// <summary>UploadData message</summary>
        public sealed class UploadData
        {
            public byte[] Data { get; set; } = Array.Empty<byte>();
            public Dictionary<string, string>? Metadata { get; set; }
            public List<bool>? Flags { get; set; }

            internal void _Reset()
            {
                Data = Array.Empty<byte>();
                Metadata = null!;
                Flags = null;
            }
        }

        /// <summary>Opcode constants</summary>
        public static class Opcodes
        {
            public const int LoginRequest = 1001;
            public const int JoinRoomRequest = 100;
            public const int ChatMessage = 1000;
            public const int UploadData = 1002;

            public static string? GetName(int opcode) => opcode switch
            {
                1001 => nameof(LoginRequest),
                100 => nameof(JoinRoomRequest),
                1000 => nameof(ChatMessage),
                1002 => nameof(UploadData),
                _ => null
            };
        }

        /// <summary>Codec interface</summary>
        public interface ICodec
        {
            byte[] Encode<T>(T message) where T : class;
            T Decode<T>(ReadOnlySpan<byte> data) where T : class, new();
            object? Decode(int opcode, ReadOnlySpan<byte> data);
        }

        /// <summary>Protobuf Codec implementation</summary>
        public sealed class CodecProtobuf : ICodec
        {
            public byte[] Encode<T>(T message) where T : class
            {
                using var ms = new MemoryStream();
                switch (message)
                {
                    case LoginRequest m: EncodeLoginRequest(ms, m); break;
                    case JoinRoomRequest m: EncodeJoinRoomRequest(ms, m); break;
                    case ChatMessage m: EncodeChatMessage(ms, m); break;
                    case UploadData m: EncodeUploadData(ms, m); break;
                    default: throw new ArgumentException($"Unknown message type: {typeof(T).Name}");
                }
                return ms.ToArray();
            }

            public T Decode<T>(ReadOnlySpan<byte> data) where T : class, new()
            {
                var result = new T();
                switch (result)
                {
                    case LoginRequest m: DecodeLoginRequest(data, m); break;
                    case JoinRoomRequest m: DecodeJoinRoomRequest(data, m); break;
                    case ChatMessage m: DecodeChatMessage(data, m); break;
                    case UploadData m: DecodeUploadData(data, m); break;
                }
                return result;
            }

            public object? Decode(int opcode, ReadOnlySpan<byte> data)
            {
                return opcode switch
                {
                    Opcodes.LoginRequest => Decode<LoginRequest>(data),
                    Opcodes.JoinRoomRequest => Decode<JoinRoomRequest>(data),
                    Opcodes.ChatMessage => Decode<ChatMessage>(data),
                    Opcodes.UploadData => Decode<UploadData>(data),
                    _ => null
                };
            }

            private static void EncodeLoginRequest(MemoryStream ms, LoginRequest m)
            {
                ProtoWriter.WriteString(ms, 1, m.UserId);
                ProtoWriter.WriteString(ms, 2, m.Token);
                ProtoWriter.WriteInt32(ms, 3, m.Version);
            }

            private static void EncodeJoinRoomRequest(MemoryStream ms, JoinRoomRequest m)
            {
                ProtoWriter.WriteInt32(ms, 1, m.RoomId);
                ProtoWriter.WriteString(ms, 2, m.Password);
            }

            private static void EncodeChatMessage(MemoryStream ms, ChatMessage m)
            {
                ProtoWriter.WriteInt32(ms, 1, m.Channel);
                ProtoWriter.WriteString(ms, 2, m.Message);
                if (m.TargetUserIds != null)
                {
                    foreach (var item in m.TargetUserIds)
                    {
                        ProtoWriter.WriteInt64(ms, 3, item);
                    }
                }
            }

            private static void EncodeUploadData(MemoryStream ms, UploadData m)
            {
                ProtoWriter.WriteBytes(ms, 1, m.Data);
                if (m.Flags != null)
                {
                    foreach (var item in m.Flags)
                    {
                        ProtoWriter.WriteBool(ms, 3, item);
                    }
                }
            }

            private static void DecodeLoginRequest(ReadOnlySpan<byte> data, LoginRequest m)
            {
                var reader = new ProtoReader(data);
                while (reader.HasMore)
                {
                    var (tag, wireType) = reader.ReadTag();
                    switch (tag)
                    {
                        case 1: m.UserId = reader.ReadString(); break;
                        case 2: m.Token = reader.ReadString(); break;
                        case 3: m.Version = reader.ReadInt32(); break;
                        default: reader.Skip(wireType); break;
                    }
                }
            }

            private static void DecodeJoinRoomRequest(ReadOnlySpan<byte> data, JoinRoomRequest m)
            {
                var reader = new ProtoReader(data);
                while (reader.HasMore)
                {
                    var (tag, wireType) = reader.ReadTag();
                    switch (tag)
                    {
                        case 1: m.RoomId = reader.ReadInt32(); break;
                        case 2: m.Password = reader.ReadString(); break;
                        default: reader.Skip(wireType); break;
                    }
                }
            }

            private static void DecodeChatMessage(ReadOnlySpan<byte> data, ChatMessage m)
            {
                var reader = new ProtoReader(data);
                while (reader.HasMore)
                {
                    var (tag, wireType) = reader.ReadTag();
                    switch (tag)
                    {
                        case 1: m.Channel = reader.ReadInt32(); break;
                        case 2: m.Message = reader.ReadString(); break;
                        case 3:
                            m.TargetUserIds ??= new List<long>();
                            m.TargetUserIds.Add(reader.ReadInt64());
                            break;
                        default: reader.Skip(wireType); break;
                    }
                }
            }

            private static void DecodeUploadData(ReadOnlySpan<byte> data, UploadData m)
            {
                var reader = new ProtoReader(data);
                while (reader.HasMore)
                {
                    var (tag, wireType) = reader.ReadTag();
                    switch (tag)
                    {
                        case 1: m.Data = reader.ReadBytes(); break;
                        case 3:
                            m.Flags ??= new List<bool>();
                            m.Flags.Add(reader.ReadBool());
                            break;
                        default: reader.Skip(wireType); break;
                    }
                }
            }

        }

        /// <summary>Sender interface for Proxy</summary>
        public interface ISender
        {
            void SendTo(int sessionId, ReadOnlySpan<byte> frame);
        }

        /// <summary>
        /// Abstract stub for C2Game handlers.
        /// Inherit and implement all On* methods.
        /// </summary>
        public abstract class Stub
        {
            protected ICodec Codec { get; }

            protected Stub(ICodec? codec = null)
            {
                Codec = codec ?? new CodecProtobuf();
            }

            public void Dispatch(PacketEnvelope envelope)
            {
                switch (envelope.Opcode)
                {
                    case Opcodes.LoginRequest:
                        var loginRequest = Codec.Decode<LoginRequest>(envelope.Payload);
                        OnLoginRequest(envelope.Meta, loginRequest);
                        break;
                    case Opcodes.JoinRoomRequest:
                        var joinRoomRequest = Codec.Decode<JoinRoomRequest>(envelope.Payload);
                        OnJoinRoomRequest(envelope.Meta, joinRoomRequest);
                        break;
                    case Opcodes.ChatMessage:
                        var chatMessage = Codec.Decode<ChatMessage>(envelope.Payload);
                        OnChatMessage(envelope.Meta, chatMessage);
                        break;
                    case Opcodes.UploadData:
                        var uploadData = Codec.Decode<UploadData>(envelope.Payload);
                        OnUploadData(envelope.Meta, uploadData);
                        break;
                }
            }

            protected abstract void OnLoginRequest(EnvelopeMeta meta, LoginRequest message);
            protected abstract void OnJoinRoomRequest(EnvelopeMeta meta, JoinRoomRequest message);
            protected abstract void OnChatMessage(EnvelopeMeta meta, ChatMessage message);
            protected abstract void OnUploadData(EnvelopeMeta meta, UploadData message);
        }

        /// <summary>
        /// Runtime adapter implementing INetRuntime for C2Game.
        /// Bridges NetClient and generated Stub.
        /// </summary>
        public sealed class Runtime : Devian.INetRuntime
        {
            private readonly Stub _stub;

            public Runtime(Stub stub)
            {
                _stub = stub ?? throw new ArgumentNullException(nameof(stub));
            }

            /// <summary>
            /// Try to dispatch inbound packet. Returns true if opcode belongs to this protocol.
            /// </summary>
            public bool TryDispatchInbound(int sessionId, int opcode, ReadOnlySpan<byte> payload)
            {
                switch (opcode)
                {
                    case Opcodes.LoginRequest:
                    case Opcodes.JoinRoomRequest:
                    case Opcodes.ChatMessage:
                    case Opcodes.UploadData:
                    {
                        var meta = new EnvelopeMeta(sessionId);
                        var envelope = new PacketEnvelope(opcode, payload, meta);
                        _stub.Dispatch(envelope);
                        return true;
                    }
                    default:
                        return false;
                }
            }
        }

        /// <summary>
        /// Proxy for sending C2Game messages.
        /// </summary>
        public sealed class Proxy
        {
            private readonly ISender _sender;
            private readonly ICodec _codec;

            public Proxy(ISender sender, ICodec? codec = null)
            {
                _sender = sender;
                _codec = codec ?? new CodecProtobuf();
            }

            public void SendLoginRequest(int sessionId, LoginRequest message)
            {
                var payload = _codec.Encode(message);
                var frame = Frame.Pack(Opcodes.LoginRequest, payload);
                _sender.SendTo(sessionId, frame);
            }

            public void SendJoinRoomRequest(int sessionId, JoinRoomRequest message)
            {
                var payload = _codec.Encode(message);
                var frame = Frame.Pack(Opcodes.JoinRoomRequest, payload);
                _sender.SendTo(sessionId, frame);
            }

            public void SendChatMessage(int sessionId, ChatMessage message)
            {
                var payload = _codec.Encode(message);
                var frame = Frame.Pack(Opcodes.ChatMessage, payload);
                _sender.SendTo(sessionId, frame);
            }

            public void SendUploadData(int sessionId, UploadData message)
            {
                var payload = _codec.Encode(message);
                var frame = Frame.Pack(Opcodes.UploadData, payload);
                _sender.SendTo(sessionId, frame);
            }

        }
    }
}
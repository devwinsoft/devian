// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System v10
// </auto-generated>

#nullable enable

using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Devian;
using Devian.Module.Common;

namespace Devian.Protocol.Game
{
    // Direction: server_to_client

    /// <summary>
    /// Game2C protocol container.
    /// </summary>
    public static partial class Game2C
    {
        /// <summary>
        /// Frame helper for protocol framing.
        /// Frame format: [opcode:int32LE][payload...]
        /// </summary>
        internal static class Frame
        {
            public static int ReadOpcode(ReadOnlySpan<byte> frame)
            {
                if (frame.Length < 4) throw new ArgumentException("Frame too short");
                return BitConverter.ToInt32(frame.Slice(0, 4));
            }

            public static ReadOnlySpan<byte> ReadPayload(ReadOnlySpan<byte> frame)
            {
                if (frame.Length < 4) return ReadOnlySpan<byte>.Empty;
                return frame.Slice(4);
            }

            public static byte[] Pack(int opcode, ReadOnlySpan<byte> payload)
            {
                var frame = new byte[4 + payload.Length];
                BitConverter.TryWriteBytes(frame.AsSpan(0, 4), opcode);
                payload.CopyTo(frame.AsSpan(4));
                return frame;
            }
        }

        /// <summary>Envelope metadata (sessionId 등)</summary>
        public readonly struct EnvelopeMeta
        {
            public int SessionId { get; }

            public EnvelopeMeta(int sessionId)
            {
                SessionId = sessionId;
            }
        }

        /// <summary>
        /// Packet envelope (ref struct - 복사/할당 방지)
        /// </summary>
        public ref struct PacketEnvelope
        {
            public int Opcode { get; }
            public ReadOnlySpan<byte> Payload { get; }
            public EnvelopeMeta Meta { get; }

            public PacketEnvelope(int opcode, ReadOnlySpan<byte> payload, EnvelopeMeta meta)
            {
                Opcode = opcode;
                Payload = payload;
                Meta = meta;
            }
        }

        /// <summary>
        /// Generic packet pool for message object reuse.
        /// </summary>
        internal sealed class PacketPool<T> where T : class, new()
        {
            private readonly Stack<T> _stack;
            private readonly int _max;

            public PacketPool(int max = 256)
            {
                _max = max;
                _stack = new Stack<T>(Math.Min(max, 32));
            }

            public T Rent()
            {
                lock (_stack)
                {
                    return _stack.Count > 0 ? _stack.Pop() : new T();
                }
            }

            public void Return(T item)
            {
                lock (_stack)
                {
                    if (_stack.Count < _max) _stack.Push(item);
                }
            }
        }

        /// <summary>
        /// Span-based protobuf reader (zero-copy)
        /// </summary>
        internal ref struct ProtoReader
        {
            private ReadOnlySpan<byte> _data;
            private int _pos;

            public ProtoReader(ReadOnlySpan<byte> data)
            {
                _data = data;
                _pos = 0;
            }

            public bool HasMore => _pos < _data.Length;

            public (int tag, int wireType) ReadTag()
            {
                var varint = ReadVarint();
                return ((int)(varint >> 3), (int)(varint & 0x7));
            }

            public long ReadVarint()
            {
                long result = 0;
                int shift = 0;
                while (_pos < _data.Length)
                {
                    byte b = _data[_pos++];
                    result |= (long)(b & 0x7F) << shift;
                    if ((b & 0x80) == 0) break;
                    shift += 7;
                }
                return result;
            }

            public int ReadInt32() => (int)ReadVarint();
            public long ReadInt64() => ReadVarint();
            public uint ReadUInt32() => (uint)ReadVarint();
            public ulong ReadUInt64() => (ulong)ReadVarint();
            public bool ReadBool() => ReadVarint() != 0;

            public int ReadSInt32()
            {
                var n = (uint)ReadVarint();
                return (int)((n >> 1) ^ -(int)(n & 1));
            }

            public long ReadSInt64()
            {
                var n = (ulong)ReadVarint();
                return (long)(n >> 1) ^ -(long)(n & 1);
            }

            public float ReadFloat()
            {
                var bytes = _data.Slice(_pos, 4);
                _pos += 4;
                return BitConverter.ToSingle(bytes);
            }

            public double ReadDouble()
            {
                var bytes = _data.Slice(_pos, 8);
                _pos += 8;
                return BitConverter.ToDouble(bytes);
            }

            public string ReadString()
            {
                var len = (int)ReadVarint();
                if (len == 0) return string.Empty;
                var bytes = _data.Slice(_pos, len);
                _pos += len;
                return Encoding.UTF8.GetString(bytes);
            }

            public byte[] ReadBytes()
            {
                var len = (int)ReadVarint();
                if (len == 0) return Array.Empty<byte>();
                var bytes = _data.Slice(_pos, len).ToArray();
                _pos += len;
                return bytes;
            }

            public void Skip(int wireType)
            {
                switch (wireType)
                {
                    case 0: ReadVarint(); break;
                    case 1: _pos += 8; break;
                    case 2: _pos += (int)ReadVarint(); break;
                    case 5: _pos += 4; break;
                }
            }
        }

        /// <summary>
        /// Protobuf wire format writer helper
        /// </summary>
        private static class ProtoWriter
        {
            public static void WriteVarint(MemoryStream ms, long value)
            {
                var uval = (ulong)value;
                while (uval >= 0x80)
                {
                    ms.WriteByte((byte)(uval | 0x80));
                    uval >>= 7;
                }
                ms.WriteByte((byte)uval);
            }

            public static void WriteTag(MemoryStream ms, int tag, int wireType)
            {
                WriteVarint(ms, (tag << 3) | wireType);
            }

            public static void WriteString(MemoryStream ms, int tag, string? value)
            {
                if (string.IsNullOrEmpty(value)) return;
                WriteTag(ms, tag, 2);
                var bytes = Encoding.UTF8.GetBytes(value);
                WriteVarint(ms, bytes.Length);
                ms.Write(bytes, 0, bytes.Length);
            }

            public static void WriteInt32(MemoryStream ms, int tag, int value)
            {
                if (value == 0) return;
                WriteTag(ms, tag, 0);
                WriteVarint(ms, value);
            }

            public static void WriteInt64(MemoryStream ms, int tag, long value)
            {
                if (value == 0) return;
                WriteTag(ms, tag, 0);
                WriteVarint(ms, value);
            }

            public static void WriteBool(MemoryStream ms, int tag, bool value)
            {
                if (!value) return;
                WriteTag(ms, tag, 0);
                ms.WriteByte(1);
            }

            public static void WriteBytes(MemoryStream ms, int tag, byte[]? value)
            {
                if (value == null || value.Length == 0) return;
                WriteTag(ms, tag, 2);
                WriteVarint(ms, value.Length);
                ms.Write(value, 0, value.Length);
            }

            public static void WriteFloat(MemoryStream ms, int tag, float value)
            {
                if (value == 0) return;
                WriteTag(ms, tag, 5);
                var bytes = BitConverter.GetBytes(value);
                ms.Write(bytes, 0, 4);
            }

            public static void WriteDouble(MemoryStream ms, int tag, double value)
            {
                if (value == 0) return;
                WriteTag(ms, tag, 1);
                var bytes = BitConverter.GetBytes(value);
                ms.Write(bytes, 0, 8);
            }
        }

        /// <summary>LoginResponse message</summary>
        public sealed class LoginResponse
        {
            public bool Success { get; set; }
            public long PlayerId { get; set; }
            public int ErrorCode { get; set; }
            public string? ErrorMessage { get; set; } = string.Empty;

            internal void _Reset()
            {
                Success = default;
                PlayerId = default;
                ErrorCode = default;
                ErrorMessage = string.Empty;
            }
        }

        /// <summary>JoinRoomResponse message</summary>
        public sealed class JoinRoomResponse
        {
            public bool Success { get; set; }
            public int RoomId { get; set; }
            public List<long>? PlayerIds { get; set; }

            internal void _Reset()
            {
                Success = default;
                RoomId = default;
                PlayerIds = null;
            }
        }

        /// <summary>ChatNotify message</summary>
        public sealed class ChatNotify
        {
            public int Channel { get; set; }
            public long SenderId { get; set; }
            public string SenderName { get; set; } = string.Empty;
            public string Message { get; set; } = string.Empty;
            public long Timestamp { get; set; }

            internal void _Reset()
            {
                Channel = default;
                SenderId = default;
                SenderName = string.Empty;
                Message = string.Empty;
                Timestamp = default;
            }
        }

        /// <summary>Opcode constants</summary>
        public static class Opcodes
        {
            public const int LoginResponse = 1002;
            public const int JoinRoomResponse = 1001;
            public const int ChatNotify = 1000;

            public static string? GetName(int opcode) => opcode switch
            {
                1002 => nameof(LoginResponse),
                1001 => nameof(JoinRoomResponse),
                1000 => nameof(ChatNotify),
                _ => null
            };
        }

        /// <summary>Codec interface</summary>
        public interface ICodec
        {
            byte[] Encode<T>(T message) where T : class;
            T Decode<T>(ReadOnlySpan<byte> data) where T : class, new();
            object? Decode(int opcode, ReadOnlySpan<byte> data);
        }

        /// <summary>Protobuf Codec implementation</summary>
        public sealed class CodecProtobuf : ICodec
        {
            public byte[] Encode<T>(T message) where T : class
            {
                using var ms = new MemoryStream();
                switch (message)
                {
                    case LoginResponse m: EncodeLoginResponse(ms, m); break;
                    case JoinRoomResponse m: EncodeJoinRoomResponse(ms, m); break;
                    case ChatNotify m: EncodeChatNotify(ms, m); break;
                    default: throw new ArgumentException($"Unknown message type: {typeof(T).Name}");
                }
                return ms.ToArray();
            }

            public T Decode<T>(ReadOnlySpan<byte> data) where T : class, new()
            {
                var result = new T();
                switch (result)
                {
                    case LoginResponse m: DecodeLoginResponse(data, m); break;
                    case JoinRoomResponse m: DecodeJoinRoomResponse(data, m); break;
                    case ChatNotify m: DecodeChatNotify(data, m); break;
                }
                return result;
            }

            public object? Decode(int opcode, ReadOnlySpan<byte> data)
            {
                return opcode switch
                {
                    Opcodes.LoginResponse => Decode<LoginResponse>(data),
                    Opcodes.JoinRoomResponse => Decode<JoinRoomResponse>(data),
                    Opcodes.ChatNotify => Decode<ChatNotify>(data),
                    _ => null
                };
            }

            private static void EncodeLoginResponse(MemoryStream ms, LoginResponse m)
            {
                ProtoWriter.WriteBool(ms, 1, m.Success);
                ProtoWriter.WriteInt64(ms, 2, m.PlayerId);
                ProtoWriter.WriteInt32(ms, 3, m.ErrorCode);
                ProtoWriter.WriteString(ms, 4, m.ErrorMessage);
            }

            private static void EncodeJoinRoomResponse(MemoryStream ms, JoinRoomResponse m)
            {
                ProtoWriter.WriteBool(ms, 1, m.Success);
                ProtoWriter.WriteInt32(ms, 2, m.RoomId);
                if (m.PlayerIds != null)
                {
                    foreach (var item in m.PlayerIds)
                    {
                        ProtoWriter.WriteInt64(ms, 3, item);
                    }
                }
            }

            private static void EncodeChatNotify(MemoryStream ms, ChatNotify m)
            {
                ProtoWriter.WriteInt32(ms, 1, m.Channel);
                ProtoWriter.WriteInt64(ms, 2, m.SenderId);
                ProtoWriter.WriteString(ms, 3, m.SenderName);
                ProtoWriter.WriteString(ms, 4, m.Message);
                ProtoWriter.WriteInt64(ms, 5, m.Timestamp);
            }

            private static void DecodeLoginResponse(ReadOnlySpan<byte> data, LoginResponse m)
            {
                var reader = new ProtoReader(data);
                while (reader.HasMore)
                {
                    var (tag, wireType) = reader.ReadTag();
                    switch (tag)
                    {
                        case 1: m.Success = reader.ReadBool(); break;
                        case 2: m.PlayerId = reader.ReadInt64(); break;
                        case 3: m.ErrorCode = reader.ReadInt32(); break;
                        case 4: m.ErrorMessage = reader.ReadString(); break;
                        default: reader.Skip(wireType); break;
                    }
                }
            }

            private static void DecodeJoinRoomResponse(ReadOnlySpan<byte> data, JoinRoomResponse m)
            {
                var reader = new ProtoReader(data);
                while (reader.HasMore)
                {
                    var (tag, wireType) = reader.ReadTag();
                    switch (tag)
                    {
                        case 1: m.Success = reader.ReadBool(); break;
                        case 2: m.RoomId = reader.ReadInt32(); break;
                        case 3:
                            m.PlayerIds ??= new List<long>();
                            m.PlayerIds.Add(reader.ReadInt64());
                            break;
                        default: reader.Skip(wireType); break;
                    }
                }
            }

            private static void DecodeChatNotify(ReadOnlySpan<byte> data, ChatNotify m)
            {
                var reader = new ProtoReader(data);
                while (reader.HasMore)
                {
                    var (tag, wireType) = reader.ReadTag();
                    switch (tag)
                    {
                        case 1: m.Channel = reader.ReadInt32(); break;
                        case 2: m.SenderId = reader.ReadInt64(); break;
                        case 3: m.SenderName = reader.ReadString(); break;
                        case 4: m.Message = reader.ReadString(); break;
                        case 5: m.Timestamp = reader.ReadInt64(); break;
                        default: reader.Skip(wireType); break;
                    }
                }
            }

        }

        /// <summary>Sender interface for Proxy</summary>
        public interface ISender
        {
            void SendTo(int sessionId, ReadOnlySpan<byte> frame);
        }

        /// <summary>
        /// Abstract stub for Game2C handlers.
        /// Inherit and implement all On* methods.
        /// </summary>
        public abstract class Stub
        {
            protected ICodec Codec { get; }

            protected Stub(ICodec? codec = null)
            {
                Codec = codec ?? new CodecProtobuf();
            }

            public void Dispatch(PacketEnvelope envelope)
            {
                switch (envelope.Opcode)
                {
                    case Opcodes.LoginResponse:
                        var loginResponse = Codec.Decode<LoginResponse>(envelope.Payload);
                        OnLoginResponse(envelope.Meta, loginResponse);
                        break;
                    case Opcodes.JoinRoomResponse:
                        var joinRoomResponse = Codec.Decode<JoinRoomResponse>(envelope.Payload);
                        OnJoinRoomResponse(envelope.Meta, joinRoomResponse);
                        break;
                    case Opcodes.ChatNotify:
                        var chatNotify = Codec.Decode<ChatNotify>(envelope.Payload);
                        OnChatNotify(envelope.Meta, chatNotify);
                        break;
                }
            }

            protected abstract void OnLoginResponse(EnvelopeMeta meta, LoginResponse message);
            protected abstract void OnJoinRoomResponse(EnvelopeMeta meta, JoinRoomResponse message);
            protected abstract void OnChatNotify(EnvelopeMeta meta, ChatNotify message);
        }

        /// <summary>
        /// Runtime adapter implementing INetRuntime for Game2C.
        /// Bridges NetClient and generated Stub.
        /// </summary>
        public sealed class Runtime : Devian.INetRuntime
        {
            private readonly Stub _stub;

            public Runtime(Stub stub)
            {
                _stub = stub ?? throw new ArgumentNullException(nameof(stub));
            }

            /// <summary>
            /// Try to dispatch inbound packet. Returns true if opcode belongs to this protocol.
            /// </summary>
            public bool TryDispatchInbound(int sessionId, int opcode, ReadOnlySpan<byte> payload)
            {
                switch (opcode)
                {
                    case Opcodes.LoginResponse:
                    case Opcodes.JoinRoomResponse:
                    case Opcodes.ChatNotify:
                    {
                        var meta = new EnvelopeMeta(sessionId);
                        var envelope = new PacketEnvelope(opcode, payload, meta);
                        _stub.Dispatch(envelope);
                        return true;
                    }
                    default:
                        return false;
                }
            }
        }

        /// <summary>
        /// Proxy for sending Game2C messages.
        /// </summary>
        public sealed class Proxy
        {
            private readonly ISender _sender;
            private readonly ICodec _codec;

            public Proxy(ISender sender, ICodec? codec = null)
            {
                _sender = sender;
                _codec = codec ?? new CodecProtobuf();
            }

            public void SendLoginResponse(int sessionId, LoginResponse message)
            {
                var payload = _codec.Encode(message);
                var frame = Frame.Pack(Opcodes.LoginResponse, payload);
                _sender.SendTo(sessionId, frame);
            }

            public void SendJoinRoomResponse(int sessionId, JoinRoomResponse message)
            {
                var payload = _codec.Encode(message);
                var frame = Frame.Pack(Opcodes.JoinRoomResponse, payload);
                _sender.SendTo(sessionId, frame);
            }

            public void SendChatNotify(int sessionId, ChatNotify message)
            {
                var payload = _codec.Encode(message);
                var frame = Frame.Pack(Opcodes.ChatNotify, payload);
                _sender.SendTo(sessionId, frame);
            }

        }
    }
}
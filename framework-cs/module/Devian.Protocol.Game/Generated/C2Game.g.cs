// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System v10
// </auto-generated>

#nullable enable

using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Devian;

namespace Devian.Protocol.Game
{
    // Direction: client_to_server

    /// <summary>
    /// C2Game protocol container.
    /// </summary>
    public static partial class C2Game
    {
        /// <summary>
        /// Frame helper for protocol framing.
        /// Frame format: [opcode:int32LE][payload...]
        /// </summary>
        internal static class Frame
        {
            public static int ReadOpcode(ReadOnlySpan<byte> frame)
            {
                if (frame.Length < 4) throw new ArgumentException("Frame too short");
                return BitConverter.ToInt32(frame.Slice(0, 4));
            }

            public static ReadOnlySpan<byte> ReadPayload(ReadOnlySpan<byte> frame)
            {
                if (frame.Length < 4) return ReadOnlySpan<byte>.Empty;
                return frame.Slice(4);
            }

            public static byte[] Pack(int opcode, ReadOnlySpan<byte> payload)
            {
                var frame = new byte[4 + payload.Length];
                BitConverter.TryWriteBytes(frame.AsSpan(0, 4), opcode);
                payload.CopyTo(frame.AsSpan(4));
                return frame;
            }
        }

        /// <summary>Envelope metadata (sessionId 등)</summary>
        public readonly struct EnvelopeMeta
        {
            public int SessionId { get; }

            public EnvelopeMeta(int sessionId)
            {
                SessionId = sessionId;
            }
        }

        /// <summary>
        /// Packet envelope (ref struct - 복사/할당 방지)
        /// </summary>
        public ref struct PacketEnvelope
        {
            public int Opcode { get; }
            public ReadOnlySpan<byte> Payload { get; }
            public EnvelopeMeta Meta { get; }

            public PacketEnvelope(int opcode, ReadOnlySpan<byte> payload, EnvelopeMeta meta)
            {
                Opcode = opcode;
                Payload = payload;
                Meta = meta;
            }
        }

        /// <summary>
        /// Generic packet pool for message object reuse.
        /// </summary>
        internal sealed class PacketPool<T> where T : class, new()
        {
            private readonly Stack<T> _stack;
            private readonly int _max;

            public PacketPool(int max = 256)
            {
                _max = max;
                _stack = new Stack<T>(Math.Min(max, 32));
            }

            public T Rent()
            {
                lock (_stack)
                {
                    return _stack.Count > 0 ? _stack.Pop() : new T();
                }
            }

            public void Return(T item)
            {
                lock (_stack)
                {
                    if (_stack.Count < _max) _stack.Push(item);
                }
            }
        }

        /// <summary>
        /// Span-based protobuf reader (zero-copy, zero-alloc for string decode)
        /// </summary>
        internal ref struct ProtoReader
        {
            // Static UTF8 encoder to avoid repeated Encoding.UTF8 property access
            private static readonly Encoding Utf8 = Encoding.UTF8;

            private ReadOnlySpan<byte> _data;
            private int _pos;

            public ProtoReader(ReadOnlySpan<byte> data)
            {
                _data = data;
                _pos = 0;
            }

            public bool HasMore => _pos < _data.Length;
            public int Position => _pos;
            public int Remaining => _data.Length - _pos;

            public (int tag, int wireType) ReadTag()
            {
                var varint = ReadVarint();
                return ((int)(varint >> 3), (int)(varint & 0x7));
            }

            public long ReadVarint()
            {
                long result = 0;
                int shift = 0;
                while (_pos < _data.Length)
                {
                    byte b = _data[_pos++];
                    result |= (long)(b & 0x7F) << shift;
                    if ((b & 0x80) == 0) break;
                    shift += 7;
                }
                return result;
            }

            public int ReadInt32() => (int)ReadVarint();
            public long ReadInt64() => ReadVarint();
            public uint ReadUInt32() => (uint)ReadVarint();
            public ulong ReadUInt64() => (ulong)ReadVarint();
            public bool ReadBool() => ReadVarint() != 0;

            public int ReadSInt32()
            {
                var n = (uint)ReadVarint();
                return (int)((n >> 1) ^ -(int)(n & 1));
            }

            public long ReadSInt64()
            {
                var n = (ulong)ReadVarint();
                return (long)(n >> 1) ^ -(long)(n & 1);
            }

            public float ReadFloat()
            {
                var span = _data.Slice(_pos, 4);
                _pos += 4;
                return BitConverter.ToSingle(span);
            }

            public double ReadDouble()
            {
                var span = _data.Slice(_pos, 8);
                _pos += 8;
                return BitConverter.ToDouble(span);
            }

            /// <summary>
            /// Read string using span-based UTF8 decode (zero temp byte[] allocation).
            /// Only allocates the final string object.
            /// </summary>
            public string ReadString()
            {
                var len = (int)ReadVarint();
                if (len == 0) return string.Empty;
                // Zero-alloc path: decode directly from contiguous span
                var span = _data.Slice(_pos, len);
                _pos += len;
                return Utf8.GetString(span);
            }

            /// <summary>
            /// Read bytes field. Note: bytes fields inherently need array allocation
            /// since the message field type is byte[].
            /// </summary>
            public byte[] ReadBytes()
            {
                var len = (int)ReadVarint();
                if (len == 0) return Array.Empty<byte>();
                var result = _data.Slice(_pos, len).ToArray();
                _pos += len;
                return result;
            }

            /// <summary>
            /// Read length-delimited block length and return end position for packed repeated.
            /// Use with ReadPackedInt32/etc for zero-copy packed repeated decode.
            /// </summary>
            public int ReadLengthDelimitedEnd()
            {
                var len = (int)ReadVarint();
                return _pos + len;
            }

            public void Skip(int wireType)
            {
                switch (wireType)
                {
                    case 0: ReadVarint(); break;
                    case 1: _pos += 8; break;
                    case 2: _pos += (int)ReadVarint(); break;
                    case 5: _pos += 4; break;
                }
            }
        }

        /// <summary>
        /// Protobuf wire format writer helper (IBufferWriter-based, zero-alloc)
        /// </summary>
        private static class ProtoWriter
        {
            public static void WriteVarint(IBufferWriter<byte> w, ulong value)
            {
                Span<byte> buf = stackalloc byte[10];
                var i = 0;
                while (value >= 0x80)
                {
                    buf[i++] = (byte)(value | 0x80);
                    value >>= 7;
                }
                buf[i++] = (byte)value;
                var span = w.GetSpan(i);
                buf.Slice(0, i).CopyTo(span);
                w.Advance(i);
            }

            public static void WriteTag(IBufferWriter<byte> w, int tag, int wireType)
            {
                WriteVarint(w, (ulong)((tag << 3) | wireType));
            }

            public static void WriteString(IBufferWriter<byte> w, int tag, string? value)
            {
                if (string.IsNullOrEmpty(value)) return;
                WriteTag(w, tag, 2);
                var byteCount = Encoding.UTF8.GetByteCount(value);
                WriteVarint(w, (ulong)byteCount);
                if (byteCount <= 256)
                {
                    // Small string: write directly to span
                    var span = w.GetSpan(byteCount);
                    Encoding.UTF8.GetBytes(value.AsSpan(), span);
                    w.Advance(byteCount);
                }
                else
                {
                    // Large string: use pooled buffer
                    var rented = ArrayPool<byte>.Shared.Rent(byteCount);
                    try
                    {
                        Encoding.UTF8.GetBytes(value.AsSpan(), rented.AsSpan(0, byteCount));
                        var span = w.GetSpan(byteCount);
                        rented.AsSpan(0, byteCount).CopyTo(span);
                        w.Advance(byteCount);
                    }
                    finally
                    {
                        ArrayPool<byte>.Shared.Return(rented);
                    }
                }
            }

            public static void WriteInt32(IBufferWriter<byte> w, int tag, int value)
            {
                if (value == 0) return;
                WriteTag(w, tag, 0);
                WriteVarint(w, (ulong)value);
            }

            public static void WriteInt64(IBufferWriter<byte> w, int tag, long value)
            {
                if (value == 0) return;
                WriteTag(w, tag, 0);
                WriteVarint(w, (ulong)value);
            }

            public static void WriteBool(IBufferWriter<byte> w, int tag, bool value)
            {
                if (!value) return;
                WriteTag(w, tag, 0);
                var span = w.GetSpan(1);
                span[0] = 1;
                w.Advance(1);
            }

            public static void WriteBytes(IBufferWriter<byte> w, int tag, byte[]? value)
            {
                if (value == null || value.Length == 0) return;
                WriteTag(w, tag, 2);
                WriteVarint(w, (ulong)value.Length);
                var span = w.GetSpan(value.Length);
                value.AsSpan().CopyTo(span);
                w.Advance(value.Length);
            }

            public static void WriteFloat(IBufferWriter<byte> w, int tag, float value)
            {
                if (value == 0) return;
                WriteTag(w, tag, 5);
                var span = w.GetSpan(4);
                BitConverter.TryWriteBytes(span, value);
                w.Advance(4);
            }

            public static void WriteDouble(IBufferWriter<byte> w, int tag, double value)
            {
                if (value == 0) return;
                WriteTag(w, tag, 1);
                var span = w.GetSpan(8);
                BitConverter.TryWriteBytes(span, value);
                w.Advance(8);
            }
        }

        /// <summary>Ping message</summary>
        public sealed class Ping
        {
            public long Timestamp { get; set; }
            public string? Payload { get; set; } = string.Empty;

            internal void _Reset()
            {
                Timestamp = default;
                Payload = string.Empty;
            }
        }

        /// <summary>Echo message</summary>
        public sealed class Echo
        {
            public string Message { get; set; } = string.Empty;

            internal void _Reset()
            {
                Message = string.Empty;
            }
        }

        /// <summary>Opcode constants</summary>
        public static class Opcodes
        {
            public const int Ping = 1001;
            public const int Echo = 1000;

            public static string? GetName(int opcode) => opcode switch
            {
                1001 => nameof(Ping),
                1000 => nameof(Echo),
                _ => null
            };
        }

        /// <summary>Codec interface</summary>
        public interface ICodec
        {
            /// <summary>Encode to byte array (legacy, avoid in hot path)</summary>
            byte[] Encode<T>(T message) where T : class;
            /// <summary>Encode directly to IBufferWriter (zero-alloc send path)</summary>
            void EncodeTo<T>(IBufferWriter<byte> writer, T message) where T : class;
            T Decode<T>(ReadOnlySpan<byte> data) where T : class, new();
            object? Decode(int opcode, ReadOnlySpan<byte> data);
        }

        /// <summary>Protobuf Codec implementation</summary>
        public sealed class CodecProtobuf : ICodec
        {
            public byte[] Encode<T>(T message) where T : class
            {
                // Legacy path: uses PooledBufferWriter then copies to byte[]
                using var bw = new PooledBufferWriter(256);
                EncodeTo(bw, message);
                return bw.WrittenSpan.ToArray();
            }

            public void EncodeTo<T>(IBufferWriter<byte> writer, T message) where T : class
            {
                switch (message)
                {
                    case Ping m: EncodePing(writer, m); break;
                    case Echo m: EncodeEcho(writer, m); break;
                    default: throw new ArgumentException($"Unknown message type: {typeof(T).Name}");
                }
            }

            public T Decode<T>(ReadOnlySpan<byte> data) where T : class, new()
            {
                var result = new T();
                switch (result)
                {
                    case Ping m: DecodePing(data, m); break;
                    case Echo m: DecodeEcho(data, m); break;
                }
                return result;
            }

            public object? Decode(int opcode, ReadOnlySpan<byte> data)
            {
                return opcode switch
                {
                    Opcodes.Ping => Decode<Ping>(data),
                    Opcodes.Echo => Decode<Echo>(data),
                    _ => null
                };
            }

            private static void EncodePing(IBufferWriter<byte> writer, Ping m)
            {
                ProtoWriter.WriteInt64(writer, 1, m.Timestamp);
                ProtoWriter.WriteString(writer, 2, m.Payload);
            }

            private static void EncodeEcho(IBufferWriter<byte> writer, Echo m)
            {
                ProtoWriter.WriteString(writer, 1, m.Message);
            }

            internal static void DecodePing(ReadOnlySpan<byte> data, Ping m)
            {
                var reader = new ProtoReader(data);
                while (reader.HasMore)
                {
                    var (tag, wireType) = reader.ReadTag();
                    switch (tag)
                    {
                        case 1: m.Timestamp = reader.ReadInt64(); break;
                        case 2: m.Payload = reader.ReadString(); break;
                        default: reader.Skip(wireType); break;
                    }
                }
            }

            internal static void DecodeEcho(ReadOnlySpan<byte> data, Echo m)
            {
                var reader = new ProtoReader(data);
                while (reader.HasMore)
                {
                    var (tag, wireType) = reader.ReadTag();
                    switch (tag)
                    {
                        case 1: m.Message = reader.ReadString(); break;
                        default: reader.Skip(wireType); break;
                    }
                }
            }

        }

        /// <summary>Sender interface for Proxy</summary>
        public interface ISender
        {
            void SendTo(ReadOnlySpan<byte> frame);
        }

        /// <summary>
        /// Abstract stub for C2Game handlers.
        /// Inherit and implement all On* methods.
        /// </summary>
        public abstract class Stub
        {
            protected ICodec Codec { get; }

            protected Stub(ICodec? codec = null)
            {
                Codec = codec ?? new CodecProtobuf();
            }

            public void Dispatch(PacketEnvelope envelope)
            {
                switch (envelope.Opcode)
                {
                    case Opcodes.Ping:
                        var ping = Codec.Decode<Ping>(envelope.Payload);
                        OnPing(envelope.Meta, ping);
                        break;
                    case Opcodes.Echo:
                        var echo = Codec.Decode<Echo>(envelope.Payload);
                        OnEcho(envelope.Meta, echo);
                        break;
                }
            }

            protected abstract void OnPing(EnvelopeMeta meta, Ping message);
            protected abstract void OnEcho(EnvelopeMeta meta, Echo message);
        }

        /// <summary>
        /// Runtime adapter implementing INetRuntime for C2Game.
        /// Bridges NetClient and generated Stub.
        /// </summary>
        public sealed class Runtime : Devian.INetRuntime
        {
            private readonly Stub _stub;

            public Runtime(Stub stub)
            {
                _stub = stub ?? throw new ArgumentNullException(nameof(stub));
            }

            /// <summary>
            /// Try to dispatch inbound packet. Returns true if opcode belongs to this protocol.
            /// </summary>
            public bool TryDispatchInbound(int sessionId, int opcode, ReadOnlySpan<byte> payload)
            {
                switch (opcode)
                {
                    case Opcodes.Ping:
                    case Opcodes.Echo:
                    {
                        var meta = new EnvelopeMeta(sessionId);
                        var envelope = new PacketEnvelope(opcode, payload, meta);
                        _stub.Dispatch(envelope);
                        return true;
                    }
                    default:
                        return false;
                }
            }
        }

        /// <summary>
        /// Proxy for sending C2Game messages.
        /// Uses INetSession/INetConnector for protocol-agnostic session management.
        /// Inbound dispatch uses Game2C.Runtime.
        /// </summary>
        public sealed class Proxy : IDisposable
        {
            // ======== Session (interface-based, no concrete types) ========
            private INetSession? _session;
            private string _url = string.Empty;
            private string _lastError = string.Empty;
            private volatile bool _isConnecting; // Re-entry guard flag
            private bool _errorNotified; // Error dedup guard (max 1 OnError per attempt)

            // ======== Codec ========
            private readonly ICodec _codec;

            // ======== Events ========
            public event Action? OnOpen;
            public event Action<ushort, string>? OnClose;
            public event Action<Exception>? OnError;

            // ======== Properties ========
            public bool IsConnected => _session?.State == NetClientState.Connected;
            public bool IsConnecting => _isConnecting;
            public string Url => _url;
            public string LastError => _lastError;

            // ======== Constructor ========
            public Proxy(ICodec? codec = null)
            {
                _codec = codec ?? new CodecProtobuf();
            }

            // ======== Connection Lifecycle API ========

            /// <summary>
            /// Connect to server using the provided connector.
            /// Previous session is always disposed before creating a new one.
            /// Stub must be Game2C.Stub for inbound message dispatch.
            /// </summary>
            public void Connect(Game2C.Stub stub, string url, INetConnector connector)
            {
                if (stub == null) throw new ArgumentNullException(nameof(stub));
                if (string.IsNullOrEmpty(url)) throw new ArgumentException("url is empty", nameof(url));
                if (connector == null) throw new ArgumentNullException(nameof(connector));

                // Always dispose previous session to prevent stale event handler leaks.
                // Without this, prior session continuations can fire HandleError on the
                // current Proxy after a new session is already created.
                if (_session != null)
                    DisposeConnection();

                _url = url;
                _lastError = string.Empty;
                _isConnecting = true; // Set before session creation to prevent re-entry
                _errorNotified = false; // Reset error dedup guard for new attempt

                // Inbound dispatch runtime (Game2C)
                var runtime = new Game2C.Runtime(stub);

                // Create session via connector (no concrete types here)
                var session = connector.CreateSession(runtime, url);
                session.OnOpen += HandleOpen;
                session.OnClose += HandleClose;
                session.OnError += HandleError;

                _session = session;
                _ = session.ConnectAsync().ContinueWith(t => { var ex = t.Exception; }, System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted | System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously);
            }

            /// <summary>
            /// Process network events. Call from Update() loop.
            /// </summary>
            public void Tick()
            {
                _session?.Tick();
            }

            /// <summary>
            /// Request graceful disconnect.
            /// </summary>
            public void Disconnect()
            {
                if (_session == null) return;
                _ = _session.CloseAsync();
            }

            /// <summary>
            /// Dispose connection resources.
            /// </summary>
            public void Dispose()
            {
                DisposeConnection();
            }

            private void DisposeConnection()
            {
                _isConnecting = false; // Clear flag first
                _errorNotified = false; // Reset error dedup guard

                var s = _session;
                if (s == null) return;

                s.OnOpen -= HandleOpen;
                s.OnClose -= HandleClose;
                s.OnError -= HandleError;

                if (s is IDisposable d) d.Dispose();
                _session = null;
            }

            // ======== Internal Event Handlers ========

            private void HandleOpen()
            {
                _isConnecting = false;
                _errorNotified = false; // Reset for connected state
                OnOpen?.Invoke();
            }

            private void HandleClose(ushort code, string reason)
            {
                _isConnecting = false;
                OnClose?.Invoke(code, reason);
            }

            private void HandleError(Exception ex)
            {
                _isConnecting = false;
                _lastError = ex.Message;
                if (_errorNotified)
                    return;
                _errorNotified = true;
                OnError?.Invoke(ex);
            }

            // ======== Session Attachment (for WsClient shared session) ========

            /// <summary>
            /// Attach an externally created session for sending.
            /// Used by WsClient to share a single session across protocols.
            /// </summary>
            public void AttachSession(INetSession session)
            {
                _session = session ?? throw new ArgumentNullException(nameof(session));
            }

            // ======== Send Methods ========
            // Uses PooledBufferWriter + EncodeTo for zero GC allocation.
            // Frame format: [opcode:int32LE][payload...]

            public void SendPing(Ping message)
            {
                var session = _session ?? throw new InvalidOperationException("Proxy is not connected. Call Connect() or AttachSession() first.");

                using var bw = new PooledBufferWriter(256);

                // Write opcode (4 bytes LE)
                var span = bw.GetSpan(4);
                BitConverter.TryWriteBytes(span, Opcodes.Ping);
                bw.Advance(4);

                // Encode payload directly to buffer
                _codec.EncodeTo(bw, message);

                // Send frame
                session.SendTo(bw.WrittenSpan);
            }

            public void SendEcho(Echo message)
            {
                var session = _session ?? throw new InvalidOperationException("Proxy is not connected. Call Connect() or AttachSession() first.");

                using var bw = new PooledBufferWriter(256);

                // Write opcode (4 bytes LE)
                var span = bw.GetSpan(4);
                BitConverter.TryWriteBytes(span, Opcodes.Echo);
                bw.Advance(4);

                // Encode payload directly to buffer
                _codec.EncodeTo(bw, message);

                // Send frame
                session.SendTo(bw.WrittenSpan);
            }

        }

        // ============================================================================
        // Pooling API - RentDecodePooled / ReturnPooled
        // SSOT: skills/devian-builder/40-codegen-protocol/SKILL.md
        // ============================================================================

        private static readonly PacketPool<Ping> _pool_Ping = new PacketPool<Ping>(256);
        private static readonly PacketPool<Echo> _pool_Echo = new PacketPool<Echo>(256);

        /// <summary>
        /// Rent a pooled message object and decode from data.
        /// Call ReturnPooled() when done to return the object to the pool.
        /// </summary>
        public static object? RentDecodePooled(int opcode, ReadOnlySpan<byte> data)
        {
            switch (opcode)
            {
                case Opcodes.Ping:
                {
                    var m = _pool_Ping.Rent();
                    m._Reset();
                    CodecProtobuf.DecodePing(data, m);
                    return m;
                }
                case Opcodes.Echo:
                {
                    var m = _pool_Echo.Rent();
                    m._Reset();
                    CodecProtobuf.DecodeEcho(data, m);
                    return m;
                }
                default:
                    return null;
            }
        }

        /// <summary>
        /// Rent a pooled message object of type T and decode from data.
        /// Call ReturnPooled() when done to return the object to the pool.
        /// </summary>
        public static T RentDecodePooled<T>(ReadOnlySpan<byte> data) where T : class, new()
        {
            object pooled;
            if (typeof(T) == typeof(Ping))
            {
                var m = _pool_Ping.Rent();
                m._Reset();
                CodecProtobuf.DecodePing(data, m);
                pooled = m;
            }
            else if (typeof(T) == typeof(Echo))
            {
                var m = _pool_Echo.Rent();
                m._Reset();
                CodecProtobuf.DecodeEcho(data, m);
                pooled = m;
            }
            else
            {
                // Fallback: create new instance (not pooled)
                var codec = new CodecProtobuf();
                return codec.Decode<T>(data);
            }
            return (T)pooled;
        }

        /// <summary>
        /// Return a pooled message object to the pool.
        /// The object will be reset before being returned.
        /// </summary>
        public static void ReturnPooled(object message)
        {
            switch (message)
            {
                case Ping m:
                    m._Reset();
                    _pool_Ping.Return(m);
                    break;
                case Echo m:
                    m._Reset();
                    _pool_Echo.Return(m);
                    break;
                default:
                    // Unknown type - silently ignore (no crash for user error)
                    break;
            }
        }

        /// <summary>
        /// Return a pooled message object of type T to the pool.
        /// </summary>
        public static void ReturnPooled<T>(T message) where T : class
        {
            if (message == null) return;
            ReturnPooled((object)message);
        }
    }
}
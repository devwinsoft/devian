// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System v10
// GameWsClient: WebSocket client binding for Game protocol group.
// 
// Usage:
//   var client = new GameWsClient();
//   client.Connect("wss://...");
//   // Implement handlers via partial class
//   // Send messages via client.C2GameProxy.SendXxx(...)
//   // Call client.Tick() each frame
// </auto-generated>

#nullable enable

using System;
using Devian;

namespace Devian.Protocol.Game
{
    /// <summary>
    /// WebSocket client for Game protocol group.
    /// Uses INetSession/INetConnector for protocol-agnostic session management.
    /// Implements INetTickable for unified tick management.
    /// </summary>
    public sealed class GameWsClient : INetTickable, IDisposable
    {
        // ======== Inbound Handlers ========
        public Game2C_Handlers Game2CHandlers { get; }

        // ======== Outbound Proxies ========
        public C2Game.Proxy C2GameProxy { get; }

        // ======== Session Infrastructure ========
        private INetSession? _session;
        private readonly INetConnector _connector;
        private string _url = string.Empty;
        private string _lastError = string.Empty;

        // ======== Runtime Multiplexer ========
        private sealed class RuntimeMux : INetRuntime
        {
            private readonly Game2C.Runtime _game2CRuntime;

            public RuntimeMux(
                Game2C.Runtime game2CRuntime
            )
            {
                _game2CRuntime = game2CRuntime;
            }

            public bool TryDispatchInbound(int sessionId, int opcode, ReadOnlySpan<byte> payload)
            {
                if (_game2CRuntime.TryDispatchInbound(sessionId, opcode, payload)) return true;
                return false;
            }
        }

        // ======== Constructor ========
        public GameWsClient(INetConnector? connector = null)
        {
            // Create handlers
            Game2CHandlers = new Game2C_Handlers();

            // Create proxies
            C2GameProxy = new C2Game.Proxy();

            // Use provided connector or create default
            _connector = connector ?? new NetWsConnector();
        }

        // ======== Properties ========
        public bool IsConnected => _session?.State == NetClientState.Connected;
        public string Url => _url;
        public string LastError => _lastError;

        // ======== Connection Lifecycle ========

        /// <summary>
        /// Connect to server. Creates session via INetConnector.
        /// </summary>
        public void Connect(string url)
        {
            if (string.IsNullOrEmpty(url)) throw new ArgumentException("url is empty", nameof(url));

            DisposeSession();

            _url = url;
            _lastError = string.Empty;

            // Create runtime multiplexer from handlers
            var runtimeMux = new RuntimeMux(
                new Game2C.Runtime(Game2CHandlers)
            );

            // Create session via connector
            var session = _connector.CreateSession(runtimeMux, url);
            session.OnOpen += HandleOpen;
            session.OnClose += HandleClose;
            session.OnError += HandleError;

            // Attach session to proxies for sending
            C2GameProxy.AttachSession(session);

            _session = session;
            _ = session.ConnectAsync();
        }

        /// <summary>
        /// Process network events. Call from Update() loop.
        /// </summary>
        public void Tick()
        {
            _session?.Tick();
        }

        /// <summary>
        /// Request graceful disconnect.
        /// </summary>
        public void Close()
        {
            if (_session == null) return;
            _ = _session.CloseAsync();
        }

        /// <summary>
        /// Dispose connection resources.
        /// </summary>
        public void Dispose()
        {
            DisposeSession();
        }

        private void DisposeSession()
        {
            if (_session != null)
            {
                _session.OnOpen -= HandleOpen;
                _session.OnClose -= HandleClose;
                _session.OnError -= HandleError;
                (_session as IDisposable)?.Dispose();
                _session = null;
            }
        }

        // ======== Internal Event Handlers ========

        private void HandleOpen()
        {
            OnOpen?.Invoke();
        }

        private void HandleClose(ushort code, string reason)
        {
            OnClose?.Invoke(code, reason);
        }

        private void HandleError(Exception ex)
        {
            _lastError = ex.Message;
            OnError?.Invoke(ex);
        }

        // ======== Events ========
        public event Action? OnOpen;
        public event Action<ushort, string>? OnClose;
        public event Action<Exception>? OnError;
    }
}
// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System v10
// </auto-generated>

#nullable enable

using System;
using System.Buffers;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Devian;

namespace Devian.Protocol.Game
{
    // Direction: client_to_server

    /// <summary>
    /// C2Game protocol container.
    /// </summary>
    public static partial class C2Game
    {
        /// <summary>
        /// Frame helper for protocol framing.
        /// Frame format: [opcode:int32LE][payload...]
        /// </summary>
        internal static class Frame
        {
            public static int ReadOpcode(ReadOnlySpan<byte> frame)
            {
                if (frame.Length < 4) throw new ArgumentException("Frame too short");
                return BitConverter.ToInt32(frame.Slice(0, 4));
            }

            public static ReadOnlySpan<byte> ReadPayload(ReadOnlySpan<byte> frame)
            {
                if (frame.Length < 4) return ReadOnlySpan<byte>.Empty;
                return frame.Slice(4);
            }

            public static byte[] Pack(int opcode, ReadOnlySpan<byte> payload)
            {
                var frame = new byte[4 + payload.Length];
                BitConverter.TryWriteBytes(frame.AsSpan(0, 4), opcode);
                payload.CopyTo(frame.AsSpan(4));
                return frame;
            }
        }

        /// <summary>Envelope metadata (sessionId 등)</summary>
        public readonly struct EnvelopeMeta
        {
            public int SessionId { get; }

            public EnvelopeMeta(int sessionId)
            {
                SessionId = sessionId;
            }
        }

        /// <summary>
        /// Packet envelope (ref struct - 복사/할당 방지)
        /// </summary>
        public ref struct PacketEnvelope
        {
            public int Opcode { get; }
            public ReadOnlySpan<byte> Payload { get; }
            public EnvelopeMeta Meta { get; }

            public PacketEnvelope(int opcode, ReadOnlySpan<byte> payload, EnvelopeMeta meta)
            {
                Opcode = opcode;
                Payload = payload;
                Meta = meta;
            }
        }

        /// <summary>
        /// Generic packet pool for message object reuse.
        /// </summary>
        internal sealed class PacketPool<T> where T : class, new()
        {
            private readonly Stack<T> _stack;
            private readonly int _max;

            public PacketPool(int max = 256)
            {
                _max = max;
                _stack = new Stack<T>(Math.Min(max, 32));
            }

            public T Rent()
            {
                lock (_stack)
                {
                    return _stack.Count > 0 ? _stack.Pop() : new T();
                }
            }

            public void Return(T item)
            {
                lock (_stack)
                {
                    if (_stack.Count < _max) _stack.Push(item);
                }
            }
        }

        /// <summary>
        /// Span-based protobuf reader (zero-copy)
        /// </summary>
        internal ref struct ProtoReader
        {
            private ReadOnlySpan<byte> _data;
            private int _pos;

            public ProtoReader(ReadOnlySpan<byte> data)
            {
                _data = data;
                _pos = 0;
            }

            public bool HasMore => _pos < _data.Length;

            public (int tag, int wireType) ReadTag()
            {
                var varint = ReadVarint();
                return ((int)(varint >> 3), (int)(varint & 0x7));
            }

            public long ReadVarint()
            {
                long result = 0;
                int shift = 0;
                while (_pos < _data.Length)
                {
                    byte b = _data[_pos++];
                    result |= (long)(b & 0x7F) << shift;
                    if ((b & 0x80) == 0) break;
                    shift += 7;
                }
                return result;
            }

            public int ReadInt32() => (int)ReadVarint();
            public long ReadInt64() => ReadVarint();
            public uint ReadUInt32() => (uint)ReadVarint();
            public ulong ReadUInt64() => (ulong)ReadVarint();
            public bool ReadBool() => ReadVarint() != 0;

            public int ReadSInt32()
            {
                var n = (uint)ReadVarint();
                return (int)((n >> 1) ^ -(int)(n & 1));
            }

            public long ReadSInt64()
            {
                var n = (ulong)ReadVarint();
                return (long)(n >> 1) ^ -(long)(n & 1);
            }

            public float ReadFloat()
            {
                var bytes = _data.Slice(_pos, 4);
                _pos += 4;
                return BitConverter.ToSingle(bytes);
            }

            public double ReadDouble()
            {
                var bytes = _data.Slice(_pos, 8);
                _pos += 8;
                return BitConverter.ToDouble(bytes);
            }

            public string ReadString()
            {
                var len = (int)ReadVarint();
                if (len == 0) return string.Empty;
                var bytes = _data.Slice(_pos, len);
                _pos += len;
                return Encoding.UTF8.GetString(bytes);
            }

            public byte[] ReadBytes()
            {
                var len = (int)ReadVarint();
                if (len == 0) return Array.Empty<byte>();
                var bytes = _data.Slice(_pos, len).ToArray();
                _pos += len;
                return bytes;
            }

            public void Skip(int wireType)
            {
                switch (wireType)
                {
                    case 0: ReadVarint(); break;
                    case 1: _pos += 8; break;
                    case 2: _pos += (int)ReadVarint(); break;
                    case 5: _pos += 4; break;
                }
            }
        }

        /// <summary>
        /// Protobuf wire format writer helper
        /// </summary>
        private static class ProtoWriter
        {
            public static void WriteVarint(MemoryStream ms, long value)
            {
                var uval = (ulong)value;
                while (uval >= 0x80)
                {
                    ms.WriteByte((byte)(uval | 0x80));
                    uval >>= 7;
                }
                ms.WriteByte((byte)uval);
            }

            public static void WriteTag(MemoryStream ms, int tag, int wireType)
            {
                WriteVarint(ms, (tag << 3) | wireType);
            }

            public static void WriteString(MemoryStream ms, int tag, string? value)
            {
                if (string.IsNullOrEmpty(value)) return;
                WriteTag(ms, tag, 2);
                var bytes = Encoding.UTF8.GetBytes(value);
                WriteVarint(ms, bytes.Length);
                ms.Write(bytes, 0, bytes.Length);
            }

            public static void WriteInt32(MemoryStream ms, int tag, int value)
            {
                if (value == 0) return;
                WriteTag(ms, tag, 0);
                WriteVarint(ms, value);
            }

            public static void WriteInt64(MemoryStream ms, int tag, long value)
            {
                if (value == 0) return;
                WriteTag(ms, tag, 0);
                WriteVarint(ms, value);
            }

            public static void WriteBool(MemoryStream ms, int tag, bool value)
            {
                if (!value) return;
                WriteTag(ms, tag, 0);
                ms.WriteByte(1);
            }

            public static void WriteBytes(MemoryStream ms, int tag, byte[]? value)
            {
                if (value == null || value.Length == 0) return;
                WriteTag(ms, tag, 2);
                WriteVarint(ms, value.Length);
                ms.Write(value, 0, value.Length);
            }

            public static void WriteFloat(MemoryStream ms, int tag, float value)
            {
                if (value == 0) return;
                WriteTag(ms, tag, 5);
                var bytes = BitConverter.GetBytes(value);
                ms.Write(bytes, 0, 4);
            }

            public static void WriteDouble(MemoryStream ms, int tag, double value)
            {
                if (value == 0) return;
                WriteTag(ms, tag, 1);
                var bytes = BitConverter.GetBytes(value);
                ms.Write(bytes, 0, 8);
            }
        }

        /// <summary>Ping message</summary>
        public sealed class Ping
        {
            public long Timestamp { get; set; }
            public string? Payload { get; set; } = string.Empty;

            internal void _Reset()
            {
                Timestamp = default;
                Payload = string.Empty;
            }
        }

        /// <summary>Echo message</summary>
        public sealed class Echo
        {
            public string Message { get; set; } = string.Empty;

            internal void _Reset()
            {
                Message = string.Empty;
            }
        }

        /// <summary>Opcode constants</summary>
        public static class Opcodes
        {
            public const int Ping = 1001;
            public const int Echo = 1000;

            public static string? GetName(int opcode) => opcode switch
            {
                1001 => nameof(Ping),
                1000 => nameof(Echo),
                _ => null
            };
        }

        /// <summary>Codec interface</summary>
        public interface ICodec
        {
            byte[] Encode<T>(T message) where T : class;
            T Decode<T>(ReadOnlySpan<byte> data) where T : class, new();
            object? Decode(int opcode, ReadOnlySpan<byte> data);
        }

        /// <summary>Protobuf Codec implementation</summary>
        public sealed class CodecProtobuf : ICodec
        {
            public byte[] Encode<T>(T message) where T : class
            {
                using var ms = new MemoryStream();
                switch (message)
                {
                    case Ping m: EncodePing(ms, m); break;
                    case Echo m: EncodeEcho(ms, m); break;
                    default: throw new ArgumentException($"Unknown message type: {typeof(T).Name}");
                }
                return ms.ToArray();
            }

            public T Decode<T>(ReadOnlySpan<byte> data) where T : class, new()
            {
                var result = new T();
                switch (result)
                {
                    case Ping m: DecodePing(data, m); break;
                    case Echo m: DecodeEcho(data, m); break;
                }
                return result;
            }

            public object? Decode(int opcode, ReadOnlySpan<byte> data)
            {
                return opcode switch
                {
                    Opcodes.Ping => Decode<Ping>(data),
                    Opcodes.Echo => Decode<Echo>(data),
                    _ => null
                };
            }

            private static void EncodePing(MemoryStream ms, Ping m)
            {
                ProtoWriter.WriteInt64(ms, 1, m.Timestamp);
                ProtoWriter.WriteString(ms, 2, m.Payload);
            }

            private static void EncodeEcho(MemoryStream ms, Echo m)
            {
                ProtoWriter.WriteString(ms, 1, m.Message);
            }

            internal static void DecodePing(ReadOnlySpan<byte> data, Ping m)
            {
                var reader = new ProtoReader(data);
                while (reader.HasMore)
                {
                    var (tag, wireType) = reader.ReadTag();
                    switch (tag)
                    {
                        case 1: m.Timestamp = reader.ReadInt64(); break;
                        case 2: m.Payload = reader.ReadString(); break;
                        default: reader.Skip(wireType); break;
                    }
                }
            }

            internal static void DecodeEcho(ReadOnlySpan<byte> data, Echo m)
            {
                var reader = new ProtoReader(data);
                while (reader.HasMore)
                {
                    var (tag, wireType) = reader.ReadTag();
                    switch (tag)
                    {
                        case 1: m.Message = reader.ReadString(); break;
                        default: reader.Skip(wireType); break;
                    }
                }
            }

        }

        /// <summary>Sender interface for Proxy</summary>
        public interface ISender
        {
            void SendTo(int sessionId, ReadOnlySpan<byte> frame);
        }

        /// <summary>
        /// Abstract stub for C2Game handlers.
        /// Inherit and implement all On* methods.
        /// </summary>
        public abstract class Stub
        {
            protected ICodec Codec { get; }

            protected Stub(ICodec? codec = null)
            {
                Codec = codec ?? new CodecProtobuf();
            }

            public void Dispatch(PacketEnvelope envelope)
            {
                switch (envelope.Opcode)
                {
                    case Opcodes.Ping:
                        var ping = Codec.Decode<Ping>(envelope.Payload);
                        OnPing(envelope.Meta, ping);
                        break;
                    case Opcodes.Echo:
                        var echo = Codec.Decode<Echo>(envelope.Payload);
                        OnEcho(envelope.Meta, echo);
                        break;
                }
            }

            protected abstract void OnPing(EnvelopeMeta meta, Ping message);
            protected abstract void OnEcho(EnvelopeMeta meta, Echo message);
        }

        /// <summary>
        /// Runtime adapter implementing INetRuntime for C2Game.
        /// Bridges NetClient and generated Stub.
        /// </summary>
        public sealed class Runtime : Devian.INetRuntime
        {
            private readonly Stub _stub;

            public Runtime(Stub stub)
            {
                _stub = stub ?? throw new ArgumentNullException(nameof(stub));
            }

            /// <summary>
            /// Try to dispatch inbound packet. Returns true if opcode belongs to this protocol.
            /// </summary>
            public bool TryDispatchInbound(int sessionId, int opcode, ReadOnlySpan<byte> payload)
            {
                switch (opcode)
                {
                    case Opcodes.Ping:
                    case Opcodes.Echo:
                    {
                        var meta = new EnvelopeMeta(sessionId);
                        var envelope = new PacketEnvelope(opcode, payload, meta);
                        _stub.Dispatch(envelope);
                        return true;
                    }
                    default:
                        return false;
                }
            }
        }

        /// <summary>
        /// Proxy for sending C2Game messages.
        /// </summary>
        public sealed class Proxy
        {
            private readonly ISender _sender;
            private readonly ICodec _codec;

            public Proxy(ISender sender, ICodec? codec = null)
            {
                _sender = sender;
                _codec = codec ?? new CodecProtobuf();
            }

            public void SendPing(int sessionId, Ping message)
            {
                var payload = _codec.Encode(message);
                var frame = Frame.Pack(Opcodes.Ping, payload);
                _sender.SendTo(sessionId, frame);
            }

            public void SendEcho(int sessionId, Echo message)
            {
                var payload = _codec.Encode(message);
                var frame = Frame.Pack(Opcodes.Echo, payload);
                _sender.SendTo(sessionId, frame);
            }

        }

        // ============================================================================
        // Pooling API - RentDecodePooled / ReturnPooled
        // SSOT: skills/devian-protocol/40-codegen-protocol/SKILL.md
        // ============================================================================

        private static readonly PacketPool<Ping> _pool_Ping = new PacketPool<Ping>(256);
        private static readonly PacketPool<Echo> _pool_Echo = new PacketPool<Echo>(256);

        /// <summary>
        /// Rent a pooled message object and decode from data.
        /// Call ReturnPooled() when done to return the object to the pool.
        /// </summary>
        public static object? RentDecodePooled(int opcode, ReadOnlySpan<byte> data)
        {
            switch (opcode)
            {
                case Opcodes.Ping:
                {
                    var m = _pool_Ping.Rent();
                    m._Reset();
                    CodecProtobuf.DecodePing(data, m);
                    return m;
                }
                case Opcodes.Echo:
                {
                    var m = _pool_Echo.Rent();
                    m._Reset();
                    CodecProtobuf.DecodeEcho(data, m);
                    return m;
                }
                default:
                    return null;
            }
        }

        /// <summary>
        /// Rent a pooled message object of type T and decode from data.
        /// Call ReturnPooled() when done to return the object to the pool.
        /// </summary>
        public static T RentDecodePooled<T>(ReadOnlySpan<byte> data) where T : class, new()
        {
            object pooled;
            if (typeof(T) == typeof(Ping))
            {
                var m = _pool_Ping.Rent();
                m._Reset();
                CodecProtobuf.DecodePing(data, m);
                pooled = m;
            }
            else if (typeof(T) == typeof(Echo))
            {
                var m = _pool_Echo.Rent();
                m._Reset();
                CodecProtobuf.DecodeEcho(data, m);
                pooled = m;
            }
            else
            {
                // Fallback: create new instance (not pooled)
                var codec = new CodecProtobuf();
                return codec.Decode<T>(data);
            }
            return (T)pooled;
        }

        /// <summary>
        /// Return a pooled message object to the pool.
        /// The object will be reset before being returned.
        /// </summary>
        public static void ReturnPooled(object message)
        {
            switch (message)
            {
                case Ping m:
                    m._Reset();
                    _pool_Ping.Return(m);
                    break;
                case Echo m:
                    m._Reset();
                    _pool_Echo.Return(m);
                    break;
                default:
                    // Unknown type - silently ignore (no crash for user error)
                    break;
            }
        }

        /// <summary>
        /// Return a pooled message object of type T to the pool.
        /// </summary>
        public static void ReturnPooled<T>(T message) where T : class
        {
            if (message == null) return;
            ReturnPooled((object)message);
        }
    }
}
// <auto-generated>
// Devian Unity Editor - TableID Selector Base (ScriptableWizard)
// </auto-generated>

#if UNITY_EDITOR

using System;
using System.Collections.Generic;
using System.Linq;
using UnityEditor;
using UnityEngine;

namespace Devian.Unity
{
    /// <summary>
    /// Base class for TableID Selector (ScriptableWizard).
    /// Provides search, grid selection, and value assignment.
    /// </summary>
    public abstract class EditorID_SelectorBase : ScriptableWizard
    {
        private const int ColumnCount = 4;
        private const string NoneOption = "(none)";

        private SerializedProperty? _targetProperty;
        private Dictionary<string, string> _items = new(); // key -> display
        private List<string> _filteredKeys = new();
        private string _searchText = string.Empty;
        private Vector2 _scrollPosition;
        private int _selectedIndex = 0;

        /// <summary>
        /// Show the selector for a property.
        /// </summary>
        public void Show(SerializedProperty property)
        {
            _targetProperty = property;
            titleContent = new GUIContent($"Select {GetDisplayTypeName()}");
        }

        /// <summary>
        /// Initialize with current value and select it.
        /// </summary>
        public void Init(string currentValue)
        {
            _searchText = string.Empty;
            RefreshFilteredList();

            // Find and select current value
            if (!string.IsNullOrEmpty(currentValue))
            {
                var index = _filteredKeys.FindIndex(k => 
                    string.Equals(k, currentValue, StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(_items.GetValueOrDefault(k, k), currentValue, StringComparison.OrdinalIgnoreCase));
                
                if (index >= 0)
                {
                    _selectedIndex = index + 1; // +1 for none option
                }
            }
        }

        /// <summary>
        /// Reload data from table. Derived classes must implement this.
        /// </summary>
        public abstract void Reload();

        /// <summary>
        /// Get display type name for title.
        /// </summary>
        protected abstract string GetDisplayTypeName();

        /// <summary>
        /// Add an item to the selector.
        /// </summary>
        /// <param name="key">Key value (to be set as Value)</param>
        /// <param name="display">Display text (optional, defaults to key)</param>
        protected void AddItem(string key, string? display = null)
        {
            _items[key] = display ?? key;
        }

        /// <summary>
        /// Clear all items.
        /// </summary>
        protected void ClearItems()
        {
            _items.Clear();
            _filteredKeys.Clear();
            _selectedIndex = 0;
        }

        private void RefreshFilteredList()
        {
            if (string.IsNullOrEmpty(_searchText))
            {
                _filteredKeys = _items.Keys.OrderBy(k => k).ToList();
            }
            else
            {
                var search = _searchText.ToLowerInvariant();
                _filteredKeys = _items
                    .Where(kv => kv.Key.ToLowerInvariant().Contains(search) ||
                                 kv.Value.ToLowerInvariant().Contains(search))
                    .Select(kv => kv.Key)
                    .OrderBy(k => k)
                    .ToList();
            }
        }

        protected virtual void OnGUI()
        {
            // Search field
            EditorGUILayout.BeginHorizontal();
            EditorGUILayout.LabelField("Search:", GUILayout.Width(50));
            var newSearch = EditorGUILayout.TextField(_searchText);
            if (newSearch != _searchText)
            {
                _searchText = newSearch;
                RefreshFilteredList();
                _selectedIndex = 0;
            }
            EditorGUILayout.EndHorizontal();

            EditorGUILayout.Space();

            // Build options array with none at index 0
            var options = new string[_filteredKeys.Count + 1];
            options[0] = NoneOption;
            for (int i = 0; i < _filteredKeys.Count; i++)
            {
                var key = _filteredKeys[i];
                options[i + 1] = _items.GetValueOrDefault(key, key);
            }

            // Selection grid
            _scrollPosition = EditorGUILayout.BeginScrollView(_scrollPosition);
            var newSelection = GUILayout.SelectionGrid(_selectedIndex, options, ColumnCount);
            EditorGUILayout.EndScrollView();

            if (newSelection != _selectedIndex)
            {
                _selectedIndex = newSelection;
            }

            EditorGUILayout.Space();

            // Apply button
            if (GUILayout.Button("Apply"))
            {
                ApplySelection();
                Close();
            }
        }

        private void ApplySelection()
        {
            if (_targetProperty == null) return;

            var valueProp = _targetProperty.FindPropertyRelative("Value");
            if (valueProp == null) return;

            _targetProperty.serializedObject.Update();

            if (_selectedIndex == 0)
            {
                // None selected
                ApplyNoneValue(valueProp);
            }
            else
            {
                var selectedKey = _filteredKeys[_selectedIndex - 1];
                ApplyValue(valueProp, selectedKey);
            }

            _targetProperty.serializedObject.ApplyModifiedProperties();
        }

        /// <summary>
        /// Apply the selected value to the property.
        /// Override for custom value handling.
        /// </summary>
        protected virtual void ApplyValue(SerializedProperty valueProp, string key)
        {
            switch (valueProp.propertyType)
            {
                case SerializedPropertyType.Integer:
                    if (int.TryParse(key, out var intVal))
                    {
                        valueProp.intValue = intVal;
                    }
                    break;

                case SerializedPropertyType.String:
                    valueProp.stringValue = key;
                    break;

                case SerializedPropertyType.Enum:
                    // Find enum index by name
                    var enumIndex = Array.FindIndex(valueProp.enumNames, 
                        n => string.Equals(n, key, StringComparison.OrdinalIgnoreCase));
                    if (enumIndex >= 0)
                    {
                        valueProp.enumValueIndex = enumIndex;
                    }
                    break;
            }
        }

        /// <summary>
        /// Apply "none" value to the property.
        /// Override for custom none handling.
        /// </summary>
        protected virtual void ApplyNoneValue(SerializedProperty valueProp)
        {
            switch (valueProp.propertyType)
            {
                case SerializedPropertyType.Integer:
                    valueProp.intValue = 0;
                    break;

                case SerializedPropertyType.String:
                    valueProp.stringValue = string.Empty;
                    break;

                case SerializedPropertyType.Enum:
                    valueProp.enumValueIndex = 0;
                    break;
            }
        }
    }
}

#endif

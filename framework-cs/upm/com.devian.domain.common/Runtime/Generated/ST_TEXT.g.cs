// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System v10
// Unity wrapper for StringTable via TableManager
// SSOT: skills/devian-unity/30-unity-components/14-table-manager/SKILL.md
// </auto-generated>

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using UnityEngine;

namespace Devian.Domain.Common
{
    /// <summary>String Table wrapper for TEXT</summary>
    public static class ST_TEXT
    {
        private static readonly Dictionary<string, string> _cache = new();
        private static global::Devian.TableFormat _loadedFormat;
        private static SystemLanguage _loadedLanguage;
        private static bool _isLoaded;

        // ====================================================================
        // Internal loading entry points (called by DomainTableRegistry)
        // ====================================================================

        /// <summary>Internal: Load from NDJSON text. Called by TableManager via registry.</summary>
        internal static void _LoadFromNdjson(string text, SystemLanguage lang)
        {
            _cache.Clear();
            ParseNdjson(text);
            _loadedFormat = global::Devian.TableFormat.Json;
            _loadedLanguage = lang;
            _isLoaded = true;
        }

        /// <summary>Internal: Load from PB64 text. Called by TableManager via registry.</summary>
        internal static void _LoadFromPb64(string pb64Text, SystemLanguage lang)
        {
            _cache.Clear();
            ParsePb64(pb64Text);
            _loadedFormat = global::Devian.TableFormat.Pb64;
            _loadedLanguage = lang;
            _isLoaded = true;
        }

        // ====================================================================
        // Public API
        // ====================================================================

        /// <summary>
        /// Preload TEXT string table via TableManager.
        /// Language is fixed after preload. To change language, call ReloadAsync.
        /// </summary>
        /// <param name="key">Addressables key to load TextAsset</param>
        /// <param name="format">Json or Pb64</param>
        /// <param name="language">Target language</param>
        /// <param name="onError">Error callback</param>
        public static IEnumerator PreloadAsync(
            string key,
            global::Devian.TableFormat format,
            SystemLanguage language,
            Action<string>? onError = null)
        {
            yield return global::Devian.TableManager.Instance.LoadStringsAsync(
                key,
                format,
                language,
                onError
            );
        }

        /// <summary>
        /// Reload TEXT string table with different language.
        /// Unloads current data and preloads new language.
        /// </summary>
        public static IEnumerator ReloadAsync(
            string key,
            global::Devian.TableFormat format,
            SystemLanguage language,
            Action<string>? onError = null)
        {
            global::Devian.TableManager.Instance.UnloadStrings("TEXT");
            Unload();
            yield return PreloadAsync(key, format, language, onError);
        }

        /// <summary>
        /// Get text by id from TEXT string table.
        /// Returns id if not found (fallback).
        /// </summary>
        public static string Get(string id)
        {
            return _cache.TryGetValue(id, out var text) ? text : id;
        }

        /// <summary>
        /// Unload TEXT string table and clear cache.
        /// </summary>
        public static void Unload()
        {
            _cache.Clear();
            _isLoaded = false;
        }

        /// <summary>Check if string table is loaded.</summary>
        public static bool IsLoaded => _isLoaded;

        /// <summary>Get the language used for loading.</summary>
        public static SystemLanguage LoadedLanguage => _loadedLanguage;

        /// <summary>Get the format used for loading.</summary>
        public static global::Devian.TableFormat LoadedFormat => _loadedFormat;

        // ====================================================================
        // Parsing
        // ====================================================================

        private static void ParseNdjson(string content)
        {
            var lines = content.Split('\n', StringSplitOptions.RemoveEmptyEntries);
            foreach (var line in lines)
            {
                var trimmed = line.Trim();
                if (string.IsNullOrEmpty(trimmed)) continue;
                var entry = JsonUtility.FromJson<StringEntry>(trimmed);
                if (entry != null && !string.IsNullOrEmpty(entry.id))
                {
                    _cache[entry.id] = entry.text ?? string.Empty;
                }
            }
        }

        // base64 후보 판별: A-Za-z0-9+/= 만 허용, 길이 4 미만이면 false
        private static bool IsLikelyBase64(string s)
        {
            if (string.IsNullOrEmpty(s) || s.Length < 4) return false;
            for (int i = 0; i < s.Length; i++)
            {
                char c = s[i];
                bool ok = (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') ||
                          (c >= '0' && c <= '9') || c == '+' || c == '/' || c == '=';
                if (!ok) return false;
            }
            return true;
        }

        private static void ParsePb64(string content)
        {
            if (string.IsNullOrEmpty(content)) return;

            content = content.Replace("\r", "");
            // 방어: 'chunk1|chunk2|...' 형태 지원 + YAML의 'm_Script: |' 라인도 분해되어 필터링됨
            content = content.Replace('|', '\n');

            var lines = content.Split('\n', StringSplitOptions.RemoveEmptyEntries);
            foreach (var line in lines)
            {
                var trimmed = line.Trim();
                if (string.IsNullOrEmpty(trimmed)) continue;

                // YAML 라인/잡문은 여기서 걸러져서 로그 스팸 방지
                if (!IsLikelyBase64(trimmed)) continue;

                try
                {
                    var bytes = Convert.FromBase64String(trimmed);
                    ParseStringChunk(bytes);
                }
                catch (Exception ex)
                {
                    var preview = trimmed.Length <= 64 ? trimmed : (trimmed.Substring(0, 64) + "...");
                    global::Devian.Log.Error($"[ST_TEXT] ParsePb64 failed. len={trimmed.Length} preview='{preview}' ex={ex}");
                }
            }
        }

        private static void ParseStringChunk(byte[] bytes)
        {
            int offset = 0;
            while (offset < bytes.Length)
            {
                var tag = ReadVarint(bytes, ref offset);
                var fieldNumber = (int)(tag >> 3);
                var wireType = (int)(tag & 0x7);
                if (fieldNumber == 1 && wireType == 2)
                {
                    var length = (int)ReadVarint(bytes, ref offset);
                    var entryBytes = new byte[length];
                    Array.Copy(bytes, offset, entryBytes, 0, length);
                    offset += length;
                    var (id, text) = ParseStringEntry(entryBytes);
                    if (!string.IsNullOrEmpty(id)) _cache[id] = text;
                }
                else { SkipField(bytes, ref offset, wireType); }
            }
        }

        private static (string id, string text) ParseStringEntry(byte[] bytes)
        {
            string id = string.Empty, text = string.Empty;
            int offset = 0;
            while (offset < bytes.Length)
            {
                var tag = ReadVarint(bytes, ref offset);
                var fieldNumber = (int)(tag >> 3);
                var wireType = (int)(tag & 0x7);
                if (wireType == 2)
                {
                    var length = (int)ReadVarint(bytes, ref offset);
                    var str = Encoding.UTF8.GetString(bytes, offset, length);
                    offset += length;
                    if (fieldNumber == 1) id = str;
                    else if (fieldNumber == 2) text = str;
                }
                else { SkipField(bytes, ref offset, wireType); }
            }
            return (id, text);
        }

        private static ulong ReadVarint(byte[] bytes, ref int offset)
        {
            ulong result = 0; int shift = 0;
            while (offset < bytes.Length)
            {
                var b = bytes[offset++];
                result |= (ulong)(b & 0x7f) << shift;
                if ((b & 0x80) == 0) break;
                shift += 7;
            }
            return result;
        }

        private static void SkipField(byte[] bytes, ref int offset, int wireType)
        {
            switch (wireType)
            {
                case 0: ReadVarint(bytes, ref offset); break;
                case 1: offset += 8; break;
                case 2: offset += (int)ReadVarint(bytes, ref offset); break;
                case 5: offset += 4; break;
            }
        }

        [Serializable]
        private class StringEntry
        {
            public string id = string.Empty;
            public string text = string.Empty;
        }
    }
}
#!/usr/bin/env node
// <auto-generated>
// Devian Build System v10 - Node.js Build Runner
// SSOT: skills/devian/03-ssot/SKILL.md
// </auto-generated>

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Generators
import { generateCSharpProtocol } from './generators/protocol-cs.js';
import { generateTypeScriptProtocol, generateServerRuntime, generateClientRuntime } from './generators/protocol-ts.js';
import { generateCSharpContract, generateCSharpContractBody } from './generators/contract-cs.js';
import { generateTypeScriptContract, generateTypeScriptContractBody } from './generators/contract-ts.js';
import { generateCSharpTable, generateCSharpTableEntityBody, generateCSharpTableContainerBody, generateTypeScriptTable, generateTypeScriptTableBody, generateTypeScriptTableContainerBody, generateTableData, parseXlsx } from './generators/table.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ============================================================================
// Build Runner
// ============================================================================

class DevianToolBuilder {
    constructor(buildJsonPath) {
        this.buildJsonPath = path.resolve(buildJsonPath);
        // input/build.json -> input (buildJsonDir) -> devian (rootDir)
        // All relative paths in build.json are relative to buildJsonDir
        this.buildJsonDir = path.dirname(this.buildJsonPath);
        this.rootDir = path.dirname(this.buildJsonDir);
        this.config = null;
        this.tempDir = null;
    }

    // Resolve path relative to buildJsonDir
    resolvePath(relativePath) {
        if (path.isAbsolute(relativePath)) {
            return relativePath;
        }
        return path.resolve(this.buildJsonDir, relativePath);
    }

    async run() {
        console.log('='.repeat(60));
        console.log('Devian Build System v10');
        console.log('='.repeat(60));
        console.log(`Build config: ${this.buildJsonPath}`);
        console.log(`Root dir: ${this.rootDir}`);
        console.log();

        // 1. Load config
        this.config = JSON.parse(fs.readFileSync(this.buildJsonPath, 'utf-8'));
        // tempDir is relative to build.json directory
        this.tempDir = path.join(this.buildJsonDir, this.config.tempDir || 'temp');

        // 2. Clean temp dir
        console.log('[Phase 0] Cleaning temp directory...');
        if (fs.existsSync(this.tempDir)) {
            fs.rmSync(this.tempDir, { recursive: true });
        }
        fs.mkdirSync(this.tempDir, { recursive: true });

        // 3. Generate to staging
        console.log('[Phase 1] Generating to staging...');
        
        // Process domains (contracts + tables)
        if (this.config.domains) {
            for (const [domainName, domainConfig] of Object.entries(this.config.domains)) {
                await this.processDomain(domainName, domainConfig);
            }
        }

        // Process protocols
        if (this.config.protocols && Array.isArray(this.config.protocols)) {
            for (const protocolGroup of this.config.protocols) {
                await this.processProtocolGroup(protocolGroup);
            }
        }

        // 4. Clean & Copy to targets
        console.log('[Phase 2] Clean & Copy to targets...');
        
        if (this.config.domains) {
            for (const [domainName, domainConfig] of Object.entries(this.config.domains)) {
                await this.copyDomainToTargets(domainName, domainConfig);
            }
        }

        if (this.config.protocols && Array.isArray(this.config.protocols)) {
            for (const protocolGroup of this.config.protocols) {
                await this.copyProtocolGroupToTargets(protocolGroup);
            }
        }

        console.log();
        console.log('='.repeat(60));
        console.log('Build completed successfully!');
        console.log('='.repeat(60));
    }

    // ========================================================================
    // Domain Processing (Contracts + Tables)
    // ========================================================================

    async processDomain(domainName, config) {
        console.log(`  [Domain] ${domainName}`);

        const stagingCs = path.join(this.tempDir, domainName, 'cs', 'generated');
        const stagingTs = path.join(this.tempDir, domainName, 'ts', 'generated');
        const stagingTsRoot = path.join(this.tempDir, domainName, 'ts');
        const stagingData = path.join(this.tempDir, domainName, 'data', 'json');

        fs.mkdirSync(stagingCs, { recursive: true });
        fs.mkdirSync(stagingTs, { recursive: true });
        fs.mkdirSync(stagingData, { recursive: true });

        // Collect all data for unified file generation
        const contractSpecs = [];
        const tables = [];

        // Load contracts
        if (config.contractsDir && config.contractFiles) {
            const contractsDir = this.resolvePath(config.contractsDir);
            const files = this.globFiles(contractsDir, config.contractFiles);

            for (const file of files) {
                console.log(`    [Contract] ${path.basename(file)}`);
                const spec = JSON.parse(fs.readFileSync(file, 'utf-8'));
                contractSpecs.push(spec);
            }
        }

        // Load tables
        if (config.tablesDir && config.tableFiles) {
            const tablesDir = this.resolvePath(config.tablesDir);
            const files = this.globFiles(tablesDir, config.tableFiles);

            for (const file of files) {
                console.log(`    [Table] ${path.basename(file)}`);
                const parsedTables = parseXlsx(file);
                tables.push(...parsedTables);

                // Generate NDJSON data (still individual files)
                for (const table of parsedTables) {
                    const ndjson = generateTableData(table);
                    const dataFileName = `${table.name}.ndjson`;
                    fs.writeFileSync(path.join(stagingData, dataFileName), ndjson);
                }
            }
        }

        // Generate unified C# file: {DomainName}.g.cs
        const csCode = this.generateUnifiedCSharp(domainName, contractSpecs, tables);
        fs.writeFileSync(path.join(stagingCs, `${domainName}.g.cs`), csCode);

        // Generate unified TS file: {DomainName}.g.ts
        const tsCode = this.generateUnifiedTypeScript(domainName, contractSpecs, tables);
        fs.writeFileSync(path.join(stagingTs, `${domainName}.g.ts`), tsCode);

        // Generate index.ts for TypeScript
        const indexTsContent = this.generateDomainIndexTs([domainName]);
        fs.writeFileSync(path.join(stagingTsRoot, 'index.ts'), indexTsContent);

        // Generate UPM scaffold if upmTargetDir is configured
        if (config.upmTargetDir) {
            this.generateDomainUpmScaffold(domainName, stagingCs);
        }
    }

    generateUnifiedCSharp(domainName, contractSpecs, tables) {
        const lines = [];

        // Header
        lines.push('// <auto-generated>');
        lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
        lines.push('// </auto-generated>');
        lines.push('');
        lines.push('#nullable enable');
        lines.push('');
        lines.push('using System;');
        lines.push('using System.Collections.Generic;');
        lines.push('using System.IO;');
        lines.push('using System.Text.Json;');
        lines.push('using Devian.Core;');
        lines.push('');

        // Namespace
        lines.push(`namespace Devian.${domainName}`);
        lines.push('{');

        // Contracts section
        if (contractSpecs.length > 0) {
            lines.push('    // ================================================================');
            lines.push('    // Contracts');
            lines.push('    // ================================================================');
            lines.push('');

            for (const spec of contractSpecs) {
                const body = generateCSharpContractBody(spec, domainName);
                lines.push(body);
                lines.push('');
            }
        }

        // Table Entities section
        if (tables.length > 0) {
            lines.push('    // ================================================================');
            lines.push('    // Table Entities');
            lines.push('    // ================================================================');
            lines.push('');

            for (const table of tables) {
                const body = generateCSharpTableEntityBody(table);
                lines.push(body);
                lines.push('');
            }

            // Table Containers section
            lines.push('    // ================================================================');
            lines.push('    // Table Containers');
            lines.push('    // ================================================================');
            lines.push('');

            for (const table of tables) {
                const body = generateCSharpTableContainerBody(table);
                lines.push(body);
                lines.push('');
            }
        }

        lines.push('}'); // end namespace

        return lines.join('\n');
    }

    generateUnifiedTypeScript(domainName, contractSpecs, tables) {
        const lines = [];

        // Header
        lines.push('// <auto-generated>');
        lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
        lines.push('// </auto-generated>');
        lines.push('');

        // Check if we need IEntity/IEntityKey import
        const hasContractClasses = contractSpecs.some(spec => (spec.classes || []).length > 0);
        const hasTables = tables.length > 0;
        const hasKeyedTables = tables.some(t => t.keyField);

        if (hasContractClasses || hasTables) {
            const imports = ['IEntity'];
            if (hasKeyedTables) {
                imports.push('IEntityKey');
            }
            lines.push(`import { ${imports.join(', ')} } from 'devian-core';`);
            lines.push('');
        }

        // Contracts section
        if (contractSpecs.length > 0) {
            lines.push('// ================================================================');
            lines.push('// Contracts');
            lines.push('// ================================================================');
            lines.push('');

            for (const spec of contractSpecs) {
                const body = generateTypeScriptContractBody(spec);
                lines.push(body);
                lines.push('');
            }
        }

        // Table Interfaces section
        if (tables.length > 0) {
            lines.push('// ================================================================');
            lines.push('// Tables');
            lines.push('// ================================================================');
            lines.push('');

            for (const table of tables) {
                const body = generateTypeScriptTableBody(table);
                lines.push(body);
                lines.push('');
            }

            // Table Containers section
            lines.push('// ================================================================');
            lines.push('// Table Containers');
            lines.push('// ================================================================');
            lines.push('');

            for (const table of tables) {
                const body = generateTypeScriptTableContainerBody(table);
                lines.push(body);
                lines.push('');
            }
        }

        return lines.join('\n').trimEnd();
    }

    async copyDomainToTargets(domainName, config) {
        const stagingCs = path.join(this.tempDir, domainName, 'cs', 'generated');
        const stagingTs = path.join(this.tempDir, domainName, 'ts', 'generated');
        const stagingTsRoot = path.join(this.tempDir, domainName, 'ts');
        const stagingData = path.join(this.tempDir, domainName, 'data', 'json');

        // Copy to CS target: {csTargetDir}/Devian.Module.{Domain}/generated/
        if (config.csTargetDir) {
            const csModuleName = `Devian.Module.${domainName}`;
            const resolvedTargetDir = path.join(this.resolvePath(config.csTargetDir), csModuleName);
            const target = path.join(resolvedTargetDir, 'generated');
            this.cleanAndCopy(stagingCs, target);
            console.log(`    [Copy] ${stagingCs} -> ${target}`);

            // Generate .csproj if not exists
            this.ensureCsProj(resolvedTargetDir, csModuleName);
        }

        // Copy to TS target: {tsTargetDir}/devian-module-{domain}/generated/
        if (config.tsTargetDir) {
            const tsModuleName = `devian-module-${domainName.toLowerCase()}`;
            const resolvedTargetDir = path.join(this.resolvePath(config.tsTargetDir), tsModuleName);
            const target = path.join(resolvedTargetDir, 'generated');
            this.cleanAndCopy(stagingTs, target);
            console.log(`    [Copy] ${stagingTs} -> ${target}`);

            // Copy index.ts
            const stagingIndexTs = path.join(stagingTsRoot, 'index.ts');
            const targetIndexTs = path.join(resolvedTargetDir, 'index.ts');
            if (fs.existsSync(stagingIndexTs)) {
                fs.copyFileSync(stagingIndexTs, targetIndexTs);
            }

            // Generate tsconfig.json if not exists
            this.ensureTsConfig(resolvedTargetDir);

            // Generate package.json if not exists
            this.ensureModulePackageJson(resolvedTargetDir, tsModuleName, domainName);
        }

        // Copy to Data target: {dataTargetDir}/{Domain}/json/
        if (config.dataTargetDir) {
            const target = path.join(this.resolvePath(config.dataTargetDir), domainName, 'json');
            this.cleanAndCopy(stagingData, target);
            console.log(`    [Copy] ${stagingData} -> ${target}`);
        }

        // Copy to UPM target
        if (config.upmTargetDir) {
            const stagingUpm = path.join(this.tempDir, domainName, 'upm');
            const target = this.resolvePath(config.upmTargetDir);
            this.copyUpmToTarget(stagingUpm, target);
            console.log(`    [Copy UPM] ${stagingUpm} -> ${target}`);
        }
    }

    // ========================================================================
    // Protocol Processing
    // ========================================================================

    async processProtocolGroup(groupConfig) {
        const groupName = groupConfig.group;
        console.log(`  [ProtocolGroup] ${groupName}`);

        const protocolDir = this.resolvePath(groupConfig.protocolDir);
        const csProjectName = `Devian.Network.${groupName}`;
        
        // Staging paths
        const stagingCs = path.join(this.tempDir, csProjectName);
        const stagingTs = path.join(this.tempDir, groupName);
        const stagingTsGenerated = path.join(stagingTs, 'generated');

        fs.mkdirSync(stagingCs, { recursive: true });
        fs.mkdirSync(stagingTs, { recursive: true });
        fs.mkdirSync(stagingTsGenerated, { recursive: true });

        // Collect protocol info for index.ts and ServerRuntime
        const protocolNames = [];
        const protocolInfos = []; // {name, direction}

        // Process each protocol file
        for (const protocolFileName of groupConfig.protocolFiles) {
            const protocolFile = path.join(protocolDir, protocolFileName);
            const protocolName = path.basename(protocolFileName, '.json');
            
            if (!fs.existsSync(protocolFile)) {
                console.error(`    Protocol file not found: ${protocolFile}`);
                continue;
            }

            console.log(`    [Protocol] ${protocolName}`);
            protocolNames.push(protocolName);

            // Load protocol spec
            const spec = JSON.parse(fs.readFileSync(protocolFile, 'utf-8'));

            // Collect protocol info for ServerRuntime
            protocolInfos.push({
                name: protocolName,
                direction: spec.direction || 'bidirectional'
            });

            // Load or create opcode registry
            const opcodeRegistry = this.loadOrCreateRegistry(protocolDir, protocolName, 'opcodes');
            const tagRegistry = this.loadOrCreateRegistry(protocolDir, protocolName, 'tags');

            // Assign opcodes and tags
            this.assignOpcodes(spec, opcodeRegistry);
            this.assignTags(spec, tagRegistry);

            // Save registries
            this.saveRegistry(protocolDir, protocolName, 'opcodes', opcodeRegistry);
            this.saveRegistry(protocolDir, protocolName, 'tags', tagRegistry);

            // C# Protocol
            const csCode = generateCSharpProtocol(spec, protocolName, groupName);
            fs.writeFileSync(path.join(stagingCs, `${protocolName}.g.cs`), csCode);

            // TypeScript Protocol
            const tsCode = generateTypeScriptProtocol(spec, protocolName, groupName);
            fs.writeFileSync(path.join(stagingTs, `${protocolName}.g.ts`), tsCode);
        }

        // Generate .csproj for C#
        const csprojContent = this.generateCsproj(groupName);
        fs.writeFileSync(path.join(stagingCs, `${csProjectName}.csproj`), csprojContent);

        // Generate ServerRuntime.g.ts for TypeScript (if both inbound/outbound exist)
        const serverRuntimeCode = generateServerRuntime(groupName, protocolInfos);
        const hasServerRuntime = serverRuntimeCode !== null;
        if (hasServerRuntime) {
            fs.writeFileSync(path.join(stagingTsGenerated, 'ServerRuntime.g.ts'), serverRuntimeCode);
            console.log(`    [ServerRuntime] generated/ServerRuntime.g.ts`);
        }

        // Generate ClientRuntime.g.ts for TypeScript (if both inbound/outbound exist)
        const clientRuntimeCode = generateClientRuntime(groupName, protocolInfos);
        const hasClientRuntime = clientRuntimeCode !== null;
        if (hasClientRuntime) {
            fs.writeFileSync(path.join(stagingTsGenerated, 'ClientRuntime.g.ts'), clientRuntimeCode);
            console.log(`    [ClientRuntime] generated/ClientRuntime.g.ts`);
        }

        // Generate index.ts for TypeScript
        const indexTsContent = this.generateIndexTs(groupName, protocolNames, hasServerRuntime, hasClientRuntime);
        fs.writeFileSync(path.join(stagingTs, 'index.ts'), indexTsContent);

        // Generate UPM scaffold if upmTargetDir is configured
        if (groupConfig.upmTargetDir) {
            this.generateProtocolUpmScaffold(groupName, stagingCs);
        }
    }

    generateCsproj(groupName) {
        return `<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <LangVersion>9.0</LangVersion>
    <Nullable>enable</Nullable>
    <RootNamespace>Devian.Network.${groupName}</RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="System.Text.Json" Version="8.0.5" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\\Devian.Core\\Devian.Core.csproj" />
    <ProjectReference Include="..\\Devian.Network\\Devian.Network.csproj" />
  </ItemGroup>
</Project>
`;
    }

    generateIndexTs(groupName, protocolNames, hasServerRuntime = false, hasClientRuntime = false) {
        const lines = [];

        // Header
        lines.push('// <auto-generated>');
        lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
        lines.push('// </auto-generated>');
        lines.push('');

        // Import modules
        for (const name of protocolNames) {
            lines.push(`import * as ${name}Mod from './${name}.g';`);
        }
        if (hasServerRuntime) {
            lines.push(`import * as ServerRuntimeMod from './generated/ServerRuntime.g';`);
        }
        if (hasClientRuntime) {
            lines.push(`import * as ClientRuntimeMod from './generated/ClientRuntime.g';`);
        }
        lines.push('');

        // Direct exports (for convenience)
        for (const name of protocolNames) {
            lines.push(`export const ${name} = ${name}Mod.${name};`);
        }
        if (hasServerRuntime) {
            lines.push(`export const ServerRuntime = ServerRuntimeMod;`);
        }
        if (hasClientRuntime) {
            lines.push(`export const ClientRuntime = ClientRuntimeMod;`);
        }
        lines.push('');

        // Re-export factory functions for direct import
        if (hasServerRuntime) {
            lines.push(`export { createServerRuntime } from './generated/ServerRuntime.g';`);
        }
        if (hasClientRuntime) {
            lines.push(`export { createClientRuntime } from './generated/ClientRuntime.g';`);
        }
        if (hasServerRuntime || hasClientRuntime) {
            lines.push('');
        }

        // Devian namespace tree (defined only here, not in .g.ts files)
        lines.push('// Devian namespace tree - defined only in index.ts');
        lines.push('export namespace Devian {');
        lines.push('    export namespace Network {');
        lines.push(`        export namespace ${groupName} {`);
        for (const name of protocolNames) {
            lines.push(`            export import ${name} = ${name}Mod.${name};`);
        }
        if (hasServerRuntime) {
            lines.push(`            export import ServerRuntime = ServerRuntimeMod;`);
        }
        if (hasClientRuntime) {
            lines.push(`            export import ClientRuntime = ClientRuntimeMod;`);
        }
        lines.push('        }');
        lines.push('    }');
        lines.push('}');
        lines.push('');

        return lines.join('\n');
    }

    generateDomainIndexTs(fileNames) {
        const header = [
            '// <auto-generated>',
            '// DO NOT EDIT - Generated by Devian Build System v10',
            '// </auto-generated>',
            ''
        ];
        const exports = fileNames.map(name => `export * from './generated/${name}.g';`);
        return header.concat(exports).join('\n') + '\n';
    }

    async copyProtocolGroupToTargets(groupConfig) {
        const groupName = groupConfig.group;
        const csProjectName = `Devian.Network.${groupName}`;
        
        const stagingCs = path.join(this.tempDir, csProjectName);
        const stagingTs = path.join(this.tempDir, groupName);

        // Check if ServerRuntime and ClientRuntime were generated
        const hasServerRuntime = fs.existsSync(path.join(stagingTs, 'generated', 'ServerRuntime.g.ts'));
        const hasClientRuntime = fs.existsSync(path.join(stagingTs, 'generated', 'ClientRuntime.g.ts'));

        // Copy to CS target: {csTargetDir}/Devian.Network.{ProtocolGroup}/
        if (groupConfig.csTargetDir) {
            const target = path.join(this.resolvePath(groupConfig.csTargetDir), csProjectName);
            this.cleanAndCopy(stagingCs, target);
            console.log(`    [Copy] ${stagingCs} -> ${target}`);
        }

        // Copy to TS target: {tsTargetDir}/devian-network-{group}/
        if (groupConfig.tsTargetDir) {
            const tsModuleName = `devian-network-${groupName.toLowerCase()}`;
            const target = path.join(this.resolvePath(groupConfig.tsTargetDir), tsModuleName);
            this.cleanAndCopy(stagingTs, target);
            console.log(`    [Copy] ${stagingTs} -> ${target}`);

            // Generate tsconfig.json if not exists
            this.ensureTsConfig(target);

            // Generate/update package.json with correct dependencies
            this.ensureProtocolPackageJson(target, groupName, hasServerRuntime, hasClientRuntime);
        }

        // Copy to UPM target
        if (groupConfig.upmTargetDir) {
            const stagingUpm = path.join(this.tempDir, `${csProjectName}-upm`);
            const target = this.resolvePath(groupConfig.upmTargetDir);
            this.copyUpmToTarget(stagingUpm, target);
            console.log(`    [Copy UPM] ${stagingUpm} -> ${target}`);
        }
    }

    // ========================================================================
    // Opcode/Tag Registry Management
    // ========================================================================

    loadOrCreateRegistry(protocolsDir, protocolName, type) {
        const generatedDir = path.join(protocolsDir, 'generated');
        const registryPath = path.join(generatedDir, `${protocolName}.${type}.json`);
        if (fs.existsSync(registryPath)) {
            return JSON.parse(fs.readFileSync(registryPath, 'utf-8'));
        }
        return {};
    }

    saveRegistry(protocolsDir, protocolName, type, registry) {
        const generatedDir = path.join(protocolsDir, 'generated');
        fs.mkdirSync(generatedDir, { recursive: true });
        const registryPath = path.join(generatedDir, `${protocolName}.${type}.json`);
        
        // Deterministic save: sort keys (ordinal) + trailing newline
        const sortedKeys = Object.keys(registry).sort((a, b) => a.localeCompare(b));
        const sorted = {};
        for (const key of sortedKeys) {
            sorted[key] = registry[key];
        }
        fs.writeFileSync(registryPath, JSON.stringify(sorted, null, 2) + '\n');
    }

    assignOpcodes(spec, registry) {
        const MIN_OPCODE = 1000;
        const usedOpcodes = new Set();

        // Phase 1: Apply explicit opcodes from spec (highest priority)
        for (const msg of spec.messages) {
            if (msg.opcode !== undefined) {
                if (msg.opcode < 0) {
                    throw new Error(`Negative opcode not allowed: ${msg.name} = ${msg.opcode}`);
                }
                if (usedOpcodes.has(msg.opcode)) {
                    throw new Error(`Duplicate opcode: ${msg.opcode} for ${msg.name}`);
                }
                usedOpcodes.add(msg.opcode);
                registry[msg.name] = msg.opcode;
            }
        }

        // Phase 2: Apply registry values for messages without explicit opcode
        for (const msg of spec.messages) {
            if (msg.opcode === undefined && registry[msg.name] !== undefined) {
                const regOpcode = registry[msg.name];
                if (usedOpcodes.has(regOpcode)) {
                    throw new Error(`Duplicate opcode from registry: ${regOpcode} for ${msg.name}`);
                }
                usedOpcodes.add(regOpcode);
                msg.opcode = regOpcode;
            }
        }

        // Phase 3: Auto-assign remaining messages (sorted by name for determinism)
        const unassigned = spec.messages
            .filter(m => m.opcode === undefined)
            .sort((a, b) => a.name.localeCompare(b.name));

        // Find max opcode to start auto-assign
        let nextOpcode = MIN_OPCODE;
        for (const oc of usedOpcodes) {
            if (oc >= nextOpcode) {
                nextOpcode = oc + 1;
            }
        }

        for (const msg of unassigned) {
            // Find next available opcode
            while (usedOpcodes.has(nextOpcode)) {
                nextOpcode++;
            }
            msg.opcode = nextOpcode;
            registry[msg.name] = nextOpcode;
            usedOpcodes.add(nextOpcode);
            nextOpcode++;
        }
    }

    assignTags(spec, registry) {
        const MIN_TAG = 1;
        const MAX_TAG = 536870911; // 2^29 - 1 (protobuf limit)
        const RESERVED_START = 19000;
        const RESERVED_END = 19999;

        for (const msg of spec.messages) {
            const usedTags = new Set();

            // Phase 1: Apply explicit tags from spec (highest priority)
            for (const field of msg.fields || []) {
                if (field.tag !== undefined) {
                    this.validateTag(field.tag, msg.name, field.name);
                    if (usedTags.has(field.tag)) {
                        throw new Error(`Duplicate tag in ${msg.name}: ${field.tag} for ${field.name}`);
                    }
                    usedTags.add(field.tag);
                    const key = `${msg.name}.${field.name}`;
                    registry[key] = field.tag;
                }
            }

            // Phase 2: Apply registry values for fields without explicit tag
            for (const field of msg.fields || []) {
                const key = `${msg.name}.${field.name}`;
                if (field.tag === undefined && registry[key] !== undefined) {
                    const regTag = registry[key];
                    this.validateTag(regTag, msg.name, field.name);
                    if (usedTags.has(regTag)) {
                        throw new Error(`Duplicate tag from registry in ${msg.name}: ${regTag} for ${field.name}`);
                    }
                    usedTags.add(regTag);
                    field.tag = regTag;
                }
            }

            // Phase 3: Auto-assign remaining fields (in order for determinism)
            let nextTag = MIN_TAG;
            for (const field of msg.fields || []) {
                if (field.tag === undefined) {
                    // Find next available tag, skipping reserved range
                    while (usedTags.has(nextTag) || 
                           (nextTag >= RESERVED_START && nextTag <= RESERVED_END)) {
                        nextTag++;
                        // Skip reserved range
                        if (nextTag >= RESERVED_START && nextTag <= RESERVED_END) {
                            nextTag = RESERVED_END + 1;
                        }
                    }
                    
                    if (nextTag > MAX_TAG) {
                        throw new Error(`Tag overflow in ${msg.name}.${field.name}`);
                    }

                    field.tag = nextTag;
                    const key = `${msg.name}.${field.name}`;
                    registry[key] = nextTag;
                    usedTags.add(nextTag);
                    nextTag++;
                }
            }
        }
    }

    validateTag(tag, msgName, fieldName) {
        const MIN_TAG = 1;
        const MAX_TAG = 536870911;
        const RESERVED_START = 19000;
        const RESERVED_END = 19999;

        if (tag < MIN_TAG || tag > MAX_TAG) {
            throw new Error(`Tag out of range in ${msgName}.${fieldName}: ${tag} (valid: ${MIN_TAG}-${MAX_TAG})`);
        }
        if (tag >= RESERVED_START && tag <= RESERVED_END) {
            throw new Error(`Tag in reserved range in ${msgName}.${fieldName}: ${tag} (reserved: ${RESERVED_START}-${RESERVED_END})`);
        }
    }

    // ========================================================================
    // Utilities
    // ========================================================================

    globFiles(dir, patterns) {
        if (!fs.existsSync(dir)) return [];

        const files = fs.readdirSync(dir);
        const result = [];

        for (const pattern of patterns) {
            const regex = new RegExp('^' + pattern.replace(/\*/g, '.*') + '$');
            for (const file of files) {
                if (regex.test(file)) {
                    result.push(path.join(dir, file));
                }
            }
        }

        return result;
    }

    cleanAndCopy(src, dest) {
        // Clean target
        if (fs.existsSync(dest)) {
            fs.rmSync(dest, { recursive: true });
        }
        fs.mkdirSync(dest, { recursive: true });

        // Copy files recursively
        if (!fs.existsSync(src)) return;

        this.copyDirRecursive(src, dest);
    }

    copyDirRecursive(src, dest) {
        const entries = fs.readdirSync(src, { withFileTypes: true });
        for (const entry of entries) {
            const srcPath = path.join(src, entry.name);
            const destPath = path.join(dest, entry.name);
            if (entry.isDirectory()) {
                fs.mkdirSync(destPath, { recursive: true });
                this.copyDirRecursive(srcPath, destPath);
            } else {
                fs.copyFileSync(srcPath, destPath);
            }
        }
    }

    ensureTsConfig(targetDir) {
        const tsconfigPath = path.join(targetDir, 'tsconfig.json');
        if (!fs.existsSync(tsconfigPath)) {
            const tsconfig = {
                extends: '../../tsconfig.json',
                compilerOptions: {
                    outDir: './dist'
                },
                include: ['./**/*.ts']
            };
            fs.writeFileSync(tsconfigPath, JSON.stringify(tsconfig, null, 2) + '\n');
        }
    }

    ensureCsProj(targetDir, moduleName) {
        const csprojPath = path.join(targetDir, `${moduleName}.csproj`);
        if (!fs.existsSync(csprojPath)) {
            fs.mkdirSync(targetDir, { recursive: true });
            const csproj = `<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <LangVersion>9.0</LangVersion>
    <Nullable>enable</Nullable>
    <RootNamespace>${moduleName}</RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\\Devian.Core\\Devian.Core.csproj" />
  </ItemGroup>
</Project>
`;
            fs.writeFileSync(csprojPath, csproj);
        }
    }

    ensureModulePackageJson(targetDir, moduleName, domainName) {
        const packageJsonPath = path.join(targetDir, 'package.json');
        if (!fs.existsSync(packageJsonPath)) {
            const packageJson = {
                name: `@devian/module-${domainName.toLowerCase()}`,
                version: '10.0.0',
                main: 'index.ts',
                types: 'index.ts',
                dependencies: {
                    '@devian/core': '10.0.0'
                }
            };
            fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');
        }
    }

    ensureProtocolPackageJson(targetDir, groupName, hasServerRuntime = false, hasClientRuntime = false) {
        const packageJsonPath = path.join(targetDir, 'package.json');
        
        // Build dependencies
        const dependencies = {
            '@devian/core': '10.0.0'
        };
        if (hasServerRuntime || hasClientRuntime) {
            dependencies['@devian/network'] = '10.0.0';
        }

        // Build exports
        const exports = {
            '.': './index.ts'
        };
        if (hasServerRuntime) {
            exports['./server-runtime'] = './generated/ServerRuntime.g.ts';
        }
        if (hasClientRuntime) {
            exports['./client-runtime'] = './generated/ClientRuntime.g.ts';
        }

        const packageJson = {
            name: `@devian/network-${groupName.toLowerCase()}`,
            version: '10.0.0',
            type: 'module',
            main: 'index.ts',
            types: 'index.ts',
            exports,
            dependencies
        };
        
        fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');
    }

    // ========================================================================
    // UPM (Unity Package Manager) Support
    // ========================================================================

    generateDomainUpmScaffold(domainName, stagingCs) {
        const stagingUpm = path.join(this.tempDir, domainName, 'upm');
        const stagingRuntime = path.join(stagingUpm, 'Runtime');
        const stagingEditor = path.join(stagingUpm, 'Editor');

        fs.mkdirSync(stagingRuntime, { recursive: true });
        fs.mkdirSync(stagingEditor, { recursive: true });

        // package.json
        const packageJson = JSON.stringify({
            name: `com.devian.${domainName.toLowerCase()}`,
            version: '1.0.0',
            displayName: `Devian ${domainName}`,
            description: 'Generated by Devian Build System',
            unity: '2021.3'
        }, null, 2);
        fs.writeFileSync(path.join(stagingUpm, 'package.json'), packageJson);

        // Runtime.asmdef
        const runtimeAsmdef = JSON.stringify({
            name: `Devian.${domainName}`,
            references: ['Devian.Core'],
            includePlatforms: [],
            excludePlatforms: []
        }, null, 2);
        fs.writeFileSync(path.join(stagingRuntime, `Devian.${domainName}.asmdef`), runtimeAsmdef);

        // Editor.asmdef
        const editorAsmdef = JSON.stringify({
            name: `Devian.${domainName}.Editor`,
            references: [`Devian.${domainName}`],
            includePlatforms: ['Editor'],
            excludePlatforms: []
        }, null, 2);
        fs.writeFileSync(path.join(stagingEditor, `Devian.${domainName}.Editor.asmdef`), editorAsmdef);

        // Copy C# generated files to Runtime
        if (fs.existsSync(stagingCs)) {
            for (const file of fs.readdirSync(stagingCs)) {
                if (file.endsWith('.cs')) {
                    fs.copyFileSync(
                        path.join(stagingCs, file),
                        path.join(stagingRuntime, file)
                    );
                }
            }
        }
    }

    generateProtocolUpmScaffold(groupName, stagingCs) {
        const csProjectName = `Devian.Network.${groupName}`;
        const stagingUpm = path.join(this.tempDir, `${csProjectName}-upm`);
        const stagingRuntime = path.join(stagingUpm, 'Runtime');
        const stagingEditor = path.join(stagingUpm, 'Editor');

        fs.mkdirSync(stagingRuntime, { recursive: true });
        fs.mkdirSync(stagingEditor, { recursive: true });

        // package.json
        const packageJson = JSON.stringify({
            name: `com.devian.protocol.${groupName.toLowerCase()}`,
            version: '1.0.0',
            displayName: `Devian Protocol ${groupName}`,
            description: 'Generated by Devian Build System',
            unity: '2021.3'
        }, null, 2);
        fs.writeFileSync(path.join(stagingUpm, 'package.json'), packageJson);

        // Runtime.asmdef
        const runtimeAsmdef = JSON.stringify({
            name: csProjectName,
            references: ['Devian.Core', 'Devian.Network'],
            includePlatforms: [],
            excludePlatforms: []
        }, null, 2);
        fs.writeFileSync(path.join(stagingRuntime, `${csProjectName}.asmdef`), runtimeAsmdef);

        // Editor.asmdef
        const editorAsmdef = JSON.stringify({
            name: `${csProjectName}.Editor`,
            references: [csProjectName],
            includePlatforms: ['Editor'],
            excludePlatforms: []
        }, null, 2);
        fs.writeFileSync(path.join(stagingEditor, `${csProjectName}.Editor.asmdef`), editorAsmdef);

        // Copy C# generated files to Runtime
        if (fs.existsSync(stagingCs)) {
            for (const file of fs.readdirSync(stagingCs)) {
                if (file.endsWith('.cs')) {
                    fs.copyFileSync(
                        path.join(stagingCs, file),
                        path.join(stagingRuntime, file)
                    );
                }
            }
        }
    }

    copyUpmToTarget(stagingUpm, targetDir) {
        if (!fs.existsSync(stagingUpm)) return;

        fs.mkdirSync(targetDir, { recursive: true });

        // Scaffold files (don't overwrite if exist)
        const packageJsonSrc = path.join(stagingUpm, 'package.json');
        const packageJsonDest = path.join(targetDir, 'package.json');
        if (fs.existsSync(packageJsonSrc) && !fs.existsSync(packageJsonDest)) {
            fs.copyFileSync(packageJsonSrc, packageJsonDest);
        }

        // Editor folder (don't overwrite if exist)
        const stagingEditor = path.join(stagingUpm, 'Editor');
        const targetEditor = path.join(targetDir, 'Editor');
        if (fs.existsSync(stagingEditor)) {
            fs.mkdirSync(targetEditor, { recursive: true });
            for (const file of fs.readdirSync(stagingEditor)) {
                const dest = path.join(targetEditor, file);
                if (!fs.existsSync(dest)) {
                    fs.copyFileSync(path.join(stagingEditor, file), dest);
                }
            }
        }

        // Runtime folder (clean & copy)
        const stagingRuntime = path.join(stagingUpm, 'Runtime');
        const targetRuntime = path.join(targetDir, 'Runtime');
        this.cleanAndCopy(stagingRuntime, targetRuntime);
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

async function main() {
    const args = process.argv.slice(2);

    if (args.length < 1) {
        console.log('Usage: node build.js <build.json>');
        console.log('Example: node build.js ../../../input/build.json');
        process.exit(1);
    }

    const buildJsonPath = args[0];

    try {
        const runner = new DevianToolBuilder(buildJsonPath);
        await runner.run();
    } catch (error) {
        console.error('Build failed:', error.message);
        console.error(error.stack);
        process.exit(1);
    }
}

main();

#!/usr/bin/env node
// <auto-generated>
// Devian Build System v10 - Node.js Build Runner
// SSOT: skills/devian/03-ssot/SKILL.md
// </auto-generated>

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Generators
import { generateCSharpProtocol } from './generators/protocol-cs.js';
import { generateTypeScriptProtocol, generateServerRuntime, generateClientRuntime } from './generators/protocol-ts.js';
import { generateCSharpContract, generateCSharpContractBody } from './generators/contract-cs.js';
import { generateTypeScriptContract, generateTypeScriptContractBody } from './generators/contract-ts.js';
import { generateCSharpTable, generateCSharpTableEntityBody, generateCSharpTableContainerBody, generateTypeScriptTable, generateTypeScriptTableBody, generateTypeScriptTableContainerBody, generateTableData, generateTableAsset, parseXlsx, collectEnumGenSpecs, generateCSharpEnums, generateTypeScriptEnums, getCSharpKeyTypeForTable } from './generators/table.js';
import { parseStringTablesFromXlsx, generateStringNdjson, generateStringPb64, generateStringPb64TextAssetYaml } from './generators/string-table.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ============================================================================
// Build Runner
// ============================================================================

class DevianToolBuilder {
    constructor(buildJsonPath) {
        this.buildJsonPath = path.resolve(buildJsonPath);
        // input/input_common.json -> input (buildJsonDir) -> devian (rootDir)
        // All relative paths in input json are relative to buildJsonDir
        this.buildJsonDir = path.dirname(this.buildJsonPath);
        this.rootDir = path.dirname(this.buildJsonDir);
        this.config = null;
        this.tempDir = null;
        // Store domain tables for cross-domain TableID generation
        this.domainTables = new Map();
    }

    // Resolve path relative to buildJsonDir
    resolvePath(relativePath) {
        if (path.isAbsolute(relativePath)) {
            return relativePath;
        }
        return path.resolve(this.buildJsonDir, relativePath);
    }

    /**
     * Load input json and config json, validate forbidden keys, and merge.
     * SSOT: skills/devian/03-ssot/SKILL.md
     * 
     * Rules:
     * - config.json: csConfig/tsConfig/dataConfig/upmConfig/samplePackages only
     *   Forbidden in config: tempDir, domains, protocols, staticUpmPackages (forbidden)
     * - input.json: version/configPath/tempDir/domains/protocols only
     *   Forbidden in input: csConfig/tsConfig/dataConfig/upmConfig/samplePackages
     * - All relative paths resolved from buildJsonDir (input json directory)
     * - Merge: deepMerge(config, input), tempDir from input wins
     */
    loadAndMergeConfig() {
        // Load input json
        const inputJson = JSON.parse(fs.readFileSync(this.buildJsonPath, 'utf-8'));
        
        // Forbidden keys in input json
        const forbiddenInInput = ['csConfig', 'tsConfig', 'tableConfig', 'upmConfig', 'samplePackages'];
        for (const key of forbiddenInInput) {
            if (inputJson[key] !== undefined) {
                throw new Error(
                    `[FAIL] Forbidden key in input json!\n` +
                    `  Key: ${key}\n` +
                    `  File: ${this.buildJsonPath}\n` +
                    `  These keys must be in config.json, not input json.\n` +
                    `  Add "configPath": "./config.json" to input json and move ${key} to config.json.`
                );
            }
        }
        
        // Check if configPath exists
        if (!inputJson.configPath) {
            throw new Error(
                `[FAIL] Missing configPath in input json!\n` +
                `  File: ${this.buildJsonPath}\n` +
                `  Add "configPath": "./config.json" to input json.\n` +
                `  Then move csConfig/tsConfig/dataConfig/upmConfig/samplePackages to config.json.`
            );
        }
        
        // Load config json (path resolved from buildJsonDir)
        const configPath = this.resolvePath(inputJson.configPath);
        if (!fs.existsSync(configPath)) {
            throw new Error(
                `[FAIL] Config file not found!\n` +
                `  configPath: ${inputJson.configPath}\n` +
                `  Resolved: ${configPath}\n` +
                `  Create config.json with csConfig/tsConfig/dataConfig/upmConfig/samplePackages.`
            );
        }
        
        const configJson = JSON.parse(fs.readFileSync(configPath, 'utf-8'));
        console.log(`  [Config] Loaded: ${configPath}`);
        
        // Forbidden keys in config json
        const forbiddenInConfig = ['tempDir', 'domains', 'protocols'];
        for (const key of forbiddenInConfig) {
            if (configJson[key] !== undefined) {
                throw new Error(
                    `[FAIL] Forbidden key in config json!\n` +
                    `  Key: ${key}\n` +
                    `  File: ${configPath}\n` +
                    `  These keys must be in input json, not config.json.\n` +
                    `  Move ${key} to input json.`
                );
            }
        }

        // FORBIDDEN: staticUpmPackages (replaced by samplePackages)
        // SSOT: skills/devian/03-ssot/SKILL.md
        if (configJson.staticUpmPackages !== undefined) {
            throw new Error(
                `[FAIL] Forbidden key in config json!\n` +
                `  Key: staticUpmPackages\n` +
                `  File: ${configPath}\n` +
                `  staticUpmPackages is forbidden. Use samplePackages instead.\n` +
                `  samplePackages can ONLY contain "com.devian.samples".\n` +
                `  Library packages (com.devian.foundation) and domain packages are NOT allowed.`
            );
        }
        
        // Validate samplePackages - ONLY com.devian.samples is allowed
        // SSOT: skills/devian/03-ssot/SKILL.md - Hard Rule
        if (configJson.samplePackages && Array.isArray(configJson.samplePackages)) {
            const allowedSamplePackages = ['com.devian.samples'];
            for (const pkg of configJson.samplePackages) {
                if (!allowedSamplePackages.includes(pkg)) {
                    throw new Error(
                        `[FAIL] Invalid package in samplePackages!\n` +
                        `  Package: ${pkg}\n` +
                        `  File: ${configPath}\n` +
                        `  samplePackages can ONLY contain: ${allowedSamplePackages.join(', ')}\n` +
                        `  Library packages (com.devian.foundation), domain packages (com.devian.domain.*),\n` +
                        `  and protocol packages (com.devian.protocol.*) are NOT allowed.\n` +
                        `  These packages are managed automatically by the builder.`
                    );
                }
            }
        }

        // Deep merge: config + input (input overwrites for tempDir)
        const merged = this.deepMerge(configJson, inputJson);

        // Ensure tempDir comes from input (explicit override rule)
        if (inputJson.tempDir) {
            merged.tempDir = inputJson.tempDir;
        }

        console.log(`  [Config] Merged successfully (tempDir: ${merged.tempDir})`);
        return merged;
    }
    
    /**
     * Deep merge two objects. Source overwrites target for same keys.
     */
    deepMerge(target, source) {
        const result = { ...target };
        for (const key of Object.keys(source)) {
            if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                result[key] = this.deepMerge(result[key] || {}, source[key]);
            } else {
                result[key] = source[key];
            }
        }
        return result;
    }

    /**
     * Resolve contract directory from domain config.
     * Returns resolved absolute path, or undefined if not configured.
     */
    resolveContractDir(domainName, config) {
        if (config.contractDir) {
            return this.resolvePath(config.contractDir);
        }
        return undefined;
    }

    /**
     * Resolve table directory from domain config.
     * Returns resolved absolute path, or undefined if not configured.
     */
    resolveTableDir(domainName, config) {
        if (config.tableDir) {
            return this.resolvePath(config.tableDir);
        }
        return undefined;
    }

    /**
     * Resolve string directory for a domain.
     * SSOT: skills/devian/33-string-table/SKILL.md
     * Returns resolved absolute path, or undefined if not configured.
     */
    resolveStringDir(domainName, config) {
        if (config.stringDir) {
            return this.resolvePath(config.stringDir);
        }
        return undefined;
    }

    async run() {
        console.log('='.repeat(60));
        console.log('Devian Build System v10');
        console.log('='.repeat(60));
        console.log(`Build config: ${this.buildJsonPath}`);
        console.log(`Root dir: ${this.rootDir}`);
        console.log();

        // 1. Load input json and config json, then merge
        console.log('[Phase 0] Loading configuration...');
        this.config = this.loadAndMergeConfig();
        
        // tempDir is relative to input json directory (from input json, not config)
        this.tempDir = path.join(this.buildJsonDir, this.config.tempDir || 'temp');

        // 1.1. Validate upmConfig (Hard Rule)
        console.log('[Guard] Validating upmConfig...');
        this.validateUpmConfig();

        // 1.2. Validate forbidden fields (Hard Fail)
        console.log('[Guard] Checking forbidden fields...');
        this.checkForbiddenFields();

        // 1.5. Forbidden namespace guard (재발 방지)
        console.log('[Guard] Checking forbidden namespaces...');
        this.checkForbiddenNamespaces();

        // 1.6. Unity.Common Editor/Generated guard (재발 방지)
        console.log('[Guard] Checking unity.common Editor/Generated...');
        this.checkFoundationEditorGenerated();

        // 1.7. Singleton early init guard (SimpleSingleton ctor/static-init 금지 패턴 탐지)
        console.log('[Guard] Checking singleton early init...');
        this.checkSingletonEarlyInit();

        // 2. Clean temp dir
        console.log('[Phase 0] Cleaning temp directory...');
        if (fs.existsSync(this.tempDir)) {
            fs.rmSync(this.tempDir, { recursive: true });
        }
        fs.mkdirSync(this.tempDir, { recursive: true });

        // 3. Generate to staging
        console.log('[Phase 1] Generating to staging...');
        
        // Process domains (contracts + tables)
        if (this.config.domains) {
            for (const [domainName, domainConfig] of Object.entries(this.config.domains)) {
                await this.processDomain(domainName, domainConfig);
            }
        }

        // Process protocols
        if (this.config.protocols && Array.isArray(this.config.protocols)) {
            for (const protocolGroup of this.config.protocols) {
                await this.processProtocolGroup(protocolGroup);
            }
        }

        // Process sample packages (e.g., com.devian.samples)
        // samplePackages is string[] of package names, ONLY com.devian.samples allowed
        if (this.config.samplePackages && Array.isArray(this.config.samplePackages)) {
            for (const upmName of this.config.samplePackages) {
                await this.processSamplePackage(upmName);
            }
        }

        // 4. Clean & Copy to targets (module, upm)
        console.log('[Phase 2] Materialize to targets (module, upm)...');
        
        if (this.config.domains) {
            for (const [domainName, domainConfig] of Object.entries(this.config.domains)) {
                await this.copyDomainToTargets(domainName, domainConfig);
            }
        }

        if (this.config.protocols && Array.isArray(this.config.protocols)) {
            for (const protocolGroup of this.config.protocols) {
                await this.copyProtocolGroupToTargets(protocolGroup);
            }
        }

        // Sample packages: copy to packageDir (clean + copy entire package)
        // SSOT: upm is the single source, samplePackages ONLY for com.devian.samples
        if (this.config.samplePackages && Array.isArray(this.config.samplePackages)) {
            console.log('  [Info] Sample packages: upm/<pkg> → packageDir/<pkg> (clean copy)');
            for (const upmName of this.config.samplePackages) {
                // Validate sample package exists in upm
                const pkgPath = path.join(this.upmSourceDir, upmName);
                if (!fs.existsSync(pkgPath)) {
                    throw new Error(
                        `[FAIL] Sample package not found in upm!\n` +
                        `  Package: ${upmName}\n` +
                        `  Expected at: ${pkgPath}\n` +
                        `  Sample packages must exist in upmConfig.sourceDir.`
                    );
                }

                // Copy entire sample package to packageDir (clean copy, NOT generated content)
                await this.copySamplePackageToTarget(upmName);
            }
        }

        // 5. Validate (C# modules, TS modules, and UPM packages)
        console.log('[Phase 3] Validate modules and packages...');
        await this.validateCsModules();
        await this.validateTsModules();
        await this.validateUpmPackages();

        // 6. Sync UPM packages (upm → packageDir)
        console.log('[Phase 4] Sync UPM packages (upm → packageDir)...');
        await this.syncUpmToPackageDir();

        // Guards: Run after sync (packageDir is now populated)
        await this.verifyUnityCommonTableIdFiles();
        console.log('[Guard] Post-sync: Checking unity.common Editor/Generated...');
        this.checkFoundationEditorGenerated();

        // 7. Sync UPM samples metadata
        console.log('[Phase 5] Sync UPM samples metadata...');
        await this.syncAllUpmSamples();

        console.log();
        console.log('='.repeat(60));
        console.log('Build completed successfully!');
        console.log('='.repeat(60));
    }

    // ========================================================================
    // Domain Processing (Contracts + Tables)
    // ========================================================================

    async processDomain(domainName, config) {
        console.log(`  [Domain] ${domainName}`);

        const stagingCs = path.join(this.tempDir, domainName, 'cs', 'Generated');
        const stagingTs = path.join(this.tempDir, domainName, 'ts', 'Generated');
        const stagingTsRoot = path.join(this.tempDir, domainName, 'ts');
        const stagingNdjson = path.join(this.tempDir, domainName, 'data', 'ndjson');
        const stagingPb64 = path.join(this.tempDir, domainName, 'data', 'pb64');
        // String table staging directories (string/{format}/{Language}/)
        const stagingStringRoot = path.join(this.tempDir, domainName, 'data', 'string');

        fs.mkdirSync(stagingCs, { recursive: true });
        fs.mkdirSync(stagingTs, { recursive: true });
        fs.mkdirSync(stagingNdjson, { recursive: true });
        fs.mkdirSync(stagingPb64, { recursive: true });
        fs.mkdirSync(stagingStringRoot, { recursive: true });

        // Collect all data for unified file generation
        const contractSpecs = [];
        const tables = [];
        const stringTableNames = []; // For UPM wrapper generation

        // Resolve contract directory
        const contractDir = this.resolveContractDir(domainName, config);
        
        // Load contracts (SKIP if not configured or not found)
        if (contractDir && config.contractFiles) {
            if (!fs.existsSync(contractDir)) {
                console.log(`    [Skip] contracts: directory not found: ${contractDir}`);
            } else {
                const files = this.globFiles(contractDir, config.contractFiles);
                if (files.length === 0) {
                    console.log(`    [Skip] contracts: no files matched [${config.contractFiles.join(', ')}] in ${contractDir}`);
                } else {
                    for (const file of files) {
                        console.log(`    [Contract] ${path.basename(file)}`);
                        const spec = JSON.parse(fs.readFileSync(file, 'utf-8'));
                        contractSpecs.push(spec);
                    }
                }
            }
        } else if (!contractDir && !config.contractFiles) {
            console.log(`    [Skip] contracts: not configured`);
        } else {
            console.log(`    [Skip] contracts: incomplete config (need both contractDir and contractFiles)`);
        }

        // Resolve table directory
        const tableDir = this.resolveTableDir(domainName, config);
        
        // Load tables (SKIP if not configured or not found)
        if (tableDir && config.tableFiles) {
            if (!fs.existsSync(tableDir)) {
                console.log(`    [Skip] tables: directory not found: ${tableDir}`);
            } else {
                const files = this.globFiles(tableDir, config.tableFiles);
                if (files.length === 0) {
                    console.log(`    [Skip] tables: no files matched [${config.tableFiles.join(', ')}] in ${tableDir}`);
                } else {
                    for (const file of files) {
                        console.log(`    [Table] ${path.basename(file)}`);
                        const parsedTables = parseXlsx(file);
                        tables.push(...parsedTables);

                        // Generate NDJSON and .asset data (individual files per table)
                        // SSOT: Only export if PK is defined and valid rows exist
                        for (const table of parsedTables) {
                            // NDJSON file (extension .json for tooling, content is NDJSON)
                            const ndjsonResult = generateTableData(table);
                            if (ndjsonResult.rowCount > 0 && ndjsonResult.data) {
                                const ndjsonFileName = `${table.name}.json`;
                                fs.writeFileSync(path.join(stagingNdjson, ndjsonFileName), ndjsonResult.data);
                            }

                            // Unity TextAsset .asset file (pk 옵션 있는 테이블만)
                            // SSOT: skills/devian/32-json-row-io/SKILL.md - pb64 export 규칙
                            const assetResult = generateTableAsset(table);
                            if (assetResult) {
                                fs.writeFileSync(path.join(stagingPb64, `${assetResult.tableName}.asset`), assetResult.yaml);
                            }
                        }
                    }
                }
            }
        } else if (!tableDir && !config.tableFiles) {
            console.log(`    [Skip] tables: not configured`);
        } else {
            console.log(`    [Skip] tables: incomplete config (need both tableDir and tableFiles)`);
        }

        // ================================================================
        // String Tables Processing (stringDir/stringFiles 전용)
        // SSOT: skills/devian/33-string-table/SKILL.md
        // Hard Rule: tableDir/tableFiles는 절대 사용하지 않음
        // ================================================================
        const stringDir = this.resolveStringDir(domainName, config);
        
        // Incomplete config check (FAIL, not skip)
        if ((stringDir && !config.stringFiles) || (!stringDir && config.stringFiles)) {
            throw new Error(
                `[FAIL] Incomplete string table config in domain '${domainName}'.\n` +
                `  Both stringDir and stringFiles must be configured together.\n` +
                `  stringDir: ${config.stringDir || '(not set)'}\n` +
                `  stringFiles: ${config.stringFiles ? JSON.stringify(config.stringFiles) : '(not set)'}`
            );
        }
        
        if (stringDir && config.stringFiles) {
            // ============================================================
            // Overlap detection: table inputs vs string inputs
            // Hard Rule: 같은 파일이 양쪽에서 처리되면 FAIL
            // ============================================================
            if (tableDir && config.tableFiles && fs.existsSync(tableDir) && fs.existsSync(stringDir)) {
                const tableFiles = new Set(this.globFiles(tableDir, config.tableFiles));
                const stringFiles = this.globFiles(stringDir, config.stringFiles);
                const overlap = stringFiles.filter(f => tableFiles.has(f));
                if (overlap.length > 0) {
                    throw new Error(
                        `[FAIL] Input file overlap detected in domain '${domainName}'.\n` +
                        `  The following files are matched by both tableFiles and stringFiles:\n` +
                        `  ${overlap.map(f => path.basename(f)).join(', ')}\n` +
                        `  This is forbidden to prevent silent processing errors.\n` +
                        `  Move string table XLSX files to a separate directory (stringDir).`
                    );
                }
            }
            
            if (!fs.existsSync(stringDir)) {
                console.log(`    [Skip] string tables: directory not found: ${stringDir}`);
            } else {
                const files = this.globFiles(stringDir, config.stringFiles);
                if (files.length === 0) {
                    console.log(`    [Skip] string tables: no files matched [${config.stringFiles.join(', ')}] in ${stringDir}`);
                } else {
                    for (const file of files) {
                        try {
                            const stringTables = parseStringTablesFromXlsx(file);
                            
                            for (const strTable of stringTables) {
                                console.log(`    [StringTable] ${strTable.tableName}`);
                                stringTableNames.push(strTable.tableName); // Collect for UPM wrapper
                                
                                for (const [language, entries] of strTable.byLanguage) {
                                    // Create language directories
                                    const strNdjsonDir = path.join(stagingStringRoot, 'ndjson', language);
                                    const strPb64Dir = path.join(stagingStringRoot, 'pb64', language);
                                    fs.mkdirSync(strNdjsonDir, { recursive: true });
                                    fs.mkdirSync(strPb64Dir, { recursive: true });
                                    
                                    // Generate ndjson
                                    const ndjsonContent = generateStringNdjson(entries);
                                    const ndjsonPath = path.join(strNdjsonDir, `${strTable.tableName}.json`);
                                    fs.writeFileSync(ndjsonPath, ndjsonContent);
                                    
                                    // Generate pb64 as Unity TextAsset .asset
                                    // SSOT: skills/devian-unity/30-unity-components/13-pb64-storage/SKILL.md
                                    const pb64Text = generateStringPb64(entries);
                                    const assetYaml = generateStringPb64TextAssetYaml(strTable.tableName, pb64Text);
                                    const assetPath = path.join(strPb64Dir, `${strTable.tableName}.asset`);
                                    fs.writeFileSync(assetPath, assetYaml);
                                    
                                    console.log(`      [${language}] ${strTable.tableName}.json, ${strTable.tableName}.asset`);
                                }
                            }
                        } catch (err) {
                            // Validation errors are thrown, re-throw them
                            if (err.message.startsWith('[FAIL]')) {
                                throw err;
                            }
                            // Other errors (e.g., no string table sheets) are ignored
                        }
                    }
                }
            }
        } else {
            console.log(`    [Skip] string tables: not configured`);
        }

        // Generate unified C# file: {DomainName}.g.cs
        const csCode = this.generateUnifiedCSharp(domainName, contractSpecs, tables);
        fs.writeFileSync(path.join(stagingCs, `${domainName}.g.cs`), csCode);

        // Generate unified TS file: {DomainName}.g.ts
        const tsCode = this.generateUnifiedTypeScript(domainName, contractSpecs, tables);
        fs.writeFileSync(path.join(stagingTs, `${domainName}.g.ts`), tsCode);

        // Store tables for cross-domain TableID generation (used by static UPM)
        this.domainTables.set(domainName, tables);

        // Generate index.ts for TypeScript
        const indexTsContent = this.generateDomainIndexTs([domainName]);
        fs.writeFileSync(path.join(stagingTsRoot, 'index.ts'), indexTsContent);

        // Generate Domain UPM scaffold always (domains define module existence)
        this.generateDomainUpmScaffold(domainName, stagingCs, tables, stringTableNames);
    }

    generateUnifiedCSharp(domainName, contractSpecs, tables) {
        const lines = [];

        // Collect enum specs from tables
        const enumSpecs = collectEnumGenSpecs(tables);

        // Header
        lines.push('// <auto-generated>');
        lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
        lines.push('// </auto-generated>');
        lines.push('');
        lines.push('#nullable enable');
        lines.push('');
        lines.push('using System;');
        lines.push('using System.Collections.Generic;');
        lines.push('using System.IO;');
        lines.push('using Newtonsoft.Json;');
        lines.push('using Devian;');
        lines.push('');

        // Namespace
        lines.push(`namespace Devian.Domain.${domainName}`);
        lines.push('{');

        // Enums section (gen: tables only)
        if (enumSpecs.length > 0) {
            const enumCode = generateCSharpEnums(enumSpecs);
            lines.push(enumCode);
        }

        // Contracts section
        if (contractSpecs.length > 0) {
            lines.push('    // ================================================================');
            lines.push('    // Contracts');
            lines.push('    // ================================================================');
            lines.push('');

            for (const spec of contractSpecs) {
                const body = generateCSharpContractBody(spec, domainName);
                lines.push(body);
                lines.push('');
            }
        }

        // Table Entities section
        if (tables.length > 0) {
            lines.push('    // ================================================================');
            lines.push('    // Table Entities');
            lines.push('    // ================================================================');
            lines.push('');

            for (const table of tables) {
                const body = generateCSharpTableEntityBody(table);
                lines.push(body);
                lines.push('');
            }

            // Table Containers section
            lines.push('    // ================================================================');
            lines.push('    // Table Containers');
            lines.push('    // ================================================================');
            lines.push('');

            for (const table of tables) {
                const body = generateCSharpTableContainerBody(table, enumSpecs);
                lines.push(body);
                lines.push('');
            }

            // Table ID Types section (PK 있는 테이블만)
            const keyedTables = tables.filter(t => t.keyField);
            if (keyedTables.length > 0) {
                lines.push('    // ================================================================');
                lines.push('    // Table ID Types (for Inspector binding)');
                lines.push('    // ================================================================');
                lines.push('');

                for (const table of keyedTables) {
                    const idCode = this.generateTableIdType(table, enumSpecs);
                    lines.push(idCode);
                    lines.push('');
                }

                // IsValid extension methods
                lines.push('    /// <summary>Table ID validation extensions</summary>');
                lines.push('    public static class TableIdExtensions');
                lines.push('    {');
                for (const table of keyedTables) {
                    const extCode = this.generateTableIdIsValidExtension(table, enumSpecs);
                    lines.push(extCode);
                }
                lines.push('    }');
                lines.push('');
            }
        }

        lines.push('}'); // end namespace

        return lines.join('\n');
    }

    /**
     * Generate {TableName}_ID class for a keyed table
     */
    generateTableIdType(table, enumSpecs) {
        const tableName = table.name;
        const keyField = table.keyField;
        
        // Check if key field has gen: option (enum type)
        const tableEnumSpec = enumSpecs.find(spec => spec.tableName === tableName);
        let keyType;
        if (tableEnumSpec) {
            keyType = tableEnumSpec.enumName;
        } else {
            keyType = getCSharpKeyTypeForTable(table);
        }

        const lines = [];
        lines.push(`    /// <summary>Inspector-bindable ID for ${tableName}</summary>`);
        lines.push('    [Serializable]');
        lines.push(`    public sealed class ${tableName}_ID`);
        lines.push('    {');
        lines.push(`        public ${keyType} Value;`);
        lines.push('');
        lines.push(`        public static implicit operator ${keyType}(${tableName}_ID id) => id.Value;`);
        lines.push(`        public static implicit operator ${tableName}_ID(${keyType} value) => new ${tableName}_ID { Value = value };`);
        lines.push('    }');

        return lines.join('\n');
    }

    /**
     * Generate IsValid extension method for {TableName}_ID
     */
    generateTableIdIsValidExtension(table, enumSpecs) {
        const tableName = table.name;
        const keyField = table.keyField;
        
        // Check if key field has gen: option (enum type)
        const tableEnumSpec = enumSpecs.find(spec => spec.tableName === tableName);
        let keyType;
        if (tableEnumSpec) {
            keyType = tableEnumSpec.enumName;
        } else {
            keyType = getCSharpKeyTypeForTable(table);
        }

        // IsValid logic depends on key type
        let isValidCheck;
        if (keyType === 'string') {
            isValidCheck = 'obj != null && !string.IsNullOrEmpty(obj.Value)';
        } else {
            isValidCheck = `obj != null && !EqualityComparer<${keyType}>.Default.Equals(obj.Value, default)`;
        }

        return `        public static bool IsValid(this ${tableName}_ID? obj) => ${isValidCheck};`;
    }

    generateUnifiedTypeScript(domainName, contractSpecs, tables) {
        const lines = [];

        // Collect enum specs from tables
        const enumSpecs = collectEnumGenSpecs(tables);

        // Header
        lines.push('// <auto-generated>');
        lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
        lines.push('// </auto-generated>');
        lines.push('');

        // Check if we need IEntity/IEntityKey import
        const hasContractClasses = contractSpecs.some(spec => (spec.classes || []).length > 0);
        const hasTables = tables.length > 0;
        const hasKeyedTables = tables.some(t => t.keyField);

        // Check if Variant type is used in any table field
        const needsVariant = tables.some(table =>
            (table.fields || []).some(field => {
                const fieldType = field.type || '';
                const baseType = fieldType.endsWith('[]') ? fieldType.slice(0, -2) : fieldType;
                const typeName = baseType.split('.').pop() || '';
                return typeName.toLowerCase() === 'variant';
            })
        );

        // Safety check: Variant is only available in Common domain
        if (needsVariant && domainName !== 'Common') {
            throw new Error(
                `[Domain:${domainName}] Variant type used but Variant is only defined in Common domain (features/variant.ts). ` +
                `Move the Variant feature to this domain or use a different type.`
            );
        }

        // Import Variant if needed (must come before @devian/core import)
        if (needsVariant) {
            lines.push("import type { Variant } from '../features/variant';");
        }

        if (hasContractClasses || hasTables) {
            const imports = ['IEntity'];
            if (hasKeyedTables) {
                imports.push('IEntityKey');
            }
            lines.push(`import { ${imports.join(', ')} } from '@devian/core';`);
            lines.push('');
        }

        // Enums section (gen: tables only)
        if (enumSpecs.length > 0) {
            const enumCode = generateTypeScriptEnums(enumSpecs);
            lines.push(enumCode);
        }

        // Contracts section
        if (contractSpecs.length > 0) {
            lines.push('// ================================================================');
            lines.push('// Contracts');
            lines.push('// ================================================================');
            lines.push('');

            for (const spec of contractSpecs) {
                const body = generateTypeScriptContractBody(spec);
                lines.push(body);
                lines.push('');
            }
        }

        // Table Interfaces section
        if (tables.length > 0) {
            lines.push('// ================================================================');
            lines.push('// Tables');
            lines.push('// ================================================================');
            lines.push('');

            for (const table of tables) {
                const body = generateTypeScriptTableBody(table);
                lines.push(body);
                lines.push('');
            }

            // Table Containers section
            lines.push('// ================================================================');
            lines.push('// Table Containers');
            lines.push('// ================================================================');
            lines.push('');

            for (const table of tables) {
                const body = generateTypeScriptTableContainerBody(table, enumSpecs);
                lines.push(body);
                lines.push('');
            }
        }

        return lines.join('\n').trimEnd();
    }

    async copyDomainToTargets(domainName, config) {
        const stagingCs = path.join(this.tempDir, domainName, 'cs', 'Generated');
        const stagingTs = path.join(this.tempDir, domainName, 'ts', 'Generated');
        const stagingTsRoot = path.join(this.tempDir, domainName, 'ts');
        const stagingNdjson = path.join(this.tempDir, domainName, 'data', 'ndjson');
        const stagingPb64 = path.join(this.tempDir, domainName, 'data', 'pb64');
        // String Table staging paths (SSOT: skills/devian/33-string-table/SKILL.md)
        const stagingStringNdjson = path.join(this.tempDir, domainName, 'data', 'string', 'ndjson');
        const stagingStringPb64 = path.join(this.tempDir, domainName, 'data', 'string', 'pb64');

        // Copy to CS target: {csConfig.generateDir}/Devian + .Module.{Domain}/Generated/
        // Domain C# output always goes to csConfig.generateDir (domains[*].csTargetDir is forbidden)
        if (this.csGenerateDir) {
            const csModuleName = `Devian.Domain.${domainName}`;
            const resolvedTargetDir = path.join(this.csGenerateDir, csModuleName);
            const target = path.join(resolvedTargetDir, 'Generated');
            
            // Cleanup legacy generated (lowercase) folder if exists
            const legacyTarget = path.join(resolvedTargetDir, 'generated');
            if (fs.existsSync(legacyTarget)) {
                fs.rmSync(legacyTarget, { recursive: true });
                console.log(`    [Cleanup] Removed legacy ${legacyTarget}`);
            }
            
            this.cleanAndCopy(stagingCs, target);
            console.log(`    [Copy] ${stagingCs} -> ${target}`);

            // Generate .csproj if not exists
            this.ensureCsProj(resolvedTargetDir, csModuleName);
        }

        // Copy to TS target: {tsConfig.generateDir}/devian-domain-{domain}/Generated/
        // Domain TS output always goes to tsConfig.generateDir (domains[*].tsTargetDir is forbidden)
        if (this.tsGenerateDir) {
            const tsModuleName = `devian-domain-${domainName.toLowerCase()}`;
            const resolvedTargetDir = path.join(this.tsGenerateDir, tsModuleName);
            const target = path.join(resolvedTargetDir, 'Generated');
            
            // Cleanup legacy generated (lowercase) folder if exists
            const legacyTarget = path.join(resolvedTargetDir, 'generated');
            if (fs.existsSync(legacyTarget)) {
                fs.rmSync(legacyTarget, { recursive: true });
                console.log(`    [Cleanup] Removed legacy ${legacyTarget}`);
            }
            
            this.cleanAndCopy(stagingTs, target);
            console.log(`    [Copy] ${stagingTs} -> ${target}`);

            // Update index.ts with marker-based approach (DO NOT overwrite entirely)
            this.updateDomainIndexTs(resolvedTargetDir, domainName);

            // Update features/index.ts with auto-scanned exports
            this.updateFeaturesIndexTs(resolvedTargetDir);

            // Generate tsconfig.json if not exists
            this.ensureTsConfig(resolvedTargetDir);

            // Generate package.json if not exists
            this.ensureModulePackageJson(resolvedTargetDir, tsModuleName, domainName);
        }

        // Copy to data export targets:
        // - Tables  : each {tableDir}/ndjson|pb64/
        // - Strings : each {stringDir}/ndjson|pb64/{Language}/ (language subdirs live under staging)
        // - Sounds  : ensure dirs exist only (do NOT clean user sound bundles)
        //
        // SSOT: skills/devian/03-ssot/SKILL.md
        // NOTE:
        // - Domain folder is NOT created. Files are merged directly.
        // - Filename collision will FAIL the build (no silent overwrite).
        // - Clean is performed ONCE per target subdir (ndjson/pb64 roots), not per domain.
        if (this.tableDirs && this.tableDirs.length > 0) {
            for (const tableDir of this.tableDirs) {
                const ndjsonTarget = path.join(tableDir, 'ndjson');
                const pb64Target = path.join(tableDir, 'pb64');

                this.ensureCleanDirOnce(ndjsonTarget, `table:${tableDir}:ndjson`);
                this.ensureCleanDirOnce(pb64Target, `table:${tableDir}:pb64`);

                fs.mkdirSync(ndjsonTarget, { recursive: true });
                fs.mkdirSync(pb64Target, { recursive: true });

                this.mergeCopyDirNoOverwrite(stagingNdjson, ndjsonTarget);
                console.log(`    [MergeCopy] ${stagingNdjson} -> ${ndjsonTarget}`);

                this.mergeCopyDirNoOverwrite(stagingPb64, pb64Target);
                console.log(`    [MergeCopy] ${stagingPb64} -> ${pb64Target}`);
            }
        }

        if (this.stringDirs && this.stringDirs.length > 0) {
            for (const stringDir of this.stringDirs) {
                const ndjsonTarget = path.join(stringDir, 'ndjson');
                const pb64Target = path.join(stringDir, 'pb64');

                this.ensureCleanDirOnce(ndjsonTarget, `string:${stringDir}:ndjson`);
                this.ensureCleanDirOnce(pb64Target, `string:${stringDir}:pb64`);

                fs.mkdirSync(ndjsonTarget, { recursive: true });
                fs.mkdirSync(pb64Target, { recursive: true });

                this.mergeCopyDirNoOverwrite(stagingStringNdjson, ndjsonTarget);
                console.log(`    [MergeCopy] ${stagingStringNdjson} -> ${ndjsonTarget}`);

                this.mergeCopyDirNoOverwrite(stagingStringPb64, pb64Target);
                console.log(`    [MergeCopy] ${stagingStringPb64} -> ${pb64Target}`);
            }
        }

        if (this.soundDirs && this.soundDirs.length > 0) {
            for (const soundDir of this.soundDirs) {
                // IMPORTANT: do not clean soundDir (user-managed bundles).
                // Only ensure directory exists.
                if (!fs.existsSync(soundDir)) {
                    fs.mkdirSync(soundDir, { recursive: true });
                    console.log(`    [EnsureDir] Created soundDir: ${soundDir}`);
                } else {
                    console.log(`    [EnsureDir] soundDir exists: ${soundDir}`);
                }
            }
        }

        // Copy Domain UPM to upm
        // Rule:
        // - If upm/<package>/package.json already exists => manual/hybrid package
        //   => only update Runtime/Generated and Editor/Generated (clean+copy), remove legacy folders
        // - Else => generated-only package
        //   => copy whole staging package (package-level clean+copy)
        const stagingUpm = path.join(this.tempDir, domainName, 'upm');
        if (fs.existsSync(stagingUpm)) {
            const packageName = `com.devian.domain.${domainName.toLowerCase()}`;
            const targetPkgDir = path.join(this.upmSourceDir, packageName);
            const targetPackageJson = path.join(targetPkgDir, 'package.json');

            const srcRuntimeGenerated = path.join(stagingUpm, 'Runtime', 'Generated');
            const dstRuntimeGenerated = path.join(targetPkgDir, 'Runtime', 'Generated');

            const srcEditorGenerated = path.join(stagingUpm, 'Editor', 'Generated');
            const dstEditorGenerated = path.join(targetPkgDir, 'Editor', 'Generated');

            const asmdefName = `Devian.Domain.${domainName}`;

            if (fs.existsSync(targetPackageJson)) {
                // Manual/Hybrid: protect root, update generated only
                // First, clean up legacy Generated.* folders and root .g.cs files
                const targetRuntimeDir = path.join(targetPkgDir, 'Runtime');
                if (fs.existsSync(targetRuntimeDir)) {
                    for (const entry of fs.readdirSync(targetRuntimeDir, { withFileTypes: true })) {
                        // Remove legacy Generated.* directories
                        if (entry.isDirectory() && entry.name.startsWith('Generated.')) {
                            const legacyPath = path.join(targetRuntimeDir, entry.name);
                            fs.rmSync(legacyPath, { recursive: true });
                            console.log(`    [Cleanup] Removed legacy folder: ${legacyPath}`);
                        }
                        // Remove legacy generated (lowercase) folder
                        if (entry.isDirectory() && entry.name === 'generated') {
                            const legacyPath = path.join(targetRuntimeDir, entry.name);
                            fs.rmSync(legacyPath, { recursive: true });
                            console.log(`    [Cleanup] Removed legacy folder: ${legacyPath}`);
                        }
                        // Remove legacy root .g.cs files (e.g., Common.g.cs at Runtime root)
                        if (entry.isFile() && entry.name.endsWith('.g.cs')) {
                            const legacyFile = path.join(targetRuntimeDir, entry.name);
                            fs.unlinkSync(legacyFile);
                            console.log(`    [Cleanup] Removed legacy file: ${legacyFile}`);
                        }
                    }
                }

                // Update Runtime/Generated
                this.cleanAndCopy(srcRuntimeGenerated, dstRuntimeGenerated);
                console.log(`    [Copy UPM Runtime/Generated] ${srcRuntimeGenerated} -> ${dstRuntimeGenerated}`);

                // Update Editor/Generated (remove if not generated this build)
                if (fs.existsSync(srcEditorGenerated)) {
                    this.cleanAndCopy(srcEditorGenerated, dstEditorGenerated);
                    console.log(`    [Copy UPM Editor/Generated] ${srcEditorGenerated} -> ${dstEditorGenerated}`);
                } else {
                    if (fs.existsSync(dstEditorGenerated)) {
                        fs.rmSync(dstEditorGenerated, { recursive: true });
                        console.log(`    [Cleanup] Removed stale Editor/Generated: ${dstEditorGenerated}`);
                    }
                }

                // Patch Editor asmdef to ensure required references for TableID Editor bindings
                const editorAsmdefPath = path.join(targetPkgDir, 'Editor', `${asmdefName}.Editor.asmdef`);
                if (fs.existsSync(editorAsmdefPath)) {
                    const obj = JSON.parse(fs.readFileSync(editorAsmdefPath, 'utf-8'));
                    obj.references = obj.references || [];
                    const requiredRefs = ['Devian.Unity', 'Devian.Unity.Editor'];
                    let patchedCount = 0;
                    for (const ref of requiredRefs) {
                        if (!obj.references.includes(ref)) {
                            obj.references.push(ref);
                            patchedCount++;
                        }
                    }
                    if (patchedCount > 0) {
                        fs.writeFileSync(editorAsmdefPath, JSON.stringify(obj, null, 2) + '\n');
                        console.log(`    [Patched] Editor asmdef: added ${patchedCount} reference(s)`);
                    }
                }
            } else {
                // Generated-only: create package root in upm
                this.copyUpmToTarget(stagingUpm, targetPkgDir);
                console.log(`    [Copy UPM → upm] ${stagingUpm} -> ${targetPkgDir}`);
            }
        }
    }

    // ========================================================================
    // Protocol Processing
    // ========================================================================

    async processProtocolGroup(groupConfig) {
        const groupName = groupConfig.group;
        console.log(`  [ProtocolGroup] ${groupName}`);

        const protocolDir = this.resolvePath(groupConfig.protocolDir);
        const csProjectName = `Devian.Protocol.${groupName}`;
        
        // Staging paths
        const stagingCs = path.join(this.tempDir, csProjectName);
        const stagingTs = path.join(this.tempDir, groupName);
        const stagingTsGenerated = path.join(stagingTs, 'Generated');

        fs.mkdirSync(stagingCs, { recursive: true });
        fs.mkdirSync(stagingTs, { recursive: true });
        fs.mkdirSync(stagingTsGenerated, { recursive: true });

        // Collect protocol info for index.ts and ServerRuntime
        const protocolNames = [];
        const protocolInfos = []; // {name, direction}

        // Process each protocol file
        for (const protocolFileName of groupConfig.protocolFiles) {
            const protocolFile = path.join(protocolDir, protocolFileName);
            const protocolName = path.basename(protocolFileName, '.json');
            
            if (!fs.existsSync(protocolFile)) {
                console.error(`    Protocol file not found: ${protocolFile}`);
                continue;
            }

            console.log(`    [Protocol] ${protocolName}`);
            protocolNames.push(protocolName);

            // Load protocol spec
            const spec = JSON.parse(fs.readFileSync(protocolFile, 'utf-8'));

            // Collect protocol info for ServerRuntime
            protocolInfos.push({
                name: protocolName,
                direction: spec.direction || 'bidirectional'
            });

            // Load or create opcode registry
            const opcodeRegistry = this.loadOrCreateRegistry(protocolDir, protocolName, 'opcodes');
            const tagRegistry = this.loadOrCreateRegistry(protocolDir, protocolName, 'tags');

            // Assign opcodes and tags
            this.assignOpcodes(spec, opcodeRegistry);
            this.assignTags(spec, tagRegistry);

            // Save registries
            this.saveRegistry(protocolDir, protocolName, 'opcodes', opcodeRegistry);
            this.saveRegistry(protocolDir, protocolName, 'tags', tagRegistry);

            // C# Protocol
            const csCode = generateCSharpProtocol(spec, protocolName, groupName);
            fs.writeFileSync(path.join(stagingCs, `${protocolName}.g.cs`), csCode);

            // TypeScript Protocol
            const tsCode = generateTypeScriptProtocol(spec, protocolName, groupName);
            fs.writeFileSync(path.join(stagingTs, `${protocolName}.g.ts`), tsCode);
        }

        // Generate .csproj for C#
        const csprojContent = this.generateCsproj(groupName);
        fs.writeFileSync(path.join(stagingCs, `${csProjectName}.csproj`), csprojContent);

        // Generate ServerRuntime.g.ts for TypeScript (if both inbound/outbound exist)
        const serverRuntimeCode = generateServerRuntime(groupName, protocolInfos);
        const hasServerRuntime = serverRuntimeCode !== null;
        if (hasServerRuntime) {
            fs.writeFileSync(path.join(stagingTsGenerated, 'ServerRuntime.g.ts'), serverRuntimeCode);
            console.log(`    [ServerRuntime] generated/ServerRuntime.g.ts`);
        }

        // Generate ClientRuntime.g.ts for TypeScript (if both inbound/outbound exist)
        const clientRuntimeCode = generateClientRuntime(groupName, protocolInfos);
        const hasClientRuntime = clientRuntimeCode !== null;
        if (hasClientRuntime) {
            fs.writeFileSync(path.join(stagingTsGenerated, 'ClientRuntime.g.ts'), clientRuntimeCode);
            console.log(`    [ClientRuntime] generated/ClientRuntime.g.ts`);
        }

        // Generate index.ts for TypeScript
        const indexTsContent = this.generateIndexTs(groupName, protocolNames, hasServerRuntime, hasClientRuntime);
        fs.writeFileSync(path.join(stagingTs, 'index.ts'), indexTsContent);

        // Always generate UPM scaffold (protocol UPM is always generated)
        this.generateProtocolUpmScaffold(groupName, stagingCs);
    }

    generateCsproj(groupName) {
        return `<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <LangVersion>9.0</LangVersion>
    <Nullable>enable</Nullable>
    <RootNamespace>Devian.Protocol.${groupName}</RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\\Devian\\Devian.csproj" />
    <ProjectReference Include="..\\Devian.Domain.Common\\Devian.Domain.Common.csproj" />
  </ItemGroup>
</Project>
`;
    }

    generateIndexTs(groupName, protocolNames, hasServerRuntime = false, hasClientRuntime = false) {
        const lines = [];

        // Header
        lines.push('// <auto-generated>');
        lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
        lines.push('// </auto-generated>');
        lines.push('');

        // Import modules (needed for Devian namespace tree)
        for (const name of protocolNames) {
            lines.push(`import * as ${name}Mod from './${name}.g';`);
        }
        if (hasServerRuntime) {
            lines.push(`import * as ServerRuntimeMod from './Generated/ServerRuntime.g';`);
        }
        if (hasClientRuntime) {
            lines.push(`import * as ClientRuntimeMod from './Generated/ClientRuntime.g';`);
        }
        lines.push('');

        // Direct exports - namespace/type preserving re-export (NOT const)
        for (const name of protocolNames) {
            lines.push(`export { ${name} } from './${name}.g';`);
        }
        if (hasServerRuntime) {
            lines.push(`export * as ServerRuntime from './Generated/ServerRuntime.g';`);
        }
        if (hasClientRuntime) {
            lines.push(`export * as ClientRuntime from './Generated/ClientRuntime.g';`);
        }
        lines.push('');

        // Re-export factory functions for direct import
        if (hasServerRuntime) {
            lines.push(`export { createServerRuntime } from './Generated/ServerRuntime.g';`);
        }
        if (hasClientRuntime) {
            lines.push(`export { createClientRuntime } from './Generated/ClientRuntime.g';`);
        }
        if (hasServerRuntime || hasClientRuntime) {
            lines.push('');
        }

        // Devian namespace tree (defined only here, not in .g.ts files)
        lines.push('// Devian namespace tree - defined only in index.ts');
        lines.push('export namespace Devian {');
        lines.push('    export namespace Network {');
        lines.push(`        export namespace ${groupName} {`);
        for (const name of protocolNames) {
            lines.push(`            export import ${name} = ${name}Mod.${name};`);
        }
        if (hasServerRuntime) {
            lines.push(`            export import ServerRuntime = ServerRuntimeMod;`);
        }
        if (hasClientRuntime) {
            lines.push(`            export import ClientRuntime = ClientRuntimeMod;`);
        }
        lines.push('        }');
        lines.push('    }');
        lines.push('}');
        lines.push('');

        return lines.join('\n');
    }

    generateDomainIndexTs(fileNames) {
        const header = [
            '// <auto-generated>',
            '// DO NOT EDIT - Generated by Devian Build System v10',
            '// </auto-generated>',
            ''
        ];
        const exports = fileNames.map(name => `export * from './Generated/${name}.g';`);
        return header.concat(exports).join('\n') + '\n';
    }

    async copyProtocolGroupToTargets(groupConfig) {
        const groupName = groupConfig.group;
        const csProjectName = `Devian.Protocol.${groupName}`;
        
        // (Migration) Remove old Devian.Network.<Group> folder if it exists
        const oldCsProjectName = `Devian.Network.${groupName}`;
        if (this.csGenerateDir) {
            const oldTarget = path.join(this.csGenerateDir, oldCsProjectName);
            if (fs.existsSync(oldTarget)) {
                fs.rmSync(oldTarget, { recursive: true });
                console.log(`    [Migration] Removed old folder: ${oldTarget}`);
            }
        }
        
        const stagingCs = path.join(this.tempDir, csProjectName);
        const stagingTs = path.join(this.tempDir, groupName);

        // Check if ServerRuntime and ClientRuntime were generated
        const hasServerRuntime = fs.existsSync(path.join(stagingTs, 'Generated', 'ServerRuntime.g.ts'));
        const hasClientRuntime = fs.existsSync(path.join(stagingTs, 'Generated', 'ClientRuntime.g.ts'));

        // Copy to CS target: {csConfig.generateDir}/Devian.Protocol.{ProtocolGroup}/
        // Protocol C# output always goes to csConfig.generateDir (protocols[*].csTargetDir is forbidden)
        if (this.csGenerateDir) {
            const target = path.join(this.csGenerateDir, csProjectName);
            this.cleanAndCopy(stagingCs, target);
            console.log(`    [Copy] ${stagingCs} -> ${target}`);
        }

        // Copy to TS target: {tsConfig.generateDir}/devian-protocol-{group}/
        // Protocol TS output always goes to tsConfig.generateDir (protocols[*].tsTargetDir is forbidden)
        if (this.tsGenerateDir) {
            const tsModuleName = `devian-protocol-${groupName.toLowerCase()}`;
            const target = path.join(this.tsGenerateDir, tsModuleName);
            this.cleanAndCopy(stagingTs, target);
            console.log(`    [Copy] ${stagingTs} -> ${target}`);

            // Cleanup: Remove non-TS pollution folders if they got copied
            // (This can happen when protocol group name matches domain name)
            const pollutionFolders = ['cs', 'data', 'upm', 'ts'];
            for (const folder of pollutionFolders) {
                const pollutionPath = path.join(target, folder);
                if (fs.existsSync(pollutionPath)) {
                    fs.rmSync(pollutionPath, { recursive: true });
                    console.log(`    [Cleanup] Removed pollution folder: ${pollutionPath}`);
                }
            }

            // Generate tsconfig.json if not exists
            this.ensureTsConfig(target);

            // Generate/update package.json with correct dependencies
            this.ensureProtocolPackageJson(target, groupName, hasServerRuntime, hasClientRuntime);
        }

        // Always copy to UPM source dir (protocol UPM is Generated-only)
        // UPM name is computed from group name (no manual upmName field)
        const computedUpmName = this.computeProtocolUpmName(groupName);
        
        // Validate computed UPM name (checks for conflicts)
        this.validateComputedProtocolUpmName(computedUpmName, groupName);

        const stagingUpm = path.join(this.tempDir, `${csProjectName}-upm`);
        // Copy to upm (single SSOT root)
        const upmTarget = path.join(this.upmSourceDir, computedUpmName);
        this.copyUpmToTarget(stagingUpm, upmTarget);
        console.log(`    [Copy UPM → upm] ${stagingUpm} -> ${upmTarget}`);
    }

    /**
     * Normalize group name to UPM package suffix.
     * Rules (SSOT: skills/devian/03-ssot/SKILL.md):
     * - Lowercase
     * - Spaces become underscores
     * - Underscores are preserved
     * - Only [a-z0-9._-] allowed, others removed
     * - Trim leading/trailing separators
     * @param {string} group - Protocol group name
     * @returns {string} Normalized suffix
     */
    normalizeUpmSuffixFromGroup(group) {
        if (!group || typeof group !== 'string') {
            throw new Error('[FAIL] Protocol group name is empty or invalid.');
        }

        let suffix = group
            .toLowerCase()                     // Lowercase
            .replace(/\s+/g, '_')              // Spaces → underscores
            .replace(/[^a-z0-9._-]/g, '')      // Remove invalid chars
            .replace(/^[._-]+|[._-]+$/g, '');  // Trim leading/trailing separators

        if (!suffix) {
            throw new Error(
                `[FAIL] Protocol group "${group}" normalizes to empty string.\n` +
                `  Normalized suffix must contain at least one valid character [a-z0-9].`
            );
        }

        return suffix;
    }

    /**
     * Compute protocol UPM package name from group.
     * Always returns "com.devian.protocol." + normalize(group)
     * @param {string} group - Protocol group name
     * @returns {string} Full UPM package name
     */
    computeProtocolUpmName(group) {
        const suffix = this.normalizeUpmSuffixFromGroup(group);
        return `com.devian.protocol.${suffix}`;
    }

    /**
     * Validate computed protocol UPM name for conflicts.
     * Checks against static (manual) packages in upm.
     * @param {string} upmName - Computed UPM package name
     * @param {string} groupName - Original group name (for error messages)
     */
    validateComputedProtocolUpmName(upmName, groupName) {
        // Check conflict with sample packages
        const samplePackages = this.config.samplePackages || [];
        if (samplePackages.includes(upmName)) {
            throw new Error(
                `[FAIL] Computed protocol UPM name conflicts with sample package!\n` +
                `  Group: ${groupName}\n` +
                `  Computed UPM name: ${upmName}\n` +
                `  This name is listed in samplePackages.\n` +
                `  Solution: Rename the group or remove from samplePackages if it should be generated.`
            );
        }

        // Track generated protocol UPM names for duplicate detection
        if (!this._generatedProtocolUpmNames) {
            this._generatedProtocolUpmNames = new Set();
        }

        if (this._generatedProtocolUpmNames.has(upmName)) {
            throw new Error(
                `[FAIL] Duplicate computed protocol UPM name in protocols list!\n` +
                `  Group: ${groupName}\n` +
                `  Computed UPM name: ${upmName}\n` +
                `  This name was already computed from another protocol group.\n` +
                `  Solution: Use unique group names that normalize to different UPM names.`
            );
        }

        this._generatedProtocolUpmNames.add(upmName);
        console.log(`    [Guard] Protocol UPM name computed: ${upmName}`);
    }

    // ========================================================================
    // Opcode/Tag Registry Management
    // ========================================================================

    loadOrCreateRegistry(protocolsDir, protocolName, type) {
        const generatedDir = path.join(protocolsDir, 'Generated');
        const registryPath = path.join(generatedDir, `${protocolName}.${type}.json`);
        if (fs.existsSync(registryPath)) {
            return JSON.parse(fs.readFileSync(registryPath, 'utf-8'));
        }
        return {};
    }

    saveRegistry(protocolsDir, protocolName, type, registry) {
        const generatedDir = path.join(protocolsDir, 'Generated');
        fs.mkdirSync(generatedDir, { recursive: true });
        const registryPath = path.join(generatedDir, `${protocolName}.${type}.json`);
        
        // Deterministic save: sort keys (ordinal) + trailing newline
        const sortedKeys = Object.keys(registry).sort((a, b) => a.localeCompare(b));
        const sorted = {};
        for (const key of sortedKeys) {
            sorted[key] = registry[key];
        }
        fs.writeFileSync(registryPath, JSON.stringify(sorted, null, 2) + '\n');
    }

    assignOpcodes(spec, registry) {
        const MIN_OPCODE = 1000;
        const usedOpcodes = new Set();

        // Phase 1: Apply explicit opcodes from spec (highest priority)
        for (const msg of spec.messages) {
            if (msg.opcode !== undefined) {
                if (msg.opcode < 0) {
                    throw new Error(`Negative opcode not allowed: ${msg.name} = ${msg.opcode}`);
                }
                if (usedOpcodes.has(msg.opcode)) {
                    throw new Error(`Duplicate opcode: ${msg.opcode} for ${msg.name}`);
                }
                usedOpcodes.add(msg.opcode);
                registry[msg.name] = msg.opcode;
            }
        }

        // Phase 2: Apply registry values for messages without explicit opcode
        for (const msg of spec.messages) {
            if (msg.opcode === undefined && registry[msg.name] !== undefined) {
                const regOpcode = registry[msg.name];
                if (usedOpcodes.has(regOpcode)) {
                    throw new Error(`Duplicate opcode from registry: ${regOpcode} for ${msg.name}`);
                }
                usedOpcodes.add(regOpcode);
                msg.opcode = regOpcode;
            }
        }

        // Phase 3: Auto-assign remaining messages (sorted by name for determinism)
        const unassigned = spec.messages
            .filter(m => m.opcode === undefined)
            .sort((a, b) => a.name.localeCompare(b.name));

        // Find max opcode to start auto-assign
        let nextOpcode = MIN_OPCODE;
        for (const oc of usedOpcodes) {
            if (oc >= nextOpcode) {
                nextOpcode = oc + 1;
            }
        }

        for (const msg of unassigned) {
            // Find next available opcode
            while (usedOpcodes.has(nextOpcode)) {
                nextOpcode++;
            }
            msg.opcode = nextOpcode;
            registry[msg.name] = nextOpcode;
            usedOpcodes.add(nextOpcode);
            nextOpcode++;
        }
    }

    assignTags(spec, registry) {
        const MIN_TAG = 1;
        const MAX_TAG = 536870911; // 2^29 - 1 (protobuf limit)
        const RESERVED_START = 19000;
        const RESERVED_END = 19999;

        for (const msg of spec.messages) {
            const usedTags = new Set();

            // Phase 1: Apply explicit tags from spec (highest priority)
            for (const field of msg.fields || []) {
                if (field.tag !== undefined) {
                    this.validateTag(field.tag, msg.name, field.name);
                    if (usedTags.has(field.tag)) {
                        throw new Error(`Duplicate tag in ${msg.name}: ${field.tag} for ${field.name}`);
                    }
                    usedTags.add(field.tag);
                    const key = `${msg.name}.${field.name}`;
                    registry[key] = field.tag;
                }
            }

            // Phase 2: Apply registry values for fields without explicit tag
            for (const field of msg.fields || []) {
                const key = `${msg.name}.${field.name}`;
                if (field.tag === undefined && registry[key] !== undefined) {
                    const regTag = registry[key];
                    this.validateTag(regTag, msg.name, field.name);
                    if (usedTags.has(regTag)) {
                        throw new Error(`Duplicate tag from registry in ${msg.name}: ${regTag} for ${field.name}`);
                    }
                    usedTags.add(regTag);
                    field.tag = regTag;
                }
            }

            // Phase 3: Auto-assign remaining fields (in order for determinism)
            let nextTag = MIN_TAG;
            for (const field of msg.fields || []) {
                if (field.tag === undefined) {
                    // Find next available tag, skipping reserved range
                    while (usedTags.has(nextTag) || 
                           (nextTag >= RESERVED_START && nextTag <= RESERVED_END)) {
                        nextTag++;
                        // Skip reserved range
                        if (nextTag >= RESERVED_START && nextTag <= RESERVED_END) {
                            nextTag = RESERVED_END + 1;
                        }
                    }
                    
                    if (nextTag > MAX_TAG) {
                        throw new Error(`Tag overflow in ${msg.name}.${field.name}`);
                    }

                    field.tag = nextTag;
                    const key = `${msg.name}.${field.name}`;
                    registry[key] = nextTag;
                    usedTags.add(nextTag);
                    nextTag++;
                }
            }
        }
    }

    validateTag(tag, msgName, fieldName) {
        const MIN_TAG = 1;
        const MAX_TAG = 536870911;
        const RESERVED_START = 19000;
        const RESERVED_END = 19999;

        if (tag < MIN_TAG || tag > MAX_TAG) {
            throw new Error(`Tag out of range in ${msgName}.${fieldName}: ${tag} (valid: ${MIN_TAG}-${MAX_TAG})`);
        }
        if (tag >= RESERVED_START && tag <= RESERVED_END) {
            throw new Error(`Tag in reserved range in ${msgName}.${fieldName}: ${tag} (reserved: ${RESERVED_START}-${RESERVED_END})`);
        }
    }

    // ========================================================================
    // Utilities
    // ========================================================================

    globFiles(dir, patterns) {
        if (!fs.existsSync(dir)) return [];

        const files = fs.readdirSync(dir);
        const result = [];

        for (const pattern of patterns) {
            const regex = new RegExp('^' + pattern.replace(/\*/g, '.*') + '$');
            for (const file of files) {
                if (regex.test(file)) {
                    result.push(path.join(dir, file));
                }
            }
        }

        return result;
    }

    // ========================================================================
    // Marker-based Index Management Utilities
    // ========================================================================

    /**
     * Read file content or return empty string if not exists
     */
    readTextOrEmpty(filePath) {
        if (fs.existsSync(filePath)) {
            return fs.readFileSync(filePath, 'utf-8');
        }
        return '';
    }

    /**
     * Write text to file with trailing newline
     */
    writeText(filePath, text) {
        const content = text.endsWith('\n') ? text : text + '\n';
        fs.writeFileSync(filePath, content);
    }


    /**
     * Update marker block in text content
     * Returns updated text or throws if markers not found
     */
    updateMarkerBlock(text, startMarker, endMarker, replacementLines) {
        const startIdx = text.indexOf(startMarker);
        const endIdx = text.indexOf(endMarker);

        if (startIdx === -1 || endIdx === -1) {
            throw new Error(`Marker not found: ${startMarker} or ${endMarker}`);
        }

        const before = text.substring(0, startIdx + startMarker.length);
        const after = text.substring(endIdx);

        const replacement = replacementLines.length > 0
            ? '\n' + replacementLines.join('\n') + '\n'
            : '\n';

        return before + replacement + after;
    }

    /**
     * Generate initial index.ts template with markers
     */
    generateDomainIndexTsTemplate(domainName) {
        return `// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System v10
// </auto-generated>

// <devian:domain-exports>
export * from './Generated/${domainName}.g';
// </devian:domain-exports>

// <devian:feature-exports>
export * from './features';
// </devian:feature-exports>
`;
    }

    /**
     * Generate initial features/index.ts template with markers
     */
    generateFeaturesIndexTsTemplate() {
        return `// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System v10
// This file is auto-managed. Do not edit marker blocks.
// </auto-generated>

// <devian:feature-exports>
// </devian:feature-exports>
`;
    }

    /**
     * Scan features directory and return sorted export lines
     */
    scanFeaturesForExports(featuresDir) {
        if (!fs.existsSync(featuresDir)) {
            return [];
        }

        const entries = fs.readdirSync(featuresDir, { withFileTypes: true });
        const exports = [];

        for (const entry of entries) {
            const name = entry.name;

            // Skip exclusions
            if (name === 'index.ts') continue;
            if (name.startsWith('.')) continue;
            if (name === 'Generated') continue;
            if (name.endsWith('.test.ts') || name.endsWith('.spec.ts')) continue;
            if (name.endsWith('.d.ts')) continue;

            if (entry.isDirectory()) {
                // Directory -> export * from './{dir}';
                exports.push({ name, line: `export * from './${name}';` });
            } else if (name.endsWith('.ts')) {
                // .ts file -> export * from './{basename}';
                const basename = name.slice(0, -3); // remove .ts
                exports.push({ name: basename, line: `export * from './${basename}';` });
            }
        }

        // Sort by name (localeCompare for deterministic order)
        exports.sort((a, b) => a.name.localeCompare(b.name));

        return exports.map(e => e.line);
    }

    /**
     * Update or create root index.ts with marker-based approach
     */
    updateDomainIndexTs(targetDir, domainName) {
        const indexPath = path.join(targetDir, 'index.ts');

        // Create template if not exists
        if (!fs.existsSync(indexPath)) {
            const template = this.generateDomainIndexTsTemplate(domainName);
            this.writeText(indexPath, template);
            console.log(`    [Create] ${indexPath}`);
            return;
        }

        // Update marker blocks
        let content = this.readTextOrEmpty(indexPath);

        // Update domain-exports block
        const domainExports = [`export * from './Generated/${domainName}.g';`];
        try {
            content = this.updateMarkerBlock(
                content,
                '// <devian:domain-exports>',
                '// </devian:domain-exports>',
                domainExports
            );
        } catch (e) {
            // Marker not found - regenerate file
            console.log(`    [Warn] Marker not found in ${indexPath}, regenerating...`);
            const template = this.generateDomainIndexTsTemplate(domainName);
            this.writeText(indexPath, template);
            return;
        }

        // Update feature-exports block
        const featureExports = [`export * from './features';`];
        try {
            content = this.updateMarkerBlock(
                content,
                '// <devian:feature-exports>',
                '// </devian:feature-exports>',
                featureExports
            );
        } catch (e) {
            // Continue even if feature marker not found (legacy file)
            console.log(`    [Warn] Feature marker not found in ${indexPath}`);
        }

        this.writeText(indexPath, content);
        console.log(`    [Update] ${indexPath} (marker)`);
    }

    /**
     * Update or create features/index.ts with auto-scanned exports
     */
    updateFeaturesIndexTs(targetDir) {
        const featuresDir = path.join(targetDir, 'features');
        const featuresIndexPath = path.join(featuresDir, 'index.ts');

        // Ensure features directory exists
        if (!fs.existsSync(featuresDir)) {
            fs.mkdirSync(featuresDir, { recursive: true });
        }

        // Create template if not exists
        if (!fs.existsSync(featuresIndexPath)) {
            const template = this.generateFeaturesIndexTsTemplate();
            this.writeText(featuresIndexPath, template);
            console.log(`    [Create] ${featuresIndexPath}`);
        }

        // Scan features and update marker block
        const featureExports = this.scanFeaturesForExports(featuresDir);

        let content = this.readTextOrEmpty(featuresIndexPath);

        try {
            content = this.updateMarkerBlock(
                content,
                '// <devian:feature-exports>',
                '// </devian:feature-exports>',
                featureExports
            );
            this.writeText(featuresIndexPath, content);
            if (featureExports.length > 0) {
                console.log(`    [Update] ${featuresIndexPath} (${featureExports.length} exports)`);
            }
        } catch (e) {
            console.log(`    [Warn] Marker not found in ${featuresIndexPath}, regenerating...`);
            const template = this.generateFeaturesIndexTsTemplate();
            // Insert exports into template
            const updatedTemplate = this.updateMarkerBlock(
                template,
                '// <devian:feature-exports>',
                '// </devian:feature-exports>',
                featureExports
            );
            this.writeText(featuresIndexPath, updatedTemplate);
        }
    }

    cleanAndCopy(src, dest) {
        // Clean target
        if (fs.existsSync(dest)) {
            fs.rmSync(dest, { recursive: true });
        }
        fs.mkdirSync(dest, { recursive: true });

        // Copy files recursively
        if (!fs.existsSync(src)) return;

        this.copyDirRecursive(src, dest);
    }

    copyDirRecursive(src, dest) {
        const entries = fs.readdirSync(src, { withFileTypes: true });
        for (const entry of entries) {
            const srcPath = path.join(src, entry.name);
            const destPath = path.join(dest, entry.name);
            if (entry.isDirectory()) {
                fs.mkdirSync(destPath, { recursive: true });
                this.copyDirRecursive(srcPath, destPath);
            } else {
                fs.copyFileSync(srcPath, destPath);
            }
        }
    }

    /**
     * Clean directory only once per key (for merge copy pattern).
     * Used when multiple domains copy to the same target directory.
     * @param {string} dstDir - Target directory to clean
     * @param {string} key - Unique key to track if already cleaned
     */
    ensureCleanDirOnce(dstDir, key) {
        if (!this._cleanedDirs) {
            this._cleanedDirs = new Set();
        }
        if (this._cleanedDirs.has(key)) {
            return; // Already cleaned
        }
        if (fs.existsSync(dstDir)) {
            fs.rmSync(dstDir, { recursive: true });
        }
        fs.mkdirSync(dstDir, { recursive: true });
        this._cleanedDirs.add(key);
    }

    /**
     * Merge copy directory without overwriting existing files.
     * FAIL if destination file already exists (filename collision).
     * @param {string} srcDir - Source directory
     * @param {string} dstDir - Destination directory
     */
    mergeCopyDirNoOverwrite(srcDir, dstDir) {
        if (!fs.existsSync(srcDir)) return;
        
        const entries = fs.readdirSync(srcDir, { withFileTypes: true });
        for (const entry of entries) {
            const srcPath = path.join(srcDir, entry.name);
            const dstPath = path.join(dstDir, entry.name);
            
            if (entry.isDirectory()) {
                fs.mkdirSync(dstPath, { recursive: true });
                this.mergeCopyDirNoOverwrite(srcPath, dstPath);
            } else {
                // FAIL if file already exists (no silent overwrite)
                if (fs.existsSync(dstPath)) {
                    throw new Error(
                        `[FAIL] File collision detected during merge copy.\n` +
                        `  Source: ${srcPath}\n` +
                        `  Destination: ${dstPath}\n` +
                        `  The destination file already exists. This happens when multiple domains produce files with the same name.\n` +
                        `  Solution: Ensure unique table names across all domains, or use domain-prefixed naming.`
                    );
                }
                fs.copyFileSync(srcPath, dstPath);
            }
        }
    }

    ensureTsConfig(targetDir) {
        const tsconfigPath = path.join(targetDir, 'tsconfig.json');
        if (!fs.existsSync(tsconfigPath)) {
            const tsconfig = {
                extends: '../../tsconfig.json',
                compilerOptions: {
                    outDir: './dist'
                },
                include: ['./**/*.ts']
            };
            fs.writeFileSync(tsconfigPath, JSON.stringify(tsconfig, null, 2) + '\n');
        }
    }

    ensureCsProj(targetDir, moduleName) {
        const csprojPath = path.join(targetDir, `${moduleName}.csproj`);
        if (!fs.existsSync(csprojPath)) {
            fs.mkdirSync(targetDir, { recursive: true });
            const csproj = `<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <LangVersion>9.0</LangVersion>
    <Nullable>enable</Nullable>
    <RootNamespace>${moduleName}</RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Newtonsoft.Json" Version="13.0.3" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\\Devian\\Devian.csproj" />
  </ItemGroup>
</Project>
`;
            fs.writeFileSync(csprojPath, csproj);
        }
    }

    ensureModulePackageJson(targetDir, moduleName, domainName) {
        const packageJsonPath = path.join(targetDir, 'package.json');
        if (!fs.existsSync(packageJsonPath)) {
            const packageJson = {
                name: `@devian/module-${domainName.toLowerCase()}`,
                version: '10.0.0',
                main: 'index.ts',
                types: 'index.ts',
                dependencies: {
                    '@devian/core': '10.0.0'
                }
            };
            fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');
        }
    }

    ensureProtocolPackageJson(targetDir, groupName, hasServerRuntime = false, hasClientRuntime = false) {
        const packageJsonPath = path.join(targetDir, 'package.json');
        
        // Build dependencies - @devian/core includes network functionality
        const dependencies = {
            '@devian/core': '10.0.0',
            '@devian/module-common': '10.0.0'
        };

        // Build exports
        const exports = {
            '.': './index.ts'
        };
        if (hasServerRuntime) {
            exports['./server-runtime'] = './Generated/ServerRuntime.g.ts';
        }
        if (hasClientRuntime) {
            exports['./client-runtime'] = './Generated/ClientRuntime.g.ts';
        }

        const packageJson = {
            name: `@devian/network-${groupName.toLowerCase()}`,
            version: '10.0.0',
            type: 'module',
            main: 'index.ts',
            types: 'index.ts',
            exports,
            dependencies
        };
        
        fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');
    }

    // ========================================================================
    // UPM (Unity Package Manager) Support
    // ========================================================================

    generateDomainUpmScaffold(domainName, stagingCs, tables = [], stringTableNames = []) {
        const asmdefName = `Devian.Domain.${domainName}`;
        const stagingUpm = path.join(this.tempDir, domainName, 'upm');
        const stagingRuntime = path.join(stagingUpm, 'Runtime');
        const stagingGenerated = path.join(stagingRuntime, 'Generated');
        const stagingEditor = path.join(stagingUpm, 'Editor');

        fs.mkdirSync(stagingRuntime, { recursive: true });
        fs.mkdirSync(stagingGenerated, { recursive: true });
        fs.mkdirSync(stagingEditor, { recursive: true });

        // package.json - SSOT: skills/devian-unity/03-package-metadata/SKILL.md
        // All domain packages require com.devian.foundation for TableManager (ST_/TB_ wrappers)
        const isCommon = domainName === 'Common';
        const dependencies = {
            'com.devian.foundation': '0.1.0'
        };
        if (isCommon) {
            dependencies['com.unity.nuget.newtonsoft-json'] = '3.2.1';
        }

        const packageJsonObj = {
            name: `com.devian.domain.${domainName.toLowerCase()}`,
            version: '0.1.0',
            displayName: `Devain Domain ${domainName}`,
            description: isCommon
                ? 'Devian.Domain.Common runtime for Unity (source) - Common features'
                : `Devian.Domain.${domainName} runtime for Unity (source)`,
            unity: '2021.3',
            author: { name: 'Kim, Hyong Joon' },
            dependencies
        };
        fs.writeFileSync(path.join(stagingUpm, 'package.json'), JSON.stringify(packageJsonObj, null, 2));

        // Runtime.asmdef - SSOT: skills/devian-unity/20-packages/com.devian.domain.template/SKILL.md
        // All domain packages require Devian.Core and Devian.Unity for TableManager (ST_/TB_ wrappers)
        const asmdefReferences = isCommon
            ? ['Devian.Core', 'Devian.Unity', 'Newtonsoft.Json']
            : ['Devian.Core', 'Devian.Unity'];
        
        const runtimeAsmdef = {
            name: asmdefName,
            rootNamespace: asmdefName,
            references: asmdefReferences,
            includePlatforms: [],
            excludePlatforms: [],
            allowUnsafeCode: false,
            overrideReferences: false,
            precompiledReferences: [],
            autoReferenced: true,
            defineConstraints: [],
            versionDefines: [],
            noEngineReferences: false
        };
        fs.writeFileSync(path.join(stagingRuntime, `${asmdefName}.asmdef`), JSON.stringify(runtimeAsmdef, null, 2));

        // Editor.asmdef - includes refs for TableID Editor bindings (base classes in Devian + .Unity.Editor assembly)
        // SSOT: skills/devian-unity/20-packages/com.devian.domain.template/SKILL.md
        const editorReferences = [asmdefName, 'Devian.Unity', 'Devian.Unity.Editor'];
        const editorAsmdef = {
            name: `${asmdefName}.Editor`,
            rootNamespace: `${asmdefName}.Editor`,
            references: editorReferences,
            includePlatforms: ['Editor'],
            excludePlatforms: [],
            allowUnsafeCode: false,
            overrideReferences: false,
            precompiledReferences: [],
            autoReferenced: true,
            defineConstraints: [],
            versionDefines: [],
            noEngineReferences: false
        };
        fs.writeFileSync(path.join(stagingEditor, `${asmdefName}.Editor.asmdef`), JSON.stringify(editorAsmdef, null, 2));

        // Copy C# generated files to Runtime/Generated
        if (fs.existsSync(stagingCs)) {
            for (const file of fs.readdirSync(stagingCs)) {
                if (file.endsWith('.cs')) {
                    fs.copyFileSync(
                        path.join(stagingCs, file),
                        path.join(stagingGenerated, file)
                    );
                }
            }
        }

        // Generate TableID Editor bindings into this domain module package
        // SSOT: skills/devian-unity/20-packages/com.devian.domain.template/SKILL.md
        const keyedTables = (tables || []).filter(t => t && t.keyField);
        if (keyedTables.length > 0) {
            const editorGeneratedDir = path.join(stagingUpm, 'Editor', 'Generated');
            fs.mkdirSync(editorGeneratedDir, { recursive: true });

            let generatedCount = 0;
            for (const table of keyedTables) {
                const editorCode = this.generateTableIdEditorCs(domainName, table);
                const editorFileName = `${table.name}_ID.Editor.cs`;
                fs.writeFileSync(path.join(editorGeneratedDir, editorFileName), editorCode);
                generatedCount++;
            }
            console.log(`    [Generated] ${generatedCount} TableID Editor file(s) to ${editorGeneratedDir}`);
        }

        // ================================================================
        // Generate UPM Unity wrappers: TB_{TableName}.Unity.g.cs
        // SSOT: skills/devian-unity/30-unity-components/14-table-manager/SKILL.md
        // ================================================================
        const keyedTables2 = (tables || []).filter(t => t && t.keyField);
        if (keyedTables2.length > 0) {
            for (const table of keyedTables2) {
                const wrapperCode = this.generateTableUnityWrapperCs(domainName, table);
                const wrapperFileName = `TB_${table.name}.Unity.g.cs`;
                fs.writeFileSync(path.join(stagingGenerated, wrapperFileName), wrapperCode);
            }
            console.log(`    [Generated] ${keyedTables2.length} TB_*.Unity.g.cs wrapper(s)`);
            
            // Generate DomainTableRegistry.g.cs for auto TB/ST loader registration
            const registryCode = this.generateDomainTableRegistryCs(domainName, tables, stringTableNames || []);
            fs.writeFileSync(path.join(stagingGenerated, 'DomainTableRegistry.g.cs'), registryCode);
            console.log(`    [Generated] DomainTableRegistry.g.cs (${keyedTables2.length} TB, ${(stringTableNames || []).length} ST loader(s))`);
        }

        // ================================================================
        // Generate UPM Unity wrappers: ST_{TableName}.g.cs
        // SSOT: skills/devian-unity/30-unity-components/14-table-manager/SKILL.md
        // ================================================================
        if (stringTableNames && stringTableNames.length > 0) {
            for (const tableName of stringTableNames) {
                const wrapperCode = this.generateStringTableWrapperCs(domainName, tableName);
                const wrapperFileName = `ST_${tableName}.g.cs`;
                fs.writeFileSync(path.join(stagingGenerated, wrapperFileName), wrapperCode);
            }
            console.log(`    [Generated] ${stringTableNames.length} ST_*.g.cs wrapper(s)`);
        }

        // Common 모듈일 때 Features 폴더 복사 (Logger/Variant/Complex)
        // SSOT: skills/devian-unity/20-packages/com.devian.domain.common/SKILL.md
        if (isCommon) {
            // Use csGenerateDir (unified module root)
            const featuresSource = this.csGenerateDir
                ? path.join(this.csGenerateDir, 'Devian.Domain.Common', 'features')
                : path.join(this.rootDir, 'framework-cs/module/Devian.Domain.Common/features');
            const featuresTarget = path.join(stagingRuntime, 'Features');
            
            if (fs.existsSync(featuresSource)) {
                this.copyDirRecursive(featuresSource, featuresTarget, '.cs');
                console.log(`    [UPM] Copied Features to staging: ${featuresTarget}`);
            }
        }
    }

    /**
     * Generate {TableName}_ID.Editor.cs for Unity Inspector binding
     */
    generateTableIdEditorCs(domainName, table) {
        const tableName = table.name;
        const enumSpecs = collectEnumGenSpecs([table]);
        const tableEnumSpec = enumSpecs.find(spec => spec.tableName === tableName);
        
        let keyType;
        if (tableEnumSpec) {
            keyType = tableEnumSpec.enumName;
        } else {
            keyType = getCSharpKeyTypeForTable(table);
        }

        // Class names with domain prefix to avoid conflicts
        const selectorClassName = `${domainName}_${tableName}_ID_Selector`;
        const drawerClassName = `${domainName}_${tableName}_ID_Drawer`;

        const lines = [];
        lines.push('// <auto-generated>');
        lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
        lines.push('// </auto-generated>');
        lines.push('');
        lines.push('#if UNITY_EDITOR');
        lines.push('');
        lines.push('using UnityEditor;');
        lines.push('using UnityEngine;');
        lines.push(`using Devian.Domain.${domainName};`);
        lines.push('');
        lines.push('namespace Devian');
        lines.push('{');

        // Selector class
        lines.push(`    /// <summary>Selector for ${tableName}_ID</summary>`);
        lines.push(`    public class ${selectorClassName} : EditorID_SelectorBase`);
        lines.push('    {');
        lines.push(`        protected override string GetDisplayTypeName() => "${tableName}";`);
        lines.push('');
        lines.push('        public override void Reload()');
        lines.push('        {');
        lines.push('            ClearItems();');
        lines.push(`            TB_${tableName}.Clear();`);
        lines.push('');
        lines.push(`            var textAssets = AssetManager.FindAssets<TextAsset>("${tableName}");`);
        lines.push('            foreach (var ta in textAssets)');
        lines.push('            {');
        lines.push('                var assetPath = AssetDatabase.GetAssetPath(ta);');
        lines.push('                if (!assetPath.EndsWith(".json", System.StringComparison.OrdinalIgnoreCase))');
        lines.push('                    continue;');
        lines.push('');
        lines.push(`                TB_${tableName}.LoadFromNdjson(ta.text);`);
        lines.push('            }');
        lines.push('');
        lines.push(`            foreach (var row in TB_${tableName}.GetAll())`);
        lines.push('            {');
        lines.push('                AddItem(row.GetKey().ToString());');
        lines.push('            }');
        lines.push('        }');
        lines.push('    }');
        lines.push('');

        // Drawer class
        lines.push(`    /// <summary>PropertyDrawer for ${tableName}_ID</summary>`);
        lines.push(`    [CustomPropertyDrawer(typeof(${tableName}_ID))]`);
        lines.push(`    public class ${drawerClassName} : EditorID_DrawerBase<${selectorClassName}>`);
        lines.push('    {');
        lines.push(`        private ${selectorClassName} _selector;`);
        lines.push('');
        lines.push(`        protected override ${selectorClassName} GetSelector()`);
        lines.push('        {');
        lines.push(`            if (_selector == null)`);
        lines.push('            {');
        lines.push(`                _selector = ScriptableWizard.DisplayWizard<${selectorClassName}>("Select ${tableName}");`);
        lines.push('            }');
        lines.push('            return _selector;');
        lines.push('        }');
        lines.push('    }');

        lines.push('}');
        lines.push('');
        lines.push('#endif');

        return lines.join('\n');
    }

    /**
     * Generate TB_{TableName}.Unity.g.cs - Unity wrapper for table loading
     * SSOT: skills/devian-unity/30-unity-components/14-table-manager/SKILL.md
     */
    generateTableUnityWrapperCs(domainName, table) {
        const tableName = table.name;
        const lines = [];
        
        lines.push('// <auto-generated>');
        lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
        lines.push('// Unity wrapper for TableManager integration');
        lines.push('// SSOT: skills/devian-unity/30-unity-components/14-table-manager/SKILL.md');
        lines.push('// </auto-generated>');
        lines.push('');
        lines.push('#nullable enable');
        lines.push('');
        lines.push('using System;');
        lines.push('using System.Collections;');
        lines.push('using UnityEngine;');
        lines.push('');
        lines.push(`namespace Devian.Domain.${domainName}`);
        lines.push('{');
        lines.push(`    public static partial class TB_${tableName}`);
        lines.push('    {');
        lines.push('        private static global::Devian.TableFormat _loadedFormat;');
        lines.push('        private static bool _isLoaded;');
        lines.push('');
        lines.push('        /// <summary>');
        lines.push(`        /// Preload ${tableName} table via TableManager.`);
        lines.push('        /// TableManager handles: TextAsset load + TB insert + cache.');
        lines.push('        /// </summary>');
        lines.push('        /// <param name="key">Addressables key to load TextAsset</param>');
        lines.push('        /// <param name="format">Json or Pb64</param>');
        lines.push('        /// <param name="onError">Error callback</param>');
        lines.push('        public static IEnumerator PreloadAsync(');
        lines.push('            string key,');
        lines.push('            global::Devian.TableFormat format,');
        lines.push('            Action<string>? onError = null)');
        lines.push('        {');
        lines.push('            yield return global::Devian.TableManager.Instance.LoadTablesAsync(');
        lines.push('                key,');
        lines.push('                format,');
        lines.push('                onError');
        lines.push('            );');
        lines.push('            _loadedFormat = format;');
        lines.push('            _isLoaded = true;');
        lines.push('        }');
        lines.push('');
        lines.push('        /// <summary>');
        lines.push(`        /// Unload ${tableName} table and clear data.`);
        lines.push('        /// </summary>');
        lines.push('        public static void Unload()');
        lines.push('        {');
        lines.push('            Clear();');
        lines.push('            _isLoaded = false;');
        lines.push('        }');
        lines.push('');
        lines.push('        /// <summary>');
        lines.push(`        /// Check if ${tableName} table is loaded.`);
        lines.push('        /// </summary>');
        lines.push('        public static bool IsLoaded => _isLoaded;');
        lines.push('');
        lines.push('        /// <summary>');
        lines.push('        /// Get the format used for loading.');
        lines.push('        /// </summary>');
        lines.push('        public static global::Devian.TableFormat LoadedFormat => _loadedFormat;');
        lines.push('    }');
        lines.push('}');
        
        return lines.join('\n');
    }

    /**
     * Generate DomainTableRegistry.g.cs - Auto-register TB loaders at startup
     * SSOT: skills/devian-unity/30-unity-components/14-table-manager/SKILL.md
     */
    generateDomainTableRegistryCs(domainName, tables, stringTableNames) {
        const keyedTables = (tables || []).filter(t => t && t.keyField);
        const stNames = stringTableNames || [];
        const lines = [];
        
        lines.push('// <auto-generated>');
        lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
        lines.push('// Domain Table Registry - Auto-registers TB/ST loaders at startup');
        lines.push('// SSOT: skills/devian-unity/30-unity-components/14-table-manager/SKILL.md');
        lines.push('// </auto-generated>');
        lines.push('');
        lines.push('#nullable enable');
        lines.push('');
        lines.push('using UnityEngine;');
        lines.push('');
        lines.push(`namespace Devian.Domain.${domainName}`);
        lines.push('{');
        lines.push('    /// <summary>');
        lines.push(`    /// Auto-registers TB/ST loaders for ${domainName} domain at startup.`);
        lines.push('    /// This ensures TableManager can auto-insert data when loading tables.');
        lines.push('    /// </summary>');
        lines.push('    internal static class DomainTableRegistry');
        lines.push('    {');
        lines.push('        [RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]');
        lines.push('        private static void Register()');
        lines.push('        {');
        
        // TB loaders
        for (const table of keyedTables) {
            const tableName = table.name;
            lines.push(`            global::Devian.TableManager.Instance.RegisterTbLoader("${tableName}", (format, text, bin) =>`);
            lines.push('            {');
            lines.push(`                if (format == global::Devian.TableFormat.Json && text != null)`);
            lines.push('                {');
            lines.push(`                    TB_${tableName}.LoadFromNdjson(text);`);
            lines.push(`                    TB_${tableName}._AfterLoad();`);
            lines.push('                }');
            lines.push(`                else if (format == global::Devian.TableFormat.Pb64 && bin != null)`);
            lines.push('                {');
            lines.push(`                    TB_${tableName}.LoadFromPb64Binary(bin);`);
            lines.push(`                    TB_${tableName}._AfterLoad();`);
            lines.push('                }');
            lines.push('            });');
            lines.push('');
        }
        
        // ST loaders
        for (const stName of stNames) {
            lines.push(`            global::Devian.TableManager.Instance.RegisterStLoader("${stName}", (format, lang, text, pb64Text) =>`);
            lines.push('            {');
            lines.push(`                if (format == global::Devian.TableFormat.Json && text != null)`);
            lines.push(`                    ST_${stName}._LoadFromNdjson(text, lang);`);
            lines.push(`                else if (format == global::Devian.TableFormat.Pb64 && pb64Text != null)`);
            lines.push(`                    ST_${stName}._LoadFromPb64(pb64Text, lang);`);
            lines.push('            });');
            lines.push('');
        }
        
        lines.push('        }');
        lines.push('    }');
        lines.push('}');
        
        return lines.join('\n');
    }

    /**
     * Generate ST_{TableName}.g.cs - Unity wrapper for string table loading
     * SSOT: skills/devian-unity/30-unity-components/14-table-manager/SKILL.md
     */
    generateStringTableWrapperCs(domainName, tableName) {
        const lines = [];
        
        lines.push('// <auto-generated>');
        lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
        lines.push('// Unity wrapper for StringTable via TableManager');
        lines.push('// SSOT: skills/devian-unity/30-unity-components/14-table-manager/SKILL.md');
        lines.push('// </auto-generated>');
        lines.push('');
        lines.push('#nullable enable');
        lines.push('');
        lines.push('using System;');
        lines.push('using System.Collections;');
        lines.push('using System.Collections.Generic;');
        lines.push('using System.Text;');
        lines.push('using UnityEngine;');
        lines.push('');
        lines.push(`namespace Devian.Domain.${domainName}`);
        lines.push('{');
        lines.push(`    /// <summary>String Table wrapper for ${tableName}</summary>`);
        lines.push(`    public static class ST_${tableName}`);
        lines.push('    {');
        lines.push('        private static readonly Dictionary<string, string> _cache = new();');
        lines.push('        private static global::Devian.TableFormat _loadedFormat;');
        lines.push('        private static SystemLanguage _loadedLanguage;');
        lines.push('        private static bool _isLoaded;');
        lines.push('');
        lines.push('        // ====================================================================');
        lines.push('        // Internal loading entry points (called by DomainTableRegistry)');
        lines.push('        // ====================================================================');
        lines.push('');
        lines.push('        /// <summary>Internal: Load from NDJSON text. Called by TableManager via registry.</summary>');
        lines.push('        internal static void _LoadFromNdjson(string text, SystemLanguage lang)');
        lines.push('        {');
        lines.push('            _cache.Clear();');
        lines.push('            ParseNdjson(text);');
        lines.push('            _loadedFormat = global::Devian.TableFormat.Json;');
        lines.push('            _loadedLanguage = lang;');
        lines.push('            _isLoaded = true;');
        lines.push('        }');
        lines.push('');
        lines.push('        /// <summary>Internal: Load from PB64 text. Called by TableManager via registry.</summary>');
        lines.push('        internal static void _LoadFromPb64(string pb64Text, SystemLanguage lang)');
        lines.push('        {');
        lines.push('            _cache.Clear();');
        lines.push('            ParsePb64(pb64Text);');
        lines.push('            _loadedFormat = global::Devian.TableFormat.Pb64;');
        lines.push('            _loadedLanguage = lang;');
        lines.push('            _isLoaded = true;');
        lines.push('        }');
        lines.push('');
        lines.push('        // ====================================================================');
        lines.push('        // Public API');
        lines.push('        // ====================================================================');
        lines.push('');
        lines.push('        /// <summary>');
        lines.push(`        /// Preload ${tableName} string table via TableManager.`);
        lines.push('        /// Language is fixed after preload. To change language, call ReloadAsync.');
        lines.push('        /// </summary>');
        lines.push('        /// <param name="key">Addressables key to load TextAsset</param>');
        lines.push('        /// <param name="format">Json or Pb64</param>');
        lines.push('        /// <param name="language">Target language</param>');
        lines.push('        /// <param name="onError">Error callback</param>');
        lines.push('        public static IEnumerator PreloadAsync(');
        lines.push('            string key,');
        lines.push('            global::Devian.TableFormat format,');
        lines.push('            SystemLanguage language,');
        lines.push('            Action<string>? onError = null)');
        lines.push('        {');
        lines.push('            yield return global::Devian.TableManager.Instance.LoadStringsAsync(');
        lines.push('                key,');
        lines.push('                format,');
        lines.push('                language,');
        lines.push('                onError');
        lines.push('            );');
        lines.push('        }');
        lines.push('');
        lines.push('        /// <summary>');
        lines.push(`        /// Reload ${tableName} string table with different language.`);
        lines.push('        /// Unloads current data and preloads new language.');
        lines.push('        /// </summary>');
        lines.push('        public static IEnumerator ReloadAsync(');
        lines.push('            string key,');
        lines.push('            global::Devian.TableFormat format,');
        lines.push('            SystemLanguage language,');
        lines.push('            Action<string>? onError = null)');
        lines.push('        {');
        lines.push(`            global::Devian.TableManager.Instance.UnloadStrings("${tableName}");`);
        lines.push('            Unload();');
        lines.push('            yield return PreloadAsync(key, format, language, onError);');
        lines.push('        }');
        lines.push('');
        lines.push('        /// <summary>');
        lines.push(`        /// Get text by id from ${tableName} string table.`);
        lines.push('        /// Returns id if not found (fallback).');
        lines.push('        /// </summary>');
        lines.push('        public static string Get(string id)');
        lines.push('        {');
        lines.push('            return _cache.TryGetValue(id, out var text) ? text : id;');
        lines.push('        }');
        lines.push('');
        lines.push('        /// <summary>');
        lines.push(`        /// Unload ${tableName} string table and clear cache.`);
        lines.push('        /// </summary>');
        lines.push('        public static void Unload()');
        lines.push('        {');
        lines.push('            _cache.Clear();');
        lines.push('            _isLoaded = false;');
        lines.push('        }');
        lines.push('');
        lines.push('        /// <summary>Check if string table is loaded.</summary>');
        lines.push('        public static bool IsLoaded => _isLoaded;');
        lines.push('');
        lines.push('        /// <summary>Get the language used for loading.</summary>');
        lines.push('        public static SystemLanguage LoadedLanguage => _loadedLanguage;');
        lines.push('');
        lines.push('        /// <summary>Get the format used for loading.</summary>');
        lines.push('        public static global::Devian.TableFormat LoadedFormat => _loadedFormat;');
        lines.push('');
        lines.push('        // ====================================================================');
        lines.push('        // Parsing');
        lines.push('        // ====================================================================');
        lines.push('');
        lines.push('        private static void ParseNdjson(string content)');
        lines.push('        {');
        lines.push('            var lines = content.Split(\'\\n\', StringSplitOptions.RemoveEmptyEntries);');
        lines.push('            foreach (var line in lines)');
        lines.push('            {');
        lines.push('                var trimmed = line.Trim();');
        lines.push('                if (string.IsNullOrEmpty(trimmed)) continue;');
        lines.push('                var entry = JsonUtility.FromJson<StringEntry>(trimmed);');
        lines.push('                if (entry != null && !string.IsNullOrEmpty(entry.id))');
        lines.push('                {');
        lines.push('                    _cache[entry.id] = entry.text ?? string.Empty;');
        lines.push('                }');
        lines.push('            }');
        lines.push('        }');
        lines.push('');
        lines.push('        // base64 후보 판별: A-Za-z0-9+/= 만 허용, 길이 4 미만이면 false');
        lines.push('        private static bool IsLikelyBase64(string s)');
        lines.push('        {');
        lines.push('            if (string.IsNullOrEmpty(s) || s.Length < 4) return false;');
        lines.push('            for (int i = 0; i < s.Length; i++)');
        lines.push('            {');
        lines.push('                char c = s[i];');
        lines.push('                bool ok = (c >= \'A\' && c <= \'Z\') || (c >= \'a\' && c <= \'z\') ||');
        lines.push('                          (c >= \'0\' && c <= \'9\') || c == \'+\' || c == \'/\' || c == \'=\';');
        lines.push('                if (!ok) return false;');
        lines.push('            }');
        lines.push('            return true;');
        lines.push('        }');
        lines.push('');
        lines.push('        private static void ParsePb64(string content)');
        lines.push('        {');
        lines.push('            if (string.IsNullOrEmpty(content)) return;');
        lines.push('');
        lines.push('            content = content.Replace("\\r", "");');
        lines.push('            // 방어: \'chunk1|chunk2|...\' 형태 지원 + YAML의 \'m_Script: |\' 라인도 분해되어 필터링됨');
        lines.push('            content = content.Replace(\'|\', \'\\n\');');
        lines.push('');
        lines.push('            var lines = content.Split(\'\\n\', StringSplitOptions.RemoveEmptyEntries);');
        lines.push('            foreach (var line in lines)');
        lines.push('            {');
        lines.push('                var trimmed = line.Trim();');
        lines.push('                if (string.IsNullOrEmpty(trimmed)) continue;');
        lines.push('');
        lines.push('                // YAML 라인/잡문은 여기서 걸러져서 로그 스팸 방지');
        lines.push('                if (!IsLikelyBase64(trimmed)) continue;');
        lines.push('');
        lines.push('                try');
        lines.push('                {');
        lines.push('                    var bytes = Convert.FromBase64String(trimmed);');
        lines.push('                    ParseStringChunk(bytes);');
        lines.push('                }');
        lines.push(`                catch (Exception ex)`);
        lines.push('                {');
        lines.push('                    var preview = trimmed.Length <= 64 ? trimmed : (trimmed.Substring(0, 64) + "...");');
        lines.push(`                    global::Devian.Log.Error($"[ST_${tableName}] ParsePb64 failed. len={trimmed.Length} preview='{preview}' ex={ex}");`);
        lines.push('                }');
        lines.push('            }');
        lines.push('        }');
        lines.push('');
        lines.push('        private static void ParseStringChunk(byte[] bytes)');
        lines.push('        {');
        lines.push('            int offset = 0;');
        lines.push('            while (offset < bytes.Length)');
        lines.push('            {');
        lines.push('                var tag = ReadVarint(bytes, ref offset);');
        lines.push('                var fieldNumber = (int)(tag >> 3);');
        lines.push('                var wireType = (int)(tag & 0x7);');
        lines.push('                if (fieldNumber == 1 && wireType == 2)');
        lines.push('                {');
        lines.push('                    var length = (int)ReadVarint(bytes, ref offset);');
        lines.push('                    var entryBytes = new byte[length];');
        lines.push('                    Array.Copy(bytes, offset, entryBytes, 0, length);');
        lines.push('                    offset += length;');
        lines.push('                    var (id, text) = ParseStringEntry(entryBytes);');
        lines.push('                    if (!string.IsNullOrEmpty(id)) _cache[id] = text;');
        lines.push('                }');
        lines.push('                else { SkipField(bytes, ref offset, wireType); }');
        lines.push('            }');
        lines.push('        }');
        lines.push('');
        lines.push('        private static (string id, string text) ParseStringEntry(byte[] bytes)');
        lines.push('        {');
        lines.push('            string id = string.Empty, text = string.Empty;');
        lines.push('            int offset = 0;');
        lines.push('            while (offset < bytes.Length)');
        lines.push('            {');
        lines.push('                var tag = ReadVarint(bytes, ref offset);');
        lines.push('                var fieldNumber = (int)(tag >> 3);');
        lines.push('                var wireType = (int)(tag & 0x7);');
        lines.push('                if (wireType == 2)');
        lines.push('                {');
        lines.push('                    var length = (int)ReadVarint(bytes, ref offset);');
        lines.push('                    var str = Encoding.UTF8.GetString(bytes, offset, length);');
        lines.push('                    offset += length;');
        lines.push('                    if (fieldNumber == 1) id = str;');
        lines.push('                    else if (fieldNumber == 2) text = str;');
        lines.push('                }');
        lines.push('                else { SkipField(bytes, ref offset, wireType); }');
        lines.push('            }');
        lines.push('            return (id, text);');
        lines.push('        }');
        lines.push('');
        lines.push('        private static ulong ReadVarint(byte[] bytes, ref int offset)');
        lines.push('        {');
        lines.push('            ulong result = 0; int shift = 0;');
        lines.push('            while (offset < bytes.Length)');
        lines.push('            {');
        lines.push('                var b = bytes[offset++];');
        lines.push('                result |= (ulong)(b & 0x7f) << shift;');
        lines.push('                if ((b & 0x80) == 0) break;');
        lines.push('                shift += 7;');
        lines.push('            }');
        lines.push('            return result;');
        lines.push('        }');
        lines.push('');
        lines.push('        private static void SkipField(byte[] bytes, ref int offset, int wireType)');
        lines.push('        {');
        lines.push('            switch (wireType)');
        lines.push('            {');
        lines.push('                case 0: ReadVarint(bytes, ref offset); break;');
        lines.push('                case 1: offset += 8; break;');
        lines.push('                case 2: offset += (int)ReadVarint(bytes, ref offset); break;');
        lines.push('                case 5: offset += 4; break;');
        lines.push('            }');
        lines.push('        }');
        lines.push('');
        lines.push('        [Serializable]');
        lines.push('        private class StringEntry');
        lines.push('        {');
        lines.push('            public string id = string.Empty;');
        lines.push('            public string text = string.Empty;');
        lines.push('        }');
        lines.push('    }');
        lines.push('}');
        
        return lines.join('\n');
    }

    /**
     * Recursively copy directory with optional file extension filter.
     * @param {string} src Source directory
     * @param {string} dest Destination directory
     * @param {string} [extFilter] Optional file extension filter (e.g., '.cs')
     */
    copyDirRecursive(src, dest, extFilter = null) {
        fs.mkdirSync(dest, { recursive: true });
        
        for (const entry of fs.readdirSync(src, { withFileTypes: true })) {
            const srcPath = path.join(src, entry.name);
            const destPath = path.join(dest, entry.name);
            
            if (entry.isDirectory()) {
                this.copyDirRecursive(srcPath, destPath, extFilter);
            } else if (entry.isFile()) {
                if (!extFilter || entry.name.endsWith(extFilter)) {
                    fs.copyFileSync(srcPath, destPath);
                }
            }
        }
    }

    // ========================================================================
    // Static UPM Package Processing (e.g., com.devian.foundation)
    // SSOT: skills/devian-unity/03-package-metadata/SKILL.md
    // ========================================================================

    /**
     * Process a sample package (e.g., com.devian.samples).
     * samplePackages ONLY allows com.devian.samples.
     * SSOT: skills/devian/03-ssot/SKILL.md - Hard Rule
     * @param {string} upmName - UPM package name (e.g., "com.devian.samples")
     */
    async processSamplePackage(upmName) {
        console.log(`  [SamplePkg] ${upmName}`);

        // Compute paths from upmConfig + upmName
        const sourcePath = path.join(this.upmSourceDir, upmName);
        const stagingUpm = path.join(this.tempDir, `sample-${upmName}`);

        if (!fs.existsSync(sourcePath)) {
            console.log(`    [SKIP] Source not found: ${sourcePath}`);
            return;
        }

        // Copy entire source to staging
        this.copyDirRecursive(sourcePath, stagingUpm);
        console.log(`    [OK] Staged to ${stagingUpm}`);

        // GUARD: Validate UPM sample structure (Runtime/Editor separation)
        // SSOT: skills/devian-unity-samples/01-samples-authoring-guide/SKILL.md
        this.validateUpmSampleStructure(stagingUpm, upmName);
    }



    /**
     * GUARD: Validate UPM sample structure (Runtime/Editor separation).
     * Throws Error if sample structure is invalid.
     * SSOT: skills/devian-unity-samples/01-samples-authoring-guide/SKILL.md
     */
    validateUpmSampleStructure(stagingUpm, upmName) {
        const samplesDir = path.join(stagingUpm, 'Samples~');
        
        // Skip if no Samples~ folder
        if (!fs.existsSync(samplesDir)) {
            return;
        }

        const entries = fs.readdirSync(samplesDir, { withFileTypes: true });
        const sampleFolders = entries.filter(e => e.isDirectory());

        for (const sampleEntry of sampleFolders) {
            const sampleName = sampleEntry.name;
            const samplePath = path.join(samplesDir, sampleName);
            const runtimeDir = path.join(samplePath, 'Runtime');
            const editorDir = path.join(samplePath, 'Editor');

            const hasRuntime = fs.existsSync(runtimeDir);
            const hasEditor = fs.existsSync(editorDir);

            // Rule 1: Sample must have both Runtime/ and Editor/ folders
            if (!hasRuntime && !hasEditor) {
                throw new Error(
                    `Invalid UPM sample structure: ${upmName}/Samples~/${sampleName} missing Runtime/Editor folders.\n` +
                    `  Fix: Create Runtime/ and Editor/ subdirectories with appropriate scripts and asmdef files.`
                );
            }

            // Rule 2: If Runtime exists, it must have an asmdef
            if (hasRuntime) {
                const runtimeAsmdef = this.findAsmdef(runtimeDir);
                if (!runtimeAsmdef) {
                    throw new Error(
                        `Invalid UPM sample asmdef: ${upmName}/Samples~/${sampleName}/Runtime/ missing *.asmdef file.\n` +
                        `  Fix: Add a Runtime asmdef (e.g., Devian.Sample.asmdef) with no Editor platform restriction.`
                    );
                }

                // Check Runtime asmdef doesn't restrict to Editor-only
                const runtimeAsmdefContent = JSON.parse(fs.readFileSync(runtimeAsmdef, 'utf-8'));
                const includePlatforms = runtimeAsmdefContent.includePlatforms || [];
                if (includePlatforms.length === 1 && includePlatforms[0] === 'Editor') {
                    throw new Error(
                        `Invalid UPM sample asmdef: ${upmName}/Samples~/${sampleName}/Runtime/*.asmdef must NOT have includePlatforms:["Editor"].\n` +
                        `  File: ${runtimeAsmdef}\n` +
                        `  Fix: Remove or empty the includePlatforms array for Runtime asmdef.`
                    );
                }

                // Check Runtime scripts don't have "using UnityEditor"
                this.validateNoUnityEditorUsing(runtimeDir, upmName, sampleName);
            }

            // Rule 3: If Editor exists, it must have an asmdef with includePlatforms: ["Editor"]
            if (hasEditor) {
                const editorAsmdef = this.findAsmdef(editorDir);
                if (!editorAsmdef) {
                    throw new Error(
                        `Invalid UPM sample asmdef: ${upmName}/Samples~/${sampleName}/Editor/ missing *.asmdef file.\n` +
                        `  Fix: Add an Editor asmdef (e.g., Devian.Sample.Editor.asmdef) with includePlatforms:["Editor"].`
                    );
                }

                // Check Editor asmdef has includePlatforms: ["Editor"]
                const editorAsmdefContent = JSON.parse(fs.readFileSync(editorAsmdef, 'utf-8'));
                const includePlatforms = editorAsmdefContent.includePlatforms || [];
                if (!includePlatforms.includes('Editor')) {
                    throw new Error(
                        `Invalid UPM sample asmdef: ${upmName}/Samples~/${sampleName}/Editor/*.asmdef must include includePlatforms:["Editor"].\n` +
                        `  File: ${editorAsmdef}\n` +
                        `  Current includePlatforms: ${JSON.stringify(includePlatforms)}\n` +
                        `  Fix: Add "includePlatforms": ["Editor"] to the Editor asmdef.`
                    );
                }
            }

            console.log(`    [Guard] Sample validated: Samples~/${sampleName}`);
        }
    }

    /**
     * Find first *.asmdef file in a directory.
     */
    findAsmdef(dir) {
        if (!fs.existsSync(dir)) return null;
        const entries = fs.readdirSync(dir);
        const asmdef = entries.find(e => e.endsWith('.asmdef'));
        return asmdef ? path.join(dir, asmdef) : null;
    }

    /**
     * Validate that no *.cs files in a directory contain "using UnityEditor".
     */
    validateNoUnityEditorUsing(dir, upmName, sampleName) {
        const csFiles = this.findCsFiles(dir);
        for (const csFile of csFiles) {
            const content = fs.readFileSync(csFile, 'utf-8');
            if (content.includes('using UnityEditor;') || content.includes('using UnityEditor.')) {
                throw new Error(
                    `Invalid UPM sample code: Runtime script contains "using UnityEditor".\n` +
                    `  Package: ${upmName}\n` +
                    `  Sample: Samples~/${sampleName}\n` +
                    `  File: ${csFile}\n` +
                    `  Fix: Move this script to Editor/ folder or remove UnityEditor dependency.`
                );
            }
        }
    }

    /**
     * Find all *.cs files in a directory (recursive).
     */
    findCsFiles(dir) {
        const results = [];
        if (!fs.existsSync(dir)) return results;

        const entries = fs.readdirSync(dir, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            if (entry.isDirectory()) {
                results.push(...this.findCsFiles(fullPath));
            } else if (entry.isFile() && entry.name.endsWith('.cs')) {
                results.push(fullPath);
            }
        }
        return results;
    }

    /**
     * Copy generated content from staging to upm/<pkg>.
     * Target path is computed from upmConfig.sourceDir + upmName.
     * Only copies generated content (Editor/Generated, Runtime/Generated) to upm,
     * preserving manual files.
     * Final sync to packageDir happens in syncUpmToPackageDir().
     * @param {Object} pkgConfig - { upmName }
     */
    async copyStaticUpmGeneratedContent(pkgConfig) {
        const { upmName } = pkgConfig;
        
        const stagingUpm = path.join(this.tempDir, `static-${upmName}`);
        const targetPath = path.join(this.upmSourceDir, upmName);

        if (!fs.existsSync(stagingUpm)) {
            console.log(`  [SKIP] ${upmName}: staging not found`);
            return;
        }

        // Copy only Generated content (preserving manual files)
        // "Generated Only" 정책: 생성기가 clean+generate하는 영역은 오직 Generated 폴더만
        // SSOT: skills/devian/03-ssot/SKILL.md
        // 고정 유틸(_Shared, Singleton, Pool, PoolFactories)은 수기 코드이므로 복사 대상 아님
        const generatedPaths = [
            { src: 'Editor/Generated', dest: 'Editor/Generated' },
            { src: 'Runtime/Generated', dest: 'Runtime/Generated' }
        ];

        let copiedCount = 0;
        for (const { src, dest } of generatedPaths) {
            const srcPath = path.join(stagingUpm, src);
            const destPath = path.join(targetPath, dest);
            
            if (fs.existsSync(srcPath)) {
                // Clean dest and copy from staging
                if (fs.existsSync(destPath)) {
                    fs.rmSync(destPath, { recursive: true });
                }
                fs.mkdirSync(destPath, { recursive: true });
                this.copyDirRecursive(srcPath, destPath);
                
                const files = fs.readdirSync(destPath).filter(f => f.endsWith('.cs') || f.endsWith('.ts'));
                console.log(`    [OK] ${upmName}/${src} → upm (${files.length} files)`);
                copiedCount += files.length;
            } else {
                // Source doesn't exist: remove stale dest if present
                if (fs.existsSync(destPath)) {
                    fs.rmSync(destPath, { recursive: true });
                    console.log(`    [Cleanup] ${upmName}/${dest} → removed stale generated folder`);
                }
            }
        }

        if (copiedCount === 0) {
            console.log(`    [OK] ${upmName} → upm (no generated content)`);
        }
    }

    /**
     * Copy entire sample package from upm to packageDir (clean copy).
     * Sample packages are not generated - they are manually authored.
     * SSOT: skills/devian-unity-samples/01-samples-authoring-guide/SKILL.md
     * @param {string} upmName - Sample package name (e.g., "com.devian.samples")
     */
    async copySamplePackageToTarget(upmName) {
        const sourcePath = path.join(this.upmSourceDir, upmName);
        const targetPath = path.join(this.upmPackageDir, upmName);

        if (!fs.existsSync(sourcePath)) {
            console.log(`    [SKIP] ${upmName}: upm source not found`);
            return;
        }

        // Clean target and copy entire package
        if (fs.existsSync(targetPath)) {
            fs.rmSync(targetPath, { recursive: true });
        }
        fs.mkdirSync(targetPath, { recursive: true });
        this.copyDirRecursive(sourcePath, targetPath);

        // Count copied files for logging
        const countFiles = (dir) => {
            let count = 0;
            if (!fs.existsSync(dir)) return 0;
            const entries = fs.readdirSync(dir, { withFileTypes: true });
            for (const entry of entries) {
                if (entry.isDirectory()) {
                    count += countFiles(path.join(dir, entry.name));
                } else if (entry.isFile()) {
                    count++;
                }
            }
            return count;
        };

        const fileCount = countFiles(targetPath);
        console.log(`    [OK] ${upmName} → packageDir (${fileCount} files)`);
    }

    /**
     * Verify that unity-common TableId base files exist.
     * Prevents build from succeeding when critical files are missing.
     */
    async verifyUnityCommonTableIdFiles() {
        // Use upmPackageDir from upmConfig (validated in run())
        if (!this.upmPackageDir) {
            console.log('  [SKIP] No upmPackageDir configured, skipping unity-common guard check');
            return;
        }

        const foundationPath = path.join(this.upmPackageDir, 'com.devian.foundation');
        const requiredFiles = [
            'Editor/TableId/EditorID_SelectorBase.cs',
            'Editor/TableId/EditorID_DrawerBase.cs',
            'Editor/Devian.Unity.Editor.asmdef'
        ];

        const missingFiles = [];
        for (const relPath of requiredFiles) {
            const fullPath = path.join(foundationPath, relPath);
            if (!fs.existsSync(fullPath)) {
                missingFiles.push(relPath);
            }
        }

        if (missingFiles.length > 0) {
            console.error();
            console.error('[FAIL] com.devian.foundation is missing Editor/TableId base files:');
            for (const file of missingFiles) {
                console.error(`       - ${file}`);
            }
            console.error();
            console.error('Fix: Ensure com.devian.foundation package contains Editor/TableId base files.');
            console.error('     These files should be in: upm/com.devian.foundation/Editor/TableId/');
            console.error();
            throw new Error('[FAIL] Foundation package is missing Editor/TableId base files.');
        }

        console.log('  [Guard] foundation TableId base files verified');
    }


    generateProtocolUpmScaffold(groupName, stagingCs) {
        // Protocol UPM은 Runtime-only (Editor 생성 금지)
        // SSOT: skills/devian/03-ssot/SKILL.md — Protocol UPM 자동 생성 규칙
        const csProjectName = `Devian.Protocol.${groupName}`;
        const upmName = this.computeProtocolUpmName(groupName);
        const stagingUpm = path.join(this.tempDir, `${csProjectName}-upm`);
        const stagingRuntime = path.join(stagingUpm, 'Runtime');

        fs.mkdirSync(stagingRuntime, { recursive: true });

        // package.json (스킬 17 준수: version 0.1.0, author, dependencies)
        // SSOT: skills/devian/03-ssot/SKILL.md — Hard Rule: Base UPM package is com.devian.foundation only
        const packageJson = JSON.stringify({
            name: upmName,
            version: '0.1.0',
            displayName: `Devian Protocol ${groupName}`,
            description: `Protocol definitions for ${groupName}. Generated by Devian Build System.`,
            unity: '2021.3',
            author: {
                name: 'Kim, Hyong Joon'
            },
            dependencies: {
                'com.devian.foundation': '0.1.0',
                'com.devian.domain.common': '0.1.0'
            }
        }, null, 2);
        fs.writeFileSync(path.join(stagingUpm, 'package.json'), packageJson);

        // Runtime.asmdef (정책: 단일 Devian.Core asmdef만 참조)
        const runtimeAsmdef = JSON.stringify({
            name: csProjectName,
            rootNamespace: csProjectName,
            references: [
                'Devian.Core',
                'Devian.Domain.Common'
            ],
            includePlatforms: [],
            excludePlatforms: [],
            allowUnsafeCode: false,
            overrideReferences: false,
            precompiledReferences: [],
            autoReferenced: true,
            defineConstraints: [],
            versionDefines: [],
            noEngineReferences: true
        }, null, 2);
        fs.writeFileSync(path.join(stagingRuntime, `${csProjectName}.asmdef`), runtimeAsmdef);

        // Editor asmdef 생성 금지 (Protocol UPM은 Runtime-only)

        // Copy C# generated files to Runtime
        if (fs.existsSync(stagingCs)) {
            for (const file of fs.readdirSync(stagingCs)) {
                if (file.endsWith('.cs')) {
                    fs.copyFileSync(
                        path.join(stagingCs, file),
                        path.join(stagingRuntime, file)
                    );
                }
            }
        }
    }

    copyUpmToTarget(stagingUpm, targetDir) {
        if (!fs.existsSync(stagingUpm)) return;

        fs.mkdirSync(targetDir, { recursive: true });

        // package.json - ALWAYS overwrite (staging is SSOT for generated packages)
        const packageJsonSrc = path.join(stagingUpm, 'package.json');
        const packageJsonDest = path.join(targetDir, 'package.json');
        if (fs.existsSync(packageJsonSrc)) {
            fs.copyFileSync(packageJsonSrc, packageJsonDest);
        }

        // Samples~ folder (clean & copy) - MUST copy BEFORE syncSamplesMetadata
        const stagingSamples = path.join(stagingUpm, 'Samples~');
        const targetSamples = path.join(targetDir, 'Samples~');
        if (fs.existsSync(stagingSamples)) {
            this.cleanAndCopy(stagingSamples, targetSamples);
        }

        // Sync samples metadata AFTER Samples~ has been copied
        this.syncSamplesMetadata(targetDir);

        // Editor folder handling
        const stagingEditor = path.join(stagingUpm, 'Editor');
        const targetEditor = path.join(targetDir, 'Editor');
        if (fs.existsSync(stagingEditor)) {
            fs.mkdirSync(targetEditor, { recursive: true });
            
            // Get staging editor contents
            const stagingEntries = new Set(fs.readdirSync(stagingEditor));
            
            // Remove directories in target that don't exist in staging
            // This ensures Editor/Generated is removed when staging doesn't have it
            if (fs.existsSync(targetEditor)) {
                for (const entry of fs.readdirSync(targetEditor, { withFileTypes: true })) {
                    if (entry.isDirectory() && !stagingEntries.has(entry.name)) {
                        const orphanPath = path.join(targetEditor, entry.name);
                        fs.rmSync(orphanPath, { recursive: true });
                    }
                }
            }
            
            // Copy staging editor contents
            for (const entry of fs.readdirSync(stagingEditor, { withFileTypes: true })) {
                const srcPath = path.join(stagingEditor, entry.name);
                const destPath = path.join(targetEditor, entry.name);
                
                if (entry.isDirectory()) {
                    // For directories (like Generated), always clean and copy
                    this.cleanAndCopy(srcPath, destPath);
                } else {
                    // For files (asmdef, etc.), always overwrite from staging (staging is source of truth)
                    fs.copyFileSync(srcPath, destPath);
                }
            }
        } else if (fs.existsSync(targetEditor)) {
            // staging에 Editor가 없으면 target Editor 삭제 (staging이 SSOT)
            // Protocol UPM 등 Runtime-only 패키지에서 이전 빌드 잔재 제거
            fs.rmSync(targetEditor, { recursive: true });
        }

        // Runtime folder (clean & copy)
        const stagingRuntime = path.join(stagingUpm, 'Runtime');
        const targetRuntime = path.join(targetDir, 'Runtime');
        this.cleanAndCopy(stagingRuntime, targetRuntime);
    }

    /**
     * Sync samples metadata in package.json based on Samples~ folder contents.
     * If Samples~ folder exists with subfolders, automatically adds/updates samples field.
     * @param {string} packageDir - UPM package directory
     */
    syncSamplesMetadata(packageDir) {
        const packageJsonPath = path.join(packageDir, 'package.json');
        const samplesDir = path.join(packageDir, 'Samples~');

        // Skip if no package.json
        if (!fs.existsSync(packageJsonPath)) return;

        // Check if Samples~ folder exists
        if (!fs.existsSync(samplesDir)) return;

        // Get sample folders
        const sampleFolders = fs.readdirSync(samplesDir, { withFileTypes: true })
            .filter(dirent => dirent.isDirectory())
            .map(dirent => dirent.name);

        // Skip if no sample folders
        if (sampleFolders.length === 0) return;

        // Read existing package.json
        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));

        // Build samples array from folder structure
        const samples = sampleFolders.map(folderName => {
            const samplePath = `Samples~/${folderName}`;
            
            // Check for existing sample entry to preserve displayName/description
            const existingSample = (packageJson.samples || [])
                .find(s => s.path === samplePath);

            if (existingSample) {
                return existingSample;
            }

            // Generate default metadata for new samples
            return {
                displayName: this.folderNameToDisplayName(folderName),
                description: `Sample: ${folderName}`,
                path: samplePath
            };
        });

        // Update samples field
        packageJson.samples = samples;

        // Write back with 2-space indent
        fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');
        console.log(`      [UPM] Synced ${samples.length} sample(s) in ${path.basename(packageDir)}/package.json`);
    }

    /**
     * Convert folder name to display name (e.g., "BasicWsClient" -> "Basic Ws Client")
     * @param {string} folderName - Folder name
     * @returns {string} - Human-readable display name
     */
    folderNameToDisplayName(folderName) {
        // Insert space before uppercase letters and trim
        return folderName
            .replace(/([A-Z])/g, ' $1')
            .replace(/^[\s]/, '')
            .trim();
    }

    /**
     * Convert asmdef reference name to UPM package name.
     * @param {string} asmdefRef - Assembly reference name (e.g., "Devian.Core", "Devian.Domain.Common")
     * @returns {string|null} - UPM package name or null if not mappable
     */
    asmdefRefToUpmPackage(asmdefRef) {
        // SSOT: skills/devian/03-ssot/SKILL.md — Hard Rule: Base UPM package is com.devian.foundation only
        const mapping = {
            'Devian.Core': 'com.devian.foundation',
            'Devian.Unity': 'com.devian.foundation',
            'Devian.Network': 'com.devian.foundation',
            'Devian.Protobuf': 'com.devian.foundation',
        };

        // Direct mapping
        if (mapping[asmdefRef]) {
            return mapping[asmdefRef];
        }

        // Pattern: Devian + .Domain.{Domain} (assembly) -> com.devian.domain.{domain} (UPM)
        const domainMatch = asmdefRef.match(/^Devian\.Domain\.(\w+)$/);
        if (domainMatch) {
            return `com.devian.domain.${domainMatch[1].toLowerCase()}`;
        }

        // Skip self-references or unknown packages
        return null;
    }

    /**
     * Scan Runtime/Generated.* folders for asmdef files and extract their references.
     * Updates package.json dependencies based on asmdef references.
     * @param {string} packageDir - UPM package directory
     */
    syncGeneratedDependencies(packageDir) {
        const packageJsonPath = path.join(packageDir, 'package.json');
        const runtimeDir = path.join(packageDir, 'Runtime');

        // Skip if no package.json or Runtime folder
        if (!fs.existsSync(packageJsonPath)) return;
        if (!fs.existsSync(runtimeDir)) return;

        // Find Generated.* folders
        const generatedFolders = fs.readdirSync(runtimeDir, { withFileTypes: true })
            .filter(dirent => dirent.isDirectory() && dirent.name.startsWith('Generated.'))
            .map(dirent => path.join(runtimeDir, dirent.name));

        if (generatedFolders.length === 0) return;

        // Collect all asmdef references
        const allRefs = new Set();

        for (const folder of generatedFolders) {
            // Find all .asmdef files recursively
            const findAsmdefFiles = (dir) => {
                const files = [];
                const entries = fs.readdirSync(dir, { withFileTypes: true });
                for (const entry of entries) {
                    const fullPath = path.join(dir, entry.name);
                    if (entry.isDirectory()) {
                        files.push(...findAsmdefFiles(fullPath));
                    } else if (entry.name.endsWith('.asmdef')) {
                        files.push(fullPath);
                    }
                }
                return files;
            };

            const asmdefFiles = findAsmdefFiles(folder);
            
            for (const asmdefPath of asmdefFiles) {
                try {
                    const asmdef = JSON.parse(fs.readFileSync(asmdefPath, 'utf-8'));
                    if (asmdef.references && Array.isArray(asmdef.references)) {
                        for (const ref of asmdef.references) {
                            allRefs.add(ref);
                        }
                    }
                } catch (e) {
                    console.warn(`      [WARN] Failed to parse ${asmdefPath}: ${e.message}`);
                }
            }
        }

        if (allRefs.size === 0) return;

        // Read existing package.json
        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
        const existingDeps = packageJson.dependencies || {};

        // Default versions for packages (can be improved by scanning actual packages)
        // SSOT: skills/devian/03-ssot/SKILL.md — Hard Rule: Base UPM package is com.devian.foundation only
        const defaultVersions = {
            'com.devian.foundation': '0.1.0',
            'com.devian.domain.common': '0.1.0',
        };

        // Convert refs to UPM packages and add to dependencies
        let addedCount = 0;
        for (const ref of allRefs) {
            const upmPackage = this.asmdefRefToUpmPackage(ref);
            if (upmPackage && !existingDeps[upmPackage]) {
                const version = defaultVersions[upmPackage] || '1.0.0';
                existingDeps[upmPackage] = version;
                addedCount++;
            }
        }

        if (addedCount > 0) {
            packageJson.dependencies = existingDeps;
            fs.writeFileSync(packageJsonPath, JSON.stringify(packageJson, null, 2) + '\n');
            console.log(`      [UPM] Added ${addedCount} generated dependencies in ${path.basename(packageDir)}/package.json`);
        }
    }

    /**
     * Sync UPM packages from upm to packageDir.
     * 
     * SSOT: upm is the single source of truth for all UPM packages.
     * This sync copies all packages from upm to packageDir (Unity Packages).
     *
     * SSOT: skills/devian/03-ssot/SKILL.md
     */
    async syncUpmToPackageDir() {
        if (!this.upmSourceDir || !this.upmPackageDir) {
            console.log('  [SKIP] upmSourceDir or upmPackageDir not configured');
            return;
        }

        // Collect package names from upm
        const upmPackages = new Set();
        if (fs.existsSync(this.upmSourceDir)) {
            const entries = fs.readdirSync(this.upmSourceDir, { withFileTypes: true });
            for (const entry of entries) {
                if (entry.isDirectory() && !entry.name.startsWith('.')) {
                    upmPackages.add(entry.name);
                }
            }
        }

        // Sync all upm packages to packageDir
        if (upmPackages.size > 0) {
            console.log(`  [Sync] upm → packageDir (${upmPackages.size} packages)`);
            for (const pkgName of upmPackages) {
                const sourcePath = path.join(this.upmSourceDir, pkgName);
                const targetPath = path.join(this.upmPackageDir, pkgName);

                // Clean target (package-level clean)
                if (fs.existsSync(targetPath)) {
                    fs.rmSync(targetPath, { recursive: true });
                }

                // Copy package to packageDir
                fs.mkdirSync(targetPath, { recursive: true });
                this.copyDirRecursive(sourcePath, targetPath);
                console.log(`    [UPM] ${pkgName} → ${targetPath}`);
            }
        } else {
            console.log('  [SKIP] No packages to sync');
        }
    }

    /**
     * Sync samples metadata for all UPM packages in configured upmPackageDir.
     * Scans for packages with Samples~ folders and updates their package.json.
     */
    async syncAllUpmSamples() {
        // Collect all unique package directories
        const upmPackageDirs = new Set();

        // Primary: use upmConfig.packageDir (required, validated earlier)
        if (this.upmPackageDir) {
            upmPackageDirs.add(this.upmPackageDir);
        }

        // Also check domains.upmTargetDir for backward compatibility
        if (this.config.domains) {
            for (const domainConfig of Object.values(this.config.domains)) {
                if (domainConfig.upmTargetDir) {
                    upmPackageDirs.add(this.resolvePath(domainConfig.upmTargetDir));
                }
            }
        }

        if (upmPackageDirs.size === 0) {
            console.log('  No UPM target directories configured, skipping samples sync.');
            return;
        }

        // Scan each package directory for UPM packages with Samples~ folders
        for (const packagesDir of upmPackageDirs) {
            if (!fs.existsSync(packagesDir)) continue;

            console.log(`  [Scan] ${packagesDir}`);

            // List subdirectories (each should be a UPM package)
            const entries = fs.readdirSync(packagesDir, { withFileTypes: true });
            for (const entry of entries) {
                if (!entry.isDirectory()) continue;

                const packageDir = path.join(packagesDir, entry.name);
                const packageJsonPath = path.join(packageDir, 'package.json');
                const samplesDir = path.join(packageDir, 'Samples~');

                // Skip if not a UPM package (no package.json)
                if (!fs.existsSync(packageJsonPath)) continue;

                // Skip if no Samples~ folder
                if (!fs.existsSync(samplesDir)) continue;

                // Sync samples metadata
                this.syncSamplesMetadata(packageDir);

                // Sync generated dependencies from Runtime/Generated.* asmdef files
                this.syncGeneratedDependencies(packageDir);
            }
        }
    }

    // ========================================================================
    // Forbidden Namespace Guard (재발 방지)
    // SSOT: skills/devian-common/01-module-policy/SKILL.md
    // ========================================================================

    /**
     * Validate upmConfig section exists and has required fields.
     * SSOT: skills/devian/03-ssot/SKILL.md
     */
    validateUpmConfig() {
        const upmConfig = this.config.upmConfig;

        if (!upmConfig) {
            throw new Error(
                '[FAIL] Missing required "upmConfig" section in config.json.\n' +
                '  Required fields:\n' +
                '    "upmConfig": {\n' +
                '      "sourceDir": "../framework-cs/upm",\n' +
                '      "packageDir": "../framework-cs/apps/UnityExample/Packages"\n' +
                '    }'
            );
        }

        if (!upmConfig.sourceDir || typeof upmConfig.sourceDir !== 'string') {
            throw new Error(
                '[FAIL] Missing or invalid "upmConfig.sourceDir".\n' +
                '  Expected: path to UPM source root (e.g., "../framework-cs/upm")'
            );
        }

        if (!upmConfig.packageDir || typeof upmConfig.packageDir !== 'string') {
            throw new Error(
                '[FAIL] Missing or invalid "upmConfig.packageDir".\n' +
                '  Expected: path to Unity Packages root (e.g., "../framework-cs/apps/UnityExample/Packages")'
            );
        }

        // Resolve and validate paths (upm is single SSOT)
        this.upmSourceDir = this.resolvePath(upmConfig.sourceDir);
        this.upmPackageDir = this.resolvePath(upmConfig.packageDir);

        console.log(`  [OK] upmConfig.sourceDir: ${this.upmSourceDir}`);
        console.log(`  [OK] upmConfig.packageDir: ${this.upmPackageDir}`);

        // Validate csConfig (required)
        // generateDir is optional - falls back to moduleDir (unified structure)
        if (this.config.csConfig) {
            const csConfig = this.config.csConfig;
            if (csConfig.moduleDir) {
                this.csModuleDir = this.resolvePath(csConfig.moduleDir);
                console.log(`  [OK] csConfig.moduleDir: ${this.csModuleDir}`);
            }
            // generateDir: use if specified, otherwise fall back to moduleDir (unified)
            if (csConfig.generateDir) {
                this.csGenerateDir = this.resolvePath(csConfig.generateDir);
                console.log(`  [OK] csConfig.generateDir: ${this.csGenerateDir}`);
            } else if (this.csModuleDir) {
                this.csGenerateDir = this.csModuleDir;
                console.log(`  [OK] csConfig.generateDir: ${this.csGenerateDir} (unified with moduleDir)`);
            }
        }

        // Validate tsConfig (optional, for backward compatibility)
        // generateDir is optional - falls back to moduleDir (unified structure)
        if (this.config.tsConfig) {
            const tsConfig = this.config.tsConfig;
            if (tsConfig.moduleDir) {
                this.tsModuleDir = this.resolvePath(tsConfig.moduleDir);
                console.log(`  [OK] tsConfig.moduleDir: ${this.tsModuleDir}`);
            }
            // generateDir: use if specified, otherwise fall back to moduleDir (unified)
            if (tsConfig.generateDir) {
                this.tsGenerateDir = this.resolvePath(tsConfig.generateDir);
                console.log(`  [OK] tsConfig.generateDir: ${this.tsGenerateDir}`);
                
                // Create ts generate directory if it doesn't exist
                if (!fs.existsSync(this.tsGenerateDir)) {
                    fs.mkdirSync(this.tsGenerateDir, { recursive: true });
                }
            } else if (this.tsModuleDir) {
                this.tsGenerateDir = this.tsModuleDir;
                console.log(`  [OK] tsConfig.generateDir: ${this.tsGenerateDir} (unified with moduleDir)`);
            }
        }

        // Resolve tableConfig.*Dirs (global data export targets)
        // SSOT: skills/devian/03-ssot/SKILL.md
        //
        // Hard Rules:
        // - dataConfig is forbidden (deprecated layer is not allowed)
        // - tableConfig must exist
        // - soundDirs/stringDirs/tableDirs must exist and must be string[]
        // - arrays can be empty, but keys must exist for visibility/consistency
        if (this.config.dataConfig !== undefined) {
            throw new Error(
                `[FAIL] dataConfig is forbidden.\n` +
                `  File: input/config.json\n` +
                `  Fix: Remove "dataConfig" entirely and use "tableConfig".\n` +
                `  tableConfig keys: soundDirs, stringDirs, tableDirs`
            );
        }

        const tableConfig = this.config.tableConfig;
        if (!tableConfig || typeof tableConfig !== 'object') {
            throw new Error(
                `[FAIL] Missing required "tableConfig" section in config.json.\n` +
                `  Required keys: soundDirs, stringDirs, tableDirs (each is string[]).\n` +
                `  Example:\n` +
                `    "tableConfig": {\n` +
                `      "soundDirs": ["../.../Assets/Bundles/sounds"],\n` +
                `      "stringDirs": ["../.../Assets/Bundles/Strings"],\n` +
                `      "tableDirs": ["../.../Assets/Bundles/Tables"]\n` +
                `    }`
            );
        }

        const requireStringArray = (key) => {
            const v = tableConfig[key];
            if (!Array.isArray(v)) {
                throw new Error(
                    `[FAIL] tableConfig.${key} must exist and must be string[].\n` +
                    `  File: input/config.json\n` +
                    `  Fix: Add "${key}": [] (or a list of paths)`
                );
            }
            for (let i = 0; i < v.length; i++) {
                if (typeof v[i] !== 'string') {
                    throw new Error(
                        `[FAIL] tableConfig.${key}[${i}] must be a string.\n` +
                        `  Was: ${JSON.stringify(v[i])}`
                    );
                }
            }
            return v;
        };

        this.soundDirs = requireStringArray('soundDirs').map(dir => this.resolvePath(dir));
        this.stringDirs = requireStringArray('stringDirs').map(dir => this.resolvePath(dir));
        this.tableDirs  = requireStringArray('tableDirs').map(dir => this.resolvePath(dir));

        console.log(`  [OK] tableConfig.soundDirs: ${this.soundDirs.length} targets`);
        console.log(`  [OK] tableConfig.stringDirs: ${this.stringDirs.length} targets`);
        console.log(`  [OK] tableConfig.tableDirs: ${this.tableDirs.length} targets`);

        // Path Guards (CRITICAL)
        this.validatePathGuards();
    }

    /**
     * Validate path guards to prevent accidental modification of dangerous directories.
     * Note: generateDir == moduleDir is now allowed (unified structure).
     * SSOT: skills/devian/03-ssot/SKILL.md
     */
    validatePathGuards() {
        // Guard: generateDirs must not be repo root or dangerous paths
        const dangerousPaths = [this.rootDir, path.dirname(this.rootDir), '/'];
        for (const dangerous of dangerousPaths) {
            if (this.csGenerateDir && path.resolve(this.csGenerateDir) === path.resolve(dangerous)) {
                throw new Error(`[FAIL] csConfig.generateDir cannot be repo root or parent: ${this.csGenerateDir}`);
            }
            if (this.tsGenerateDir && path.resolve(this.tsGenerateDir) === path.resolve(dangerous)) {
                throw new Error(`[FAIL] tsConfig.generateDir cannot be repo root or parent: ${this.tsGenerateDir}`);
            }
        }

        console.log('  [OK] Path guards validated');
    }


    /**
     * Check for forbidden fields and hard fail if found.
     * SSOT: skills/devian/03-ssot/SKILL.md
     */
    checkForbiddenFields() {
        const errors = [];

        // Check samplePackages - must be string[] now
        if (this.config.samplePackages && Array.isArray(this.config.samplePackages)) {
            for (let i = 0; i < this.config.samplePackages.length; i++) {
                const item = this.config.samplePackages[i];

                if (typeof item !== 'string') {
                    errors.push(
                        `samplePackages[${i}] must be a string, not an object.\n` +
                        `  samplePackages is string[] of UPM package names.\n` +
                        `  Was: ${JSON.stringify(item)}\n` +
                        `  Fix: Use plain string like "com.devian.samples"`
                    );
                }
            }
        }

        // Check protocols for forbidden fields
        if (this.config.protocols && Array.isArray(this.config.protocols)) {
            for (let i = 0; i < this.config.protocols.length; i++) {
                const proto = this.config.protocols[i];

                if (proto.upmTargetDir !== undefined) {
                    errors.push(
                        `protocols[${i}].upmTargetDir is forbidden and no longer supported.\n` +
                        `  Was: { "upmTargetDir": "${proto.upmTargetDir}", ... }\n` +
                        `  Fix: Remove this field. Protocol UPM is now auto-generated from group name.`
                    );
                }

                // upmName is now forbidden - computed automatically from group
                if (proto.upmName !== undefined) {
                    errors.push(
                        `protocols[${i}].upmName is forbidden and no longer supported.\n` +
                        `  Protocol UPM name is now computed automatically from group name.\n` +
                        `  Was: { "upmName": "${proto.upmName}", ... }\n` +
                        `  Fix: Remove "upmName" field. It will be computed as "com.devian.protocol.${(proto.group || 'unknown').toLowerCase()}"`
                    );
                }

                // csTargetDir/tsTargetDir are now forbidden - use csConfig/tsConfig.generateDir
                if (proto.csTargetDir !== undefined) {
                    errors.push(
                        `protocols[${i}].csTargetDir is forbidden and no longer supported.\n` +
                        `  Protocol C# output is now always placed in csConfig.generateDir.\n` +
                        `  Was: { "csTargetDir": "${proto.csTargetDir}", ... }\n` +
                        `  Fix: Remove "csTargetDir" from protocols[${i}]. Use csConfig.generateDir instead.`
                    );
                }

                if (proto.tsTargetDir !== undefined) {
                    errors.push(
                        `protocols[${i}].tsTargetDir is forbidden and no longer supported.\n` +
                        `  Protocol TS output is now always placed in tsConfig.generateDir.\n` +
                        `  Was: { "tsTargetDir": "${proto.tsTargetDir}", ... }\n` +
                        `  Fix: Remove "tsTargetDir" from protocols[${i}]. Use tsConfig.generateDir instead.`
                    );
                }
            }
        }

        // Check domains for forbidden fields (csTargetDir, tsTargetDir, dataTargetDirs)
        if (this.config.domains && typeof this.config.domains === 'object') {
            for (const [domainKey, domainConfig] of Object.entries(this.config.domains)) {
                if (domainConfig.csTargetDir !== undefined) {
                    errors.push(
                        `domains.${domainKey}.csTargetDir is forbidden and no longer supported.\n` +
                        `  Domain C# output is now always placed in csConfig.generateDir.\n` +
                        `  Was: { "csTargetDir": "${domainConfig.csTargetDir}", ... }\n` +
                        `  Fix: Remove "csTargetDir" from domains.${domainKey}. Use csConfig.generateDir instead.`
                    );
                }

                if (domainConfig.tsTargetDir !== undefined) {
                    errors.push(
                        `domains.${domainKey}.tsTargetDir is forbidden and no longer supported.\n` +
                        `  Domain TS output is now always placed in tsConfig.generateDir.\n` +
                        `  Was: { "tsTargetDir": "${domainConfig.tsTargetDir}", ... }\n` +
                        `  Fix: Remove "tsTargetDir" from domains.${domainKey}. Use tsConfig.generateDir instead.`
                    );
                }

                if (domainConfig.dataTargetDirs !== undefined) {
                    errors.push(
                        `domains.${domainKey}.dataTargetDirs is forbidden and no longer supported.\n` +
                        `  Data export output is now configured globally via tableConfig.soundDirs/stringDirs/tableDirs.\n` +
                        `  Was: { "dataTargetDirs": ${JSON.stringify(domainConfig.dataTargetDirs)}, ... }\n` +
                        `  Fix: Remove "dataTargetDirs" from domains.${domainKey}. Use tableConfig instead.`
                    );
                }

                // contractsDir → contractDir (legacy key removed)
                if (domainConfig.contractsDir !== undefined) {
                    errors.push(
                        `domains.${domainKey}.contractsDir is forbidden and no longer supported.\n` +
                        `  Use "contractDir" instead of "contractsDir".\n` +
                        `  Was: { "contractsDir": "${domainConfig.contractsDir}", ... }\n` +
                        `  Fix: Rename "contractsDir" to "contractDir" in domains.${domainKey}.`
                    );
                }

                // tablesDir → tableDir (legacy key removed)
                if (domainConfig.tablesDir !== undefined) {
                    errors.push(
                        `domains.${domainKey}.tablesDir is forbidden and no longer supported.\n` +
                        `  Use "tableDir" instead of "tablesDir".\n` +
                        `  Was: { "tablesDir": "${domainConfig.tablesDir}", ... }\n` +
                        `  Fix: Rename "tablesDir" to "tableDir" in domains.${domainKey}.`
                    );
                }
            }
        }

        // tableConfig is required (dataConfig is forbidden)
        if (this.config.dataConfig !== undefined) {
            errors.push(
                `dataConfig is forbidden (deprecated layer not allowed).\n` +
                `  Fix: Remove "dataConfig" and use "tableConfig" with soundDirs/stringDirs/tableDirs.`
            );
        }

        const tc = this.config.tableConfig;
        if (!tc || typeof tc !== 'object') {
            errors.push(
                `tableConfig is required.\n` +
                `  Add tableConfig to config.json.\n` +
                `  Required keys: soundDirs, stringDirs, tableDirs (each is string[]).`
            );
        } else {
            const keys = ['soundDirs', 'stringDirs', 'tableDirs'];
            for (const k of keys) {
                if (!Array.isArray(tc[k])) {
                    errors.push(
                        `tableConfig.${k} must exist and must be string[].\n` +
                        `  Fix: Add "${k}": [] (or list of paths) to tableConfig.`
                    );
                }
            }
        }

        if (errors.length > 0) {
            throw new Error(
                '[FAIL] Forbidden fields detected in input json:\n\n' +
                errors.map((e, i) => `${i + 1}. ${e}`).join('\n\n')
            );
        }

        console.log('  [OK] No forbidden fields found.');
    }

    /**
     * Validate C# modules in unified module directory.
     * All modules must exist and have valid .csproj files.
     * SSOT: skills/devian/03-ssot/SKILL.md
     */
    async validateCsModules() {
        console.log('  [Validate] C# modules...');
        
        // Validate module (manual) - must exist and be valid
        if (this.csModuleDir && fs.existsSync(this.csModuleDir)) {
            const moduleEntries = fs.readdirSync(this.csModuleDir, { withFileTypes: true });
            let moduleCount = 0;
            
            for (const entry of moduleEntries) {
                if (!entry.isDirectory() || entry.name.startsWith('.')) continue;
                
                const modulePath = path.join(this.csModuleDir, entry.name);
                const csprojFiles = this.findCsprojFiles(modulePath);
                
                if (csprojFiles.length === 0) {
                    throw new Error(
                        `[FAIL] Invalid C# module in moduleDir!\n` +
                        `  Module: ${entry.name}\n` +
                        `  Path: ${modulePath}\n` +
                        `  Reason: No .csproj file found.\n` +
                        `  module is manual-only and must contain valid C# projects.`
                    );
                }
                moduleCount++;
            }
            
            if (moduleCount > 0) {
                console.log(`    [OK] module: ${moduleCount} modules validated (manual)`);
            }
        }
        
        // Validate generated modules - when generateDir differs from moduleDir
        if (this.csGenerateDir && this.csGenerateDir !== this.csModuleDir && fs.existsSync(this.csGenerateDir)) {
            const genEntries = fs.readdirSync(this.csGenerateDir, { withFileTypes: true });
            let genCount = 0;
            
            for (const entry of genEntries) {
                if (!entry.isDirectory() || entry.name.startsWith('.')) continue;
                
                const modulePath = path.join(this.csGenerateDir, entry.name);
                const csprojFiles = this.findCsprojFiles(modulePath);
                
                if (csprojFiles.length === 0) {
                    throw new Error(
                        `[FAIL] Invalid C# module in generateDir!\n` +
                        `  Module: ${entry.name}\n` +
                        `  Path: ${modulePath}\n` +
                        `  Reason: No .csproj file found.\n` +
                        `  Generated modules must be "complete" with .csproj.`
                    );
                }
                genCount++;
            }
            
            if (genCount > 0) {
                console.log(`    [OK] module (generated): ${genCount} modules validated`);
            }
        }
    }

    /**
     * Validate TS modules in unified module directory.
     * All modules must have package.json at root.
     * SSOT: skills/devian/03-ssot/SKILL.md
     */
    async validateTsModules() {
        console.log('  [Validate] TS modules...');
        
        // Validate tsModuleDir (manual) - must exist and contain valid TS packages
        if (this.tsModuleDir && fs.existsSync(this.tsModuleDir)) {
            const moduleEntries = fs.readdirSync(this.tsModuleDir, { withFileTypes: true });
            let moduleCount = 0;
            
            for (const entry of moduleEntries) {
                if (!entry.isDirectory() || entry.name.startsWith('.')) continue;
                // Skip non-package directories
                if (entry.name === 'node_modules') continue;
                
                const modulePath = path.join(this.tsModuleDir, entry.name);
                const packageJsonPath = path.join(modulePath, 'package.json');
                
                if (!fs.existsSync(packageJsonPath)) {
                    throw new Error(
                        `[FAIL] Invalid TS module in tsModuleDir!\n` +
                        `  Module: ${entry.name}\n` +
                        `  Path: ${modulePath}\n` +
                        `  Reason: No package.json found.\n` +
                        `  tsModuleDir is manual-only and must contain valid TS packages.`
                    );
                }
                moduleCount++;
            }
            
            if (moduleCount > 0) {
                console.log(`    [OK] ts module: ${moduleCount} modules validated (manual)`);
            }
        }
        
        // Validate tsGenerateDir (generated) - when generateDir differs from moduleDir
        if (this.tsGenerateDir && this.tsGenerateDir !== this.tsModuleDir && fs.existsSync(this.tsGenerateDir)) {
            const genEntries = fs.readdirSync(this.tsGenerateDir, { withFileTypes: true });
            let genCount = 0;
            
            for (const entry of genEntries) {
                if (!entry.isDirectory() || entry.name.startsWith('.')) continue;
                // Skip non-package directories
                if (entry.name === 'node_modules') continue;
                
                const modulePath = path.join(this.tsGenerateDir, entry.name);
                const packageJsonPath = path.join(modulePath, 'package.json');
                
                if (!fs.existsSync(packageJsonPath)) {
                    throw new Error(
                        `[FAIL] Invalid TS module in tsGenerateDir!\n` +
                        `  Module: ${entry.name}\n` +
                        `  Path: ${modulePath}\n` +
                        `  Reason: No package.json found.\n` +
                        `  Generated TS modules must be "complete" with package.json.`
                    );
                }
                genCount++;
            }
            
            if (genCount > 0) {
                console.log(`    [OK] ts module (generated): ${genCount} modules validated`);
            }
        }
    }

    /**
     * Find .csproj files in a directory (non-recursive).
     */
    findCsprojFiles(dir) {
        const results = [];
        if (!fs.existsSync(dir)) return results;
        
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        for (const entry of entries) {
            if (entry.isFile() && entry.name.endsWith('.csproj')) {
                results.push(path.join(dir, entry.name));
            }
        }
        return results;
    }

    /**
     * Validate UPM packages (upm only, single SSOT).
     * All packages must be "complete UPM packages" with:
     * - package.json at root
     * - package.json.name matches folder name
     * - Required asmdef files for Runtime/Editor
     * SSOT: skills/devian/03-ssot/SKILL.md
     */
    async validateUpmPackages() {
        console.log('  [Validate] UPM packages...');
        
        // Validate upm (single SSOT)
        if (this.upmSourceDir && fs.existsSync(this.upmSourceDir)) {
            const count = await this.validateUpmDir(this.upmSourceDir, 'upm');
            if (count > 0) {
                console.log(`    [OK] upm: ${count} packages validated`);
            }
        }
    }

    /**
     * Validate all UPM packages in a directory.
     * Returns the count of validated packages.
     */
    async validateUpmDir(dir, dirLabel) {
        const entries = fs.readdirSync(dir, { withFileTypes: true });
        let count = 0;
        
        for (const entry of entries) {
            if (!entry.isDirectory() || entry.name.startsWith('.')) continue;
            
            const pkgPath = path.join(dir, entry.name);
            const packageJsonPath = path.join(pkgPath, 'package.json');
            
            // Must have package.json
            if (!fs.existsSync(packageJsonPath)) {
                throw new Error(
                    `[FAIL] Invalid UPM package in ${dirLabel}!\n` +
                    `  Package: ${entry.name}\n` +
                    `  Path: ${pkgPath}\n` +
                    `  Reason: No package.json found at root.\n` +
                    `  ${dirLabel} packages must be "complete UPM packages".`
                );
            }
            
            // Validate package.json
            let packageJson;
            try {
                packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
            } catch (e) {
                throw new Error(
                    `[FAIL] Invalid package.json in ${dirLabel}!\n` +
                    `  Package: ${entry.name}\n` +
                    `  Path: ${packageJsonPath}\n` +
                    `  Reason: ${e.message}`
                );
            }
            
            // package.json.name must exist
            if (!packageJson.name || typeof packageJson.name !== 'string') {
                throw new Error(
                    `[FAIL] Invalid package.json in ${dirLabel}!\n` +
                    `  Package: ${entry.name}\n` +
                    `  Path: ${packageJsonPath}\n` +
                    `  Reason: Missing or invalid "name" field.`
                );
            }
            
            // package.json.name should match folder name
            if (packageJson.name !== entry.name) {
                throw new Error(
                    `[FAIL] Package name mismatch in ${dirLabel}!\n` +
                    `  Folder: ${entry.name}\n` +
                    `  package.json.name: ${packageJson.name}\n` +
                    `  Path: ${pkgPath}\n` +
                    `  These must match for Unity Package Manager.`
                );
            }
            
            count++;
        }
        
        return count;
    }

    checkForbiddenNamespaces() {
        // New policy: namespace Devian.* is forbidden except:
        // - namespace Devian (single)
        // - namespace Devian.Domain.*
        // - namespace Devian.Protocol.*
        
        const targetDirs = [
            path.join(this.rootDir, 'framework-cs/module/Devian'),
            path.join(this.rootDir, 'framework-cs/upm'),
            path.join(this.rootDir, 'framework-cs/apps/UnityExample/Packages'),
        ];

        const violations = [];

        for (const dir of targetDirs) {
            if (!fs.existsSync(dir)) continue;
            const found = this.scanForForbiddenNamespaces(dir);
            violations.push(...found);
        }

        if (violations.length > 0) {
            console.error('\n[FAIL] Forbidden namespace detected!');
            console.error('Policy: Only namespace Devian, Devian.Domain.*, Devian.Protocol.* are allowed.');
            console.error('Violations:');
            for (const v of violations) {
                console.error(`  - ${v.file}:${v.line}: ${v.content.trim()}`);
            }
            throw new Error(
                `Forbidden namespace detected. Only namespace Devian, Devian.Domain.*, Devian.Protocol.* are allowed.`
            );
        }

        console.log('  [OK] No forbidden namespaces found.');
    }

    scanForForbiddenNamespaces(dir) {
        const results = [];
        const entries = fs.readdirSync(dir, { withFileTypes: true });

        // Regex: matches "namespace Devian.X" where X is not "Domain" or "Protocol"
        // Allows: "namespace Devian", "namespace Devian.Domain.*", "namespace Devian.Protocol.*"
        // Forbids: namespace Devian + .<Something> where Something is NOT Domain or Protocol
        const forbiddenNamespaceRegex = /^\s*namespace\s+Devian\.(?!Domain\b|Protocol\b)(\w+)/;

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (entry.isDirectory()) {
                results.push(...this.scanForForbiddenNamespaces(fullPath));
            } else if (entry.isFile() && entry.name.endsWith('.cs')) {
                const content = fs.readFileSync(fullPath, 'utf-8');
                const lines = content.split('\n');

                for (let i = 0; i < lines.length; i++) {
                    if (forbiddenNamespaceRegex.test(lines[i])) {
                        results.push({
                            file: fullPath,
                            line: i + 1,
                            content: lines[i],
                        });
                    }
                }
            }
        }

        return results;
    }

    /**
     * Guard: com.devian.foundation must NOT contain Editor/Generated.
     * Editor/Generated for TableID inspection belongs to com.devian.domain.* packages.
     * If this folder exists in foundation, it indicates a routing/mapping error.
     * SSOT: skills/devian/03-ssot/SKILL.md
     */
    checkFoundationEditorGenerated() {
        const forbiddenPaths = [
            path.join(this.rootDir, 'framework-cs/upm/com.devian.foundation/Editor/Generated'),
            path.join(this.rootDir, 'framework-cs/apps/UnityExample/Packages/com.devian.foundation/Editor/Generated'),
        ];

        const violations = [];

        for (const forbiddenPath of forbiddenPaths) {
            if (fs.existsSync(forbiddenPath)) {
                violations.push(forbiddenPath);
            }
        }

        if (violations.length > 0) {
            console.error('\n[FAIL] com.devian.foundation must not contain Editor/Generated!');
            console.error('This folder belongs to com.devian.domain.* packages, not foundation.');
            console.error('Violations:');
            for (const v of violations) {
                console.error(`  - ${v}`);
            }
            console.error('\nFix: Remove generation target mapping or sheet output route that produces it.');
            console.error('     Check samplePackages config and domain/table routing in input json.');
            throw new Error(
                '[FAIL] com.devian.foundation must not contain Editor/Generated. ' +
                'Remove generation target mapping or sheet output route that produces it.'
            );
        }

        console.log('  [OK] com.devian.foundation has no forbidden Editor/Generated.');
    }

    /**
     * Guard: Detect SimpleSingleton.Instance access from InitializeOnLoad or static constructors.
     * This pattern causes Unity Editor ScriptableSingleton conflicts.
     * SSOT: skills/devian-unity/30-unity-components/01-singleton/SKILL.md (8.5)
     */
    checkSingletonEarlyInit() {
        const targetDirs = [
            path.join(this.rootDir, 'framework-cs/upm'),
            path.join(this.rootDir, 'framework-cs/module'),
        ];

        const violations = [];

        for (const dir of targetDirs) {
            if (!fs.existsSync(dir)) continue;
            const found = this.scanForSingletonEarlyInit(dir);
            violations.push(...found);
        }

        if (violations.length > 0) {
            console.error('\n[FAIL] SimpleSingleton early init pattern detected!');
            console.error('Policy: Do not access SimpleSingleton.Instance from:');
            console.error('  - [InitializeOnLoad] / [InitializeOnLoadMethod] attributed code');
            console.error('  - Static constructors (static ClassName())');
            console.error('Reference: skills/devian-unity/30-unity-components/01-singleton/SKILL.md (8.5)');
            console.error('\nViolations:');
            for (const v of violations) {
                console.error(`  - ${v.file}:${v.line}: ${v.reason}`);
                console.error(`    > ${v.content.trim()}`);
            }
            throw new Error(
                '[FAIL] SimpleSingleton early init pattern detected. ' +
                'Do not access SimpleSingleton.Instance from InitializeOnLoad or static constructors. ' +
                'See: skills/devian-unity/30-unity-components/01-singleton/SKILL.md (8.5)'
            );
        }

        console.log('  [OK] No SimpleSingleton early init violations found.');
    }

    /**
     * Scan directory for SimpleSingleton early init violations.
     * Returns array of { file, line, content, reason }.
     */
    scanForSingletonEarlyInit(dir) {
        const results = [];
        const entries = fs.readdirSync(dir, { withFileTypes: true });

        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);

            if (entry.isDirectory()) {
                results.push(...this.scanForSingletonEarlyInit(fullPath));
            } else if (entry.isFile() && entry.name.endsWith('.cs')) {
                // Skip SimpleSingleton.cs itself (it's the guard implementation)
                if (entry.name === 'SimpleSingleton.cs') continue;

                const content = fs.readFileSync(fullPath, 'utf-8');
                
                // Skip files that don't use SimpleSingleton at all
                if (!content.includes('SimpleSingleton')) continue;
                
                // Check if file accesses SimpleSingleton.Instance or SimpleSingleton<...>.Instance
                const hasInstanceAccess = /SimpleSingleton[<\s].*?\.Instance\b/.test(content) ||
                                          /SimpleSingleton\s*\.\s*Instance\b/.test(content);
                if (!hasInstanceAccess) continue;

                const lines = content.split('\n');

                // Check 1: InitializeOnLoad or InitializeOnLoadMethod with SimpleSingleton.Instance
                const hasInitializeOnLoad = /\[\s*InitializeOnLoad(Method)?\s*\]/.test(content);
                if (hasInitializeOnLoad) {
                    // Find the line with Instance access and report
                    for (let i = 0; i < lines.length; i++) {
                        if (/SimpleSingleton.*\.Instance\b/.test(lines[i])) {
                            results.push({
                                file: fullPath,
                                line: i + 1,
                                content: lines[i],
                                reason: 'SimpleSingleton.Instance in file with [InitializeOnLoad]',
                            });
                        }
                    }
                }

                // Check 2: Static constructor (static TypeName()) with SimpleSingleton.Instance
                // Pattern: static ClassName() { ... }
                const staticCtorPattern = /static\s+(\w+)\s*\(\s*\)\s*\{/g;
                let match;
                while ((match = staticCtorPattern.exec(content)) !== null) {
                    const ctorName = match[1];
                    // Find the opening brace position
                    const ctorStart = match.index;
                    
                    // Simple heuristic: find matching closing brace
                    // We scan for SimpleSingleton.Instance between { and }
                    let braceDepth = 0;
                    let inCtor = false;
                    let ctorEnd = content.length;
                    
                    for (let i = ctorStart; i < content.length; i++) {
                        if (content[i] === '{') {
                            braceDepth++;
                            inCtor = true;
                        } else if (content[i] === '}') {
                            braceDepth--;
                            if (inCtor && braceDepth === 0) {
                                ctorEnd = i;
                                break;
                            }
                        }
                    }
                    
                    const ctorBody = content.substring(ctorStart, ctorEnd);
                    if (/SimpleSingleton.*\.Instance\b/.test(ctorBody)) {
                        // Find the line number of the Instance access
                        const ctorLines = ctorBody.split('\n');
                        const startLine = content.substring(0, ctorStart).split('\n').length;
                        
                        for (let i = 0; i < ctorLines.length; i++) {
                            if (/SimpleSingleton.*\.Instance\b/.test(ctorLines[i])) {
                                results.push({
                                    file: fullPath,
                                    line: startLine + i,
                                    content: ctorLines[i],
                                    reason: `SimpleSingleton.Instance in static constructor '${ctorName}'`,
                                });
                            }
                        }
                    }
                }
            }
        }

        return results;
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

async function main() {
    const args = process.argv.slice(2);

    if (args.length < 1) {
        console.log('Usage: node build.js <input.json>');
        console.log('Example: node build.js ../../../input/input_common.json');
        process.exit(1);
    }

    const buildJsonPath = args[0];

    try {
        const runner = new DevianToolBuilder(buildJsonPath);
        await runner.run();
    } catch (error) {
        console.error('Build failed:', error.message);
        console.error(error.stack);
        process.exit(1);
    }
}

main();

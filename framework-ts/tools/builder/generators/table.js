// <auto-generated>
// Devian Build System v10 - Table Generator
// SSOT: skills/devian/03-ssot/SKILL.md
// Namespace: Devian.Tables, Container: Table.TB_{TableName}
// </auto-generated>

import XLSX from 'xlsx';
import { createHash } from 'crypto';
import { gzipSync } from 'zlib';

// ============================================================================
// Class Parser Registry (for class: type fields)
// ============================================================================

const classParsers = new Map();

/**
 * Register a class parser
 * @param {string} typeName - Full type name (e.g., 'Devian.CInt')
 * @param {Function} parser - Parser function (cellText, ctx) => object|null
 */
function registerClassParser(typeName, parser) {
    classParsers.set(typeName, parser);
}

// ============================================================================
// Complex Type Parsers (CInt, CFloat, CString)
// Deterministic conversion: same input always produces same output
// ============================================================================

// ComplexUtil EncryptTable (copied from C# ComplexUtil.cs - DO NOT MODIFY)
const ENCRYPT_TABLE = new Uint8Array([
    0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
    0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
    0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
    0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
    0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
    0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
    0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
    0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
    0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
    0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
    0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
    0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
    0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
    0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
    0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
    0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16
]);

/**
 * Generate deterministic mask (save2) using SHA-256
 * Seed: "{sheetKey}|{rowPk}|{columnName}|{plainText}|{typeName}"
 * @returns {number} - int32 mask value
 */
function generateDeterministicMask(ctx, plainText) {
    const seed = `${ctx.sheetKey}|${ctx.rowPk}|${ctx.columnName}|${plainText}|${ctx.typeName}`;
    const hash = createHash('sha256').update(seed, 'utf8').digest();
    // Read first 4 bytes as little-endian int32
    let mask = hash.readInt32LE(0);
    // Avoid zero mask (deterministic fallback)
    if (mask === 0) {
        mask = 0x6d2b79f5;
    }
    return mask;
}

/**
 * Int32 to bytes (little-endian)
 */
function int32ToBytes(value) {
    const buf = Buffer.alloc(4);
    buf.writeInt32LE(value, 0);
    return [buf[0], buf[1], buf[2], buf[3]];
}

/**
 * Bytes to int32 (little-endian)
 */
function bytesToInt32(b0, b1, b2, b3) {
    const buf = Buffer.from([b0, b1, b2, b3]);
    return buf.readInt32LE(0);
}

/**
 * Float32 to int32 bits (little-endian)
 */
function floatToInt32Bits(value) {
    const buf = Buffer.alloc(4);
    buf.writeFloatLE(value, 0);
    return buf.readInt32LE(0);
}

/**
 * Encrypt bytes using ComplexUtil table
 */
function encryptBytes(data) {
    const result = new Uint8Array(data.length);
    for (let i = 0; i < data.length; i++) {
        result[i] = ENCRYPT_TABLE[data[i]];
    }
    return result;
}

/**
 * CInt parser: plain integer -> { save1, save2 }
 */
function parseCIntCell(cellText, ctx) {
    const text = String(cellText).trim();
    
    // Empty -> null
    if (text === '') return null;
    
    // Raw JSON input
    if (text.startsWith('{')) {
        try {
            return JSON.parse(text);
        } catch (e) {
            return null;
        }
    }
    
    // Plain integer input
    const value = parseInt(text, 10);
    if (isNaN(value)) return null;
    
    // Generate deterministic mask
    const save2 = generateDeterministicMask(ctx, text);
    
    // Get bytes (little-endian)
    const [v0, v1, v2, v3] = int32ToBytes(value);
    const [m0, m1, m2, m3] = int32ToBytes(save2);
    
    // Permutation: s1_0=v0^m0, s1_1=v2^m1, s1_2=v1^m2, s1_3=v3^m3
    const s1_0 = v0 ^ m0;
    const s1_1 = v2 ^ m1;
    const s1_2 = v1 ^ m2;
    const s1_3 = v3 ^ m3;
    
    const save1 = bytesToInt32(s1_0, s1_1, s1_2, s1_3);
    
    return { save1, save2 };
}

/**
 * CFloat parser: plain float -> { save1, save2 }
 */
function parseCFloatCell(cellText, ctx) {
    const text = String(cellText).trim();
    
    // Empty -> null
    if (text === '') return null;
    
    // Raw JSON input
    if (text.startsWith('{')) {
        try {
            return JSON.parse(text);
        } catch (e) {
            return null;
        }
    }
    
    // Plain float input
    const value = parseFloat(text);
    if (isNaN(value)) return null;
    
    // Convert float to int32 bits
    const bits = floatToInt32Bits(value);
    
    // Generate deterministic mask
    const save2 = generateDeterministicMask(ctx, text);
    
    // Get bytes (little-endian)
    const [v0, v1, v2, v3] = int32ToBytes(bits);
    const [m0, m1, m2, m3] = int32ToBytes(save2);
    
    // Permutation: same as CInt
    const s1_0 = v0 ^ m0;
    const s1_1 = v2 ^ m1;
    const s1_2 = v1 ^ m2;
    const s1_3 = v3 ^ m3;
    
    const save1 = bytesToInt32(s1_0, s1_1, s1_2, s1_3);
    
    return { save1, save2 };
}

/**
 * CString parser: plain string -> { data }
 */
function parseCStringCell(cellText, ctx) {
    const text = String(cellText);
    
    // Raw JSON input
    if (text.trim().startsWith('{')) {
        try {
            return JSON.parse(text);
        } catch (e) {
            // Fall through to plain encoding
        }
    }
    
    // Plain string input: encrypt + base64
    const plainBytes = Buffer.from(text, 'utf8');
    const encrypted = encryptBytes(plainBytes);
    const data = Buffer.from(encrypted).toString('base64');
    
    return { data };
}

// Register Complex parsers
registerClassParser('Devian.CInt', parseCIntCell);
registerClassParser('Devian.CFloat', parseCFloatCell);
registerClassParser('Devian.CString', parseCStringCell);

// ============================================================================
// Variant Parser (Simple format: {i} | {f} | {s})
// SSOT: skills/devian-common/11-feature-variant/SKILL.md
// ============================================================================

/**
 * Parse Variant cell: "i:123", "f:3.5", "s:Hello"
 * Returns simple format: { i: number } | { f: number } | { s: string }
 * Key is exactly one of i, f, s. No k key, no Complex shapes.
 */
function parseVariantCell(cellText, ctx) {
    const text = String(cellText).trim();
    
    // Empty -> null
    if (text === '') return null;
    
    // Raw JSON input (already in simple format)
    if (text.startsWith('{')) {
        try {
            const parsed = JSON.parse(text);
            // Validate: exactly one key (i, f, or s)
            const keys = Object.keys(parsed);
            if (keys.length !== 1) {
                throw new Error(`[Variant] JSON must have exactly one key (i, f, or s), got: ${keys.join(', ')}`);
            }
            const key = keys[0];
            if (key !== 'i' && key !== 'f' && key !== 's') {
                throw new Error(`[Variant] Invalid key '${key}'. Expected 'i', 'f', or 's'.`);
            }
            // Type validation
            const value = parsed[key];
            if (key === 'i') {
                if (typeof value !== 'number' || !Number.isInteger(value)) {
                    throw new Error(`[Variant] 'i' value must be integer, got: ${typeof value}`);
                }
            } else if (key === 'f') {
                if (typeof value !== 'number') {
                    throw new Error(`[Variant] 'f' value must be number, got: ${typeof value}`);
                }
            } else if (key === 's') {
                if (typeof value !== 'string') {
                    throw new Error(`[Variant] 's' value must be string, got: ${typeof value}`);
                }
            }
            return parsed;
        } catch (e) {
            if (e.message.startsWith('[Variant]')) throw e;
            throw new Error(`[Variant] Invalid JSON in cell: '${text}'`);
        }
    }
    
    // Parse prefix: i:, f:, s:
    if (text.length < 2 || text[1] !== ':') {
        throw new Error(`[Variant] Invalid format: '${text}'. Expected 'i:', 'f:', or 's:' prefix.`);
    }
    
    const prefix = text[0];
    const body = text.substring(2);
    
    switch (prefix) {
        case 'i': {
            const value = parseInt(body, 10);
            if (isNaN(value)) {
                throw new Error(`[Variant] Invalid integer value in '${text}'`);
            }
            // Check for decimal (not allowed for i:)
            if (body.includes('.')) {
                throw new Error(`[Variant] Integer value cannot have decimal: '${text}'`);
            }
            return { i: value };
        }
        case 'f': {
            const value = parseFloat(body);
            if (isNaN(value)) {
                throw new Error(`[Variant] Invalid float value in '${text}'`);
            }
            return { f: value };
        }
        case 's': {
            // String: store as-is (no encryption)
            return { s: body };
        }
        default:
            throw new Error(`[Variant] Invalid prefix '${prefix}' in '${text}'. Expected 'i', 'f', or 's'.`);
    }
}

/**
 * Internal: Parse integer value with deterministic mask
 */
function parseCIntCellDeterministic(value, plainText, ctx) {
    const save2 = generateDeterministicMask(ctx, plainText);
    const [v0, v1, v2, v3] = int32ToBytes(value);
    const [m0, m1, m2, m3] = int32ToBytes(save2);
    
    const s1_0 = v0 ^ m0;
    const s1_1 = v2 ^ m1;
    const s1_2 = v1 ^ m2;
    const s1_3 = v3 ^ m3;
    
    const save1 = bytesToInt32(s1_0, s1_1, s1_2, s1_3);
    return { save1, save2 };
}

/**
 * Internal: Parse float value with deterministic mask
 */
function parseCFloatCellDeterministic(value, plainText, ctx) {
    const bits = floatToInt32Bits(value);
    const save2 = generateDeterministicMask(ctx, plainText);
    const [v0, v1, v2, v3] = int32ToBytes(bits);
    const [m0, m1, m2, m3] = int32ToBytes(save2);
    
    const s1_0 = v0 ^ m0;
    const s1_1 = v2 ^ m1;
    const s1_2 = v1 ^ m2;
    const s1_3 = v3 ^ m3;
    
    const save1 = bytesToInt32(s1_0, s1_1, s1_2, s1_3);
    return { save1, save2 };
}

/**
 * Parse XLSX file and extract table definitions
 * @param {string} filePath - Path to XLSX file
 * @returns {Array} Array of table definitions
 */
export function parseXlsx(filePath) {
    const workbook = XLSX.readFile(filePath);
    const tables = [];

    for (const sheetName of workbook.SheetNames) {
        const sheet = workbook.Sheets[sheetName];
        const table = parseSheet(sheet, sheetName);
        if (table) {
            tables.push(table);
        }
    }

    return tables;
}

/**
 * Parse a single sheet into table definition
 * @param {Object} sheet - XLSX sheet object
 * @param {string} sheetName - Sheet name
 * @returns {Object|null} Table definition or null if invalid
 */
function parseSheet(sheet, sheetName) {
    const range = XLSX.utils.decode_range(sheet['!ref'] || 'A1');
    const fields = [];
    let keyField = null;

    // Parse header (4 rows fixed per SSOT)
    // Row 1: FieldName, Row 2: Type, Row 3: Options, Row 4: Comment
    for (let col = range.s.c; col <= range.e.c; col++) {
        const fieldName = getCellValue(sheet, 0, col);
        let fieldType = getCellValue(sheet, 1, col);
        if (!fieldType) fieldType = 'string';

        // Header Stop Rule: Empty FieldName → stop scanning
        if (!fieldName) break

        const options = parseOptions(getCellValue(sheet, 2, col), { sheetName, fieldName });
        const comment = getCellValue(sheet, 3, col);

        const field = {
            name: fieldName,
            type: fieldType,
            optional: options.optional === 'true',
            isKey: options.pk === 'true',
            gen: options.gen || null,
            comment: comment || '',
        };

        fields.push(field);

        if (field.isKey) {
            if (keyField) {
                throw new Error(`Multiple key fields not allowed: ${sheetName}`);
            }
            keyField = field;
        }
    }

    if (fields.length === 0) return null;

    // Validate: gen field must be pk (gen column = PK column)
    const genFields = fields.filter(f => f.gen);
    if (genFields.length > 0) {
        if (genFields.length > 1) {
            throw new Error(`[gen:] Table '${sheetName}': only one gen column allowed per table, found ${genFields.length}`);
        }
        const genField = genFields[0];
        if (!genField.isKey) {
            throw new Error(`[gen:] Table '${sheetName}': gen field must be pk (gen column is the PK)`);
        }
        if (!keyField) {
            throw new Error(`[gen:] Table '${sheetName}': gen field must be pk (gen column is the PK)`);
        }
        if (genField.name !== keyField.name) {
            throw new Error(`[gen:] Table '${sheetName}': gen field must be pk (gen column is the PK)`);
        }
    }

    // Parse data rows (Row 5+, 0-indexed: row 4+)
    const rows = [];
    for (let row = 4; row <= range.e.r; row++) {
        const rowData = {};
        let isEmpty = true;
        let keyValue = null;

        // First pass: get key value for ctx (pk-only policy)
        if (keyField) {
            const keyFieldIndex = fields.findIndex(f => f.isKey);
            if (keyFieldIndex >= 0) {
                const rawKeyValue = getCellValue(sheet, row, keyFieldIndex);
                keyValue = rawKeyValue !== null && rawKeyValue !== undefined ? String(rawKeyValue) : null;
            }
        }

        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            const value = getCellValue(sheet, row, i);

            if (value !== null && value !== undefined && value !== '') {
                isEmpty = false;
            }

            // Build context for class parsers
            const ctx = {
                sheetKey: sheetName,
                rowPk: keyValue || String(row - 3), // fallback to row index if no pk
                rowIndex: row - 3,
                columnName: field.name,
                typeName: field.type.startsWith('class:') ? field.type.slice(6) : field.type
            };

            // Parse value based on type
            rowData[field.name] = parseValue(value, field.type, ctx);

            if (field.isKey) {
                keyValue = rowData[field.name];
            }
        }

        // Data Stop Rule: Empty key → stop loading
        if (keyField && (keyValue === null || keyValue === undefined || keyValue === '')) {
            break;
        }

        // Empty row: skip (do not terminate)
        if (isEmpty) {
            continue;
        }

        rows.push(rowData);
    }

    return {
        name: sheetName,
        fields: fields,
        keyField: keyField,
        rows: rows,
    };
}

/**
 * Get cell value from sheet
 */
function getCellValue(sheet, row, col) {
    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
    const cell = sheet[cellAddress];
    return cell ? cell.v : null;
}

/**
 * Parse options string (comma-separated key:value pairs or pk flag)
 *
 * SSOT: skills/devian/30-table-authoring-rules/SKILL.md
 * 
 * Supported formats:
 * - pk (flag) - PrimaryKey, treated as pk:true
 * - key:value (e.g., "optional:true")
 * - prefix:value (e.g., "gen:ComplexPolicyType")
 * 
 * NOTE: 'key:true' and 'key' options are NOT supported and will throw an error.
 * 
 * @param {string} optionStr - Options string from cell
 * @param {object} context - Optional context for error messages { sheetName, fieldName }
 */
function parseOptions(optionStr, context = {}) {
    const options = {};
    if (!optionStr) return options;

    const { sheetName, fieldName } = context;
    const contextStr = sheetName ? ` (table: '${sheetName}'${fieldName ? `, field: '${fieldName}'` : ''})` : '';

    // Split by comma, allow extra spaces
    const parts = String(optionStr)
        .split(',')
        .map(p => p.trim())
        .filter(p => p.length > 0);

    for (const part of parts) {
        const idx = part.indexOf(':');
        if (idx <= 0) {
            // No colon or colon at start - flag format
            if (part.length > 0) {
                if (part === 'pk') {
                    // pk flag is supported (= pk:true)
                    options.pk = 'true';
                } else if (part === 'key') {
                    // key flag is NOT supported
                    throw new Error(`Invalid option flag 'key'. Use 'pk'.${contextStr}`);
                } else {
                    // Other flags are not supported
                    throw new Error(`Invalid option flag '${part}'.${contextStr}`);
                }
            }
        } else {
            // Has colon - key:value pair
            const key = part.slice(0, idx).trim();
            const value = part.slice(idx + 1).trim();
            
            // Check for unsupported 'key' option
            if (key === 'key') {
                throw new Error(`Option 'key' is not supported. Use 'pk'.${contextStr}`);
            }
            
            if (key && value !== undefined) {
                options[key] = value;
            }
        }
    }
    return options;
}

/**
 * Parse value based on type
 * @param {*} value - Cell value
 * @param {string} type - Field type
 * @param {object} ctx - Context for class parsers
 */
function parseValue(value, type, ctx = null) {
    if (value === null || value === undefined || value === '') {
        return getDefaultForType(type);
    }

    const baseType = type.replace('[]', '');
    const isArray = type.endsWith('[]');

    if (isArray) {
        // Parse array value (DFF format: "a,b,c" or "{a,b,c}" or "[a,b,c]")
        let arrayStr = String(value);
        arrayStr = arrayStr.replace(/^[\[{]/, '').replace(/[\]}]$/, '');
        const items = arrayStr.split(',').map(s => s.trim()).filter(s => s !== '');
        return items.map(item => parseSingleValue(item, baseType, ctx));
    }

    return parseSingleValue(value, baseType, ctx);
}

function parseSingleValue(value, type, ctx = null) {
    if (value === null || value === undefined) return null;

    // Normalize type for comparison (case-insensitive for Variant)
    const typeLower = type.toLowerCase();

    switch (type) {
        case 'byte':
        case 'ubyte':
        case 'short':
        case 'ushort':
        case 'int':
        case 'uint':
            return parseInt(value, 10);
        case 'long':
        case 'ulong':
            return String(value); // 64-bit as string for JSON
        case 'float':
        case 'double':
            return parseFloat(value);
        case 'bool':
            return value === true || value === 'true' || value === '1';
        case 'string':
            return String(value);
        default:
            // Variant type (case-insensitive: 'variant' or 'Variant')
            if (typeLower === 'variant') {
                if (ctx) {
                    return parseVariantCell(value, ctx);
                }
                // No ctx: try to parse as raw JSON
                if (typeof value === 'string' && value.trim().startsWith('{')) {
                    try {
                        return JSON.parse(value);
                    } catch (e) {
                        throw new Error(`[Variant] Invalid JSON: '${value}'`);
                    }
                }
                throw new Error(`[Variant] Cannot parse without context: '${value}'`);
            }
            // enum:Name or class:Name
            if (type.startsWith('enum:')) {
                return String(value); // enum stored as name string
            }
            if (type.startsWith('class:')) {
                const className = type.slice(6); // Remove 'class:' prefix
                
                // Check for registered class parser
                const parser = classParsers.get(className);
                if (parser && ctx) {
                    const result = parser(value, ctx);
                    if (result !== null) {
                        return result;
                    }
                }
                
                // Fallback: parse as JSON object
                if (typeof value === 'string' && value.trim()) {
                    try {
                        return JSON.parse(value);
                    } catch (e) {
                        // If parsing fails, return null
                        return null;
                    }
                }
                return null;
            }
            return value;
    }
}

function getDefaultForType(type) {
    if (type.endsWith('[]')) return [];
    // Normalize for variant comparison
    const typeLower = type.toLowerCase();
    switch (type) {
        case 'byte':
        case 'ubyte':
        case 'short':
        case 'ushort':
        case 'int':
        case 'uint':
        case 'float':
        case 'double':
            return 0;
        case 'long':
        case 'ulong':
            return '0';
        case 'bool':
            return false;
        case 'string':
            return '';
        default:
            // Variant type defaults to null
            if (typeLower === 'variant') {
                return null;
            }
            return null;
    }
}

// ============================================================================
// C# Table Generator
// ============================================================================

/**
 * Generate C# table container code
 * @param {Object} table - Table definition from parseXlsx
 * @param {string} domainName - Domain name
 * @returns {string} Generated C# code
 */
export function generateCSharpTable(table, domainName) {
    const lines = [];
    const tableName = table.name;
    const rowClassName = tableName;

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push('// </auto-generated>');
    lines.push('');
    lines.push('#nullable enable');
    lines.push('');
    lines.push('using System;');
    lines.push('using System.Collections.Generic;');
    lines.push('using System.IO;');
    lines.push('using Newtonsoft.Json;');
    lines.push('');

    // Namespace: Devian.Tables (SSOT A안)
    lines.push('namespace Devian.Tables');
    lines.push('{');

    // Row class
    generateRowClass(lines, table, rowClassName);
    lines.push('');

    // Container: public static partial class Table
    lines.push('    public static partial class Table');
    lines.push('    {');

    // Table container: TB_{TableName}
    generateTableContainer(lines, table, tableName, rowClassName);

    lines.push('    }'); // end Table
    lines.push('}'); // end namespace

    return lines.join('\n');
}

/**
 * Generate C# table entity body only (no header, no namespace wrapper)
 * @param {Object} table - Table definition from parseXlsx
 * @returns {string} Generated C# entity body code
 */
export function generateCSharpTableEntityBody(table) {
    const lines = [];
    const rowClassName = table.name;
    generateRowClass(lines, table, rowClassName);
    return lines.join('\n');
}

/**
 * Generate C# table container body only (inside partial class Table)
 * @param {Object} table - Table definition from parseXlsx
 * @param {Array} enumSpecs - Enum specs from collectEnumGenSpecs (optional)
 * @returns {string} Generated C# container body code
 */
export function generateCSharpTableContainerBody(table, enumSpecs = []) {
    const lines = [];
    const tableName = table.name;
    const rowClassName = table.name;
    generateTableContainer(lines, table, tableName, rowClassName, enumSpecs);
    return lines.join('\n');
}

function generateRowClass(lines, table, rowClassName) {
    const keyField = table.keyField;

    lines.push(`    /// <summary>${table.name} row</summary>`);

    if (keyField) {
        const keyType = mapTableTypeToCSharp(keyField.type, false);
        lines.push(`    public sealed class ${rowClassName} : IEntityKey<${keyType}>`);
    } else {
        lines.push(`    public sealed class ${rowClassName} : IEntity`);
    }

    lines.push('    {');

    for (const field of table.fields) {
        const csType = mapTableTypeToCSharp(field.type, field.optional);
        const propName = capitalize(field.name);
        const defaultValue = getTableDefaultValue(field.type);
        lines.push(`        public ${csType} ${propName} { get; set; }${defaultValue}`);
    }

    // GetKey method (IEntityKey<T> implementation) - only if key exists
    if (keyField) {
        const keyType = mapTableTypeToCSharp(keyField.type, false);
        lines.push('');
        lines.push(`        public ${keyType} GetKey() => ${capitalize(keyField.name)};`);
    }

    lines.push('    }');
}

function generateTableContainer(lines, table, tableName, rowClassName, enumSpecs = []) {
    const keyType = table.keyField ? mapTableTypeToCSharp(table.keyField.type, false) : 'int';
    const keyProp = table.keyField ? capitalize(table.keyField.name) : 'Id';

    // Get enum specs for this table
    const tableEnumSpecs = enumSpecs.filter(spec => spec.tableName === tableName);

    lines.push(`    /// <summary>TB_${tableName} container</summary>`);
    lines.push(`    public static class TB_${tableName}`);
    lines.push('    {');

    // Storage
    if (table.keyField) {
        lines.push(`        private static readonly Dictionary<${keyType}, ${rowClassName}> _dict = new();`);
    }
    lines.push(`        private static readonly List<${rowClassName}> _list = new();`);
    lines.push('');

    // Count property
    lines.push('        public static int Count => _list.Count;');
    lines.push('');

    // Clear
    lines.push('        public static void Clear()');
    lines.push('        {');
    if (table.keyField) {
        lines.push('            _dict.Clear();');
    }
    lines.push('            _list.Clear();');
    lines.push('        }');
    lines.push('');

    // GetAll
    lines.push(`        public static IReadOnlyList<${rowClassName}> GetAll() => _list;`);
    lines.push('');

    // Get/TryGet (if key exists)
    if (table.keyField) {
        lines.push(`        public static ${rowClassName}? Get(${keyType} key)`);
        lines.push('        {');
        lines.push('            return _dict.TryGetValue(key, out var row) ? row : null;');
        lines.push('        }');
        lines.push('');
        lines.push(`        public static bool TryGet(${keyType} key, out ${rowClassName}? row)`);
        lines.push('        {');
        lines.push('            return _dict.TryGetValue(key, out row);');
        lines.push('        }');
        lines.push('');

        // Find/TryFind (int key version) - for gen: tables
        if (tableEnumSpecs.length > 0) {
            lines.push(`        public static ${rowClassName} Find(${keyType} key)`);
            lines.push('        {');
            lines.push('            if (_dict.TryGetValue(key, out var row)) return row;');
            lines.push(`            throw new KeyNotFoundException($"TB_${tableName}: key {key} not found");`);
            lines.push('        }');
            lines.push('');
            lines.push(`        public static bool TryFind(${keyType} key, out ${rowClassName}? row)`);
            lines.push('        {');
            lines.push('            return _dict.TryGetValue(key, out row);');
            lines.push('        }');
            lines.push('');

            // EnumKey overloads - only if keyType is NOT already the enum type
            for (const enumSpec of tableEnumSpecs) {
                // Skip if keyType is already enum:EnumName (would create duplicate method)
                const keyTypeEnum = table.keyField.type;
                if (keyTypeEnum === `enum:${enumSpec.enumName}`) {
                    continue;  // keyType is already the enum, no overload needed
                }
                lines.push(`        public static ${rowClassName} Find(${enumSpec.enumName} key) => Find((${keyType})key);`);
                lines.push(`        public static bool TryFind(${enumSpec.enumName} key, out ${rowClassName}? row) => TryFind((${keyType})key, out row);`);
                lines.push('');
            }
        }
    }

    // LoadFromJson
    lines.push('        public static void LoadFromJson(string json)');
    lines.push('        {');
    lines.push('            Clear();');
    lines.push(`            var rows = JsonConvert.DeserializeObject<List<${rowClassName}>>(json);`);
    lines.push('            if (rows == null) return;');
    lines.push('            foreach (var row in rows)');
    lines.push('            {');
    lines.push('                if (row == null) continue;');
    lines.push('                _list.Add(row);');
    if (table.keyField) {
        lines.push(`                _dict[row.${keyProp}] = row;`);
    }
    lines.push('            }');
    lines.push('        }');
    lines.push('');

    // LoadFromNdjson
    lines.push('        public static void LoadFromNdjson(string ndjson)');
    lines.push('        {');
    lines.push('            Clear();');
    lines.push('            using var reader = new StringReader(ndjson);');
    lines.push('            string? line;');
    lines.push('            while ((line = reader.ReadLine()) != null)');
    lines.push('            {');
    lines.push('                if (string.IsNullOrWhiteSpace(line)) continue;');
    lines.push(`                var row = JsonConvert.DeserializeObject<${rowClassName}>(line);`);
    lines.push('                if (row == null) continue;');
    lines.push('                _list.Add(row);');
    if (table.keyField) {
        lines.push(`                _dict[row.${keyProp}] = row;`);
    }
    lines.push('            }');
    lines.push('        }');

    lines.push('    }');
}

function mapTableTypeToCSharp(type, optional) {
    const isArray = type.endsWith('[]');
    const baseType = isArray ? type.slice(0, -2) : type;

    const typeMap = {
        'byte': 'sbyte',
        'ubyte': 'byte',
        'short': 'short',
        'ushort': 'ushort',
        'int': 'int',
        'uint': 'uint',
        'long': 'long',
        'ulong': 'ulong',
        'float': 'float',
        'double': 'double',
        'string': 'string',
        'bool': 'bool',
    };

    let csType = typeMap[baseType];

    if (!csType) {
        // enum:Name or class:Name
        if (baseType.startsWith('enum:')) {
            csType = baseType.slice(5);
            if (csType.includes('.')) {
                const [ns, name] = csType.split('.');
                csType = `Devian.Domain.${ns}.${name}`;
            }
        } else if (baseType.startsWith('class:')) {
            csType = baseType.slice(6);
            if (csType.includes('.')) {
                const [ns, name] = csType.split('.');
                csType = `Devian.Domain.${ns}.${name}`;
            }
            // class types are nullable (reference types can be null in data)
            if (!isArray) {
                csType = `${csType}?`;
            }
        } else {
            csType = baseType;
        }
    }

    if (isArray) {
        return `List<${csType}>`;
    }

    if (optional && ['string'].includes(baseType)) {
        return `${csType}?`;
    }

    return csType;
}

function getTableDefaultValue(type) {
    if (type.endsWith('[]')) return ' = new();';
    if (type === 'string') return ' = string.Empty;';
    return '';
}

// ============================================================================
// TypeScript Table Generator
// ============================================================================

/**
 * Map table type to TypeScript type
 * @param {string} type - Table type (e.g., int, string, enum:Name)
 * @returns {string} TypeScript type
 */
function mapTableTypeToTypeScript(type) {
    const isArray = type.endsWith('[]');
    const baseType = isArray ? type.slice(0, -2) : type;

    const typeMap = {
        'byte': 'number',
        'ubyte': 'number',
        'short': 'number',
        'ushort': 'number',
        'int': 'number',
        'uint': 'number',
        'long': 'number',
        'ulong': 'number',
        'float': 'number',
        'double': 'number',
        'string': 'string',
        'bool': 'boolean',
    };

    let tsType = typeMap[baseType];
    let isClassType = false;

    if (!tsType) {
        // enum:Name or class:Name
        if (baseType.startsWith('enum:')) {
            tsType = baseType.slice(5);
            // Remove namespace prefix if exists (e.g., Common.UserType → UserType)
            if (tsType.includes('.')) {
                tsType = tsType.split('.').pop();
            }
        } else if (baseType.startsWith('class:')) {
            tsType = baseType.slice(6);
            if (tsType.includes('.')) {
                tsType = tsType.split('.').pop();
            }
            isClassType = true;
        } else {
            tsType = baseType;
        }
    }

    if (isArray) {
        return `${tsType}[]`;
    }

    // class types are nullable (can be null in data)
    if (isClassType) {
        return `${tsType} | null`;
    }

    return tsType;
}

/**
 * Generate TypeScript table row interface
 * @param {Object} table - Table definition from parseXlsx
 * @returns {string} Generated TypeScript code
 */
export function generateTypeScriptTable(table) {
    const lines = [];
    const interfaceName = table.name;

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System');
    lines.push('// </auto-generated>');
    lines.push('');

    // Interface
    lines.push(`export interface ${interfaceName} {`);

    for (const field of table.fields) {
        const tsType = mapTableTypeToTypeScript(field.type);
        const optional = field.optional && !field.isKey ? '?' : '';
        const propName = field.name;
        lines.push(`  ${propName}${optional}: ${tsType};`);
    }

    lines.push('}');

    return lines.join('\n');
}

/**
 * Generate TypeScript table interface body only (no header)
 * @param {Object} table - Table definition from parseXlsx
 * @returns {string} Generated TypeScript interface body code
 */
export function generateTypeScriptTableBody(table) {
    const lines = [];
    const interfaceName = table.name;
    const keyField = table.keyField;

    if (keyField) {
        const keyType = mapTableTypeToTypeScript(keyField.type);
        lines.push(`export interface ${interfaceName} extends IEntityKey<${keyType}> {`);
    } else {
        lines.push(`export interface ${interfaceName} extends IEntity {`);
    }

    for (const field of table.fields) {
        const tsType = mapTableTypeToTypeScript(field.type);
        const optional = field.optional && !field.isKey ? '?' : '';
        // Use PascalCase to match NDJSON field names (C# compatibility)
        const propName = capitalize(field.name);
        lines.push(`    ${propName}${optional}: ${tsType};`);
    }

    // getKey method signature (IEntityKey<T> implementation) - only if key exists
    if (keyField) {
        const keyType = mapTableTypeToTypeScript(keyField.type);
        lines.push(`    getKey(): ${keyType};`);
    }

    lines.push('}');

    return lines.join('\n');
}

function lowerFirst(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
}

/**
 * Generate TypeScript table container body
 * @param {Object} table - Table definition from parseXlsx
 * @param {Array} enumSpecs - Enum specs from collectEnumGenSpecs (optional)
 * @returns {string} Generated TypeScript container body code
 */
export function generateTypeScriptTableContainerBody(table, enumSpecs = []) {
    const lines = [];
    const tableName = table.name;
    const keyField = table.keyField;
    const keyType = keyField ? mapTableTypeToTypeScript(keyField.type) : null;
    // Use PascalCase to match NDJSON field names (C# compatibility)
    const keyProp = keyField ? capitalize(keyField.name) : null;

    // Get enum specs for this table
    const tableEnumSpecs = enumSpecs.filter(spec => spec.tableName === tableName);

    lines.push(`export class TB_${tableName} {`);

    // Storage
    if (keyField) {
        lines.push(`    private static _dict: Map<${keyType}, ${tableName}> = new Map();`);
    }
    lines.push(`    private static _list: ${tableName}[] = [];`);
    lines.push('');

    // Count property
    lines.push('    static get count(): number { return this._list.length; }');
    lines.push('');

    // Clear
    lines.push('    static clear(): void {');
    if (keyField) {
        lines.push('        this._dict.clear();');
    }
    lines.push('        this._list = [];');
    lines.push('    }');
    lines.push('');

    // GetAll
    lines.push(`    static getAll(): readonly ${tableName}[] { return this._list; }`);
    lines.push('');

    // Get/Has (if key exists)
    if (keyField) {
        lines.push(`    static get(key: ${keyType}): ${tableName} | undefined {`);
        lines.push('        return this._dict.get(key);');
        lines.push('    }');
        lines.push('');
        lines.push(`    static has(key: ${keyType}): boolean {`);
        lines.push('        return this._dict.has(key);');
        lines.push('    }');
        lines.push('');

        // find/tryFind (for gen: tables)
        if (tableEnumSpecs.length > 0) {
            // Check if keyType is already an enum type from the specs
            const keyTypeIsEnum = tableEnumSpecs.some(s => keyField.type === `enum:${s.enumName}`);
            
            if (keyTypeIsEnum) {
                // keyType is already the enum - no union type needed
                lines.push(`    static find(key: ${keyType}): ${tableName} {`);
                lines.push('        const row = this._dict.get(key);');
                lines.push(`        if (!row) throw new Error(\`TB_${tableName}: key \${key} not found\`);`);
                lines.push('        return row;');
                lines.push('    }');
                lines.push('');
                lines.push(`    static tryFind(key: ${keyType}): ${tableName} | undefined {`);
                lines.push('        return this._dict.get(key);');
                lines.push('    }');
                lines.push('');
            } else {
                // Build union type for enum keys
                const enumTypes = tableEnumSpecs.map(s => s.enumName).join(' | ');
                const keyUnionType = `${keyType} | ${enumTypes}`;

                lines.push(`    static find(key: ${keyUnionType}): ${tableName} {`);
                lines.push('        const row = this._dict.get(Number(key));');
                lines.push(`        if (!row) throw new Error(\`TB_${tableName}: key \${key} not found\`);`);
                lines.push('        return row;');
                lines.push('    }');
                lines.push('');
                lines.push(`    static tryFind(key: ${keyUnionType}): ${tableName} | undefined {`);
                lines.push('        return this._dict.get(Number(key));');
                lines.push('    }');
                lines.push('');
            }
        }
    }

    // LoadFromJson (NDJSON)
    lines.push('    static loadFromJson(json: string): void {');
    lines.push('        this.clear();');
    lines.push('        const lines = json.split(\'\\n\').filter(l => l.trim());');
    lines.push('        for (const line of lines) {');
    lines.push(`            const row = JSON.parse(line) as ${tableName};`);
    lines.push('            this._list.push(row);');
    if (keyField) {
        lines.push(`            this._dict.set(row.${keyProp}, row);`);
    }
    lines.push('        }');
    lines.push('    }');
    lines.push('');

    // SaveToJson (NDJSON)
    lines.push('    static saveToJson(): string {');
    lines.push('        return this._list.map(r => JSON.stringify(r)).join(\'\\n\');');
    lines.push('    }');

    lines.push('}');

    return lines.join('\n');
}

function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

// ============================================================================
// NDJSON Data Generator
// ============================================================================

/**
 * Convert a table row to ordered JSON object
 * Shared helper for NDJSON and Asset generation (avoids duplication)
 * SSOT: skills/devian/32-json-row-io/SKILL.md
 * @param {Object} row - Row data
 * @param {Array} fields - Field definitions from table
 * @returns {Object} Ordered row object ready for JSON.stringify
 */
function rowToOrderedJson(row, fields) {
    const orderedRow = {};
    for (const field of fields) {
        const value = row[field.name];
        // SSOT: 64-bit integers → string, enum → name string
        if (['long', 'ulong'].includes(field.type)) {
            orderedRow[capitalize(field.name)] = String(value);
        } else {
            orderedRow[capitalize(field.name)] = value;
        }
    }
    return orderedRow;
}

/**
 * Build export rows with PK validation
 * SSOT: skills/devian/32-json-row-io/SKILL.md - PK Validation
 * 
 * Rules:
 * - primaryKey가 정의되지 않은 테이블은 export 하지 않는다
 * - primaryKey 값이 빈 row는 export 하지 않는다
 * - export 가능한 row가 0개면 파일을 생성하지 않는다
 * 
 * @param {Object} table - Table definition from parseXlsx
 * @returns {Object} { rows: Array, skipped: boolean, reason: string|null }
 */
export function buildExportRows(table) {
    // Check if primaryKey is defined
    if (!table.keyField) {
        console.log(`[Skip] Table export skipped (no primaryKey defined): ${table.name}`);
        return { rows: [], skipped: true, reason: 'no_pk_defined' };
    }

    const pkFieldName = table.keyField.name;
    const validRows = [];

    for (const row of table.rows) {
        const pkValue = row[pkFieldName];
        
        // PK value must not be null, undefined, or empty string
        if (pkValue === null || pkValue === undefined || pkValue === '') {
            // Skip this row (PK is empty)
            continue;
        }
        
        validRows.push(row);
    }

    // Check if any valid rows remain
    if (validRows.length === 0) {
        console.log(`[Skip] Table export skipped (no valid PK rows): ${table.name}`);
        return { rows: [], skipped: true, reason: 'no_valid_rows' };
    }

    return { rows: validRows, skipped: false, reason: null };
}

/**
 * Generate NDJSON data from table
 * @param {Object} table - Table definition from parseXlsx
 * @returns {Object} { data: string, rowCount: number } - NDJSON string (one JSON per line) and row count
 */
export function generateTableData(table) {
    const { rows, skipped } = buildExportRows(table);
    
    if (skipped || rows.length === 0) {
        return { data: '', rowCount: 0 };
    }

    const lines = [];

    for (const row of rows) {
        // Convert row to JSON with proper property order (SSOT: Excel column order)
        const orderedRow = rowToOrderedJson(row, table.fields);
        lines.push(JSON.stringify(orderedRow));
    }

    return { data: lines.join('\n'), rowCount: rows.length };
}

// ============================================================================
// Unity TextAsset (.asset) Generator for Tables with PK
// SSOT: skills/devian/32-json-row-io/SKILL.md
// Format: Unity TextAsset YAML wrapping pb64 binary data (gzip block container)
// ============================================================================

// DVGB Container Constants
const DVGB_MAGIC = Buffer.from('DVGB', 'ascii');
const DVGB_VERSION = 1;
const DVGB_BLOCK_SIZE = 1048576; // 1024K = 1048576 bytes

/**
 * Encode unsigned integer as protobuf varint
 * @param {number} value - Unsigned 32-bit integer
 * @returns {Uint8Array} Varint bytes
 */
function encodeVarint(value) {
    const bytes = [];
    while (value > 0x7f) {
        bytes.push((value & 0x7f) | 0x80);
        value >>>= 7;
    }
    bytes.push(value & 0x7f);
    return new Uint8Array(bytes);
}

/**
 * Write 32-bit unsigned integer as little-endian
 * @param {number} value - Unsigned 32-bit integer
 * @returns {Buffer} 4-byte buffer
 */
function writeUInt32LE(value) {
    const buf = Buffer.allocUnsafe(4);
    buf.writeUInt32LE(value >>> 0, 0);
    return buf;
}

/**
 * Generate raw pb64 binary data from table (table-level, all rows concatenated)
 * Format: varint length-delimited JSON bytes → concat
 * Each row: [varint length][UTF-8 JSON bytes]
 * 
 * @param {Array} rows - Valid rows to export
 * @param {Array} fields - Field definitions
 * @returns {Buffer} Raw binary data (not base64)
 */
function generateRawPb64Binary(rows, fields) {
    const chunks = [];

    for (const row of rows) {
        const orderedRow = rowToOrderedJson(row, fields);
        const jsonStr = JSON.stringify(orderedRow);
        const jsonBytes = Buffer.from(jsonStr, 'utf8');
        
        // Prepend varint length
        const lengthVarint = encodeVarint(jsonBytes.length);
        
        chunks.push(Buffer.from(lengthVarint));
        chunks.push(jsonBytes);
    }

    return Buffer.concat(chunks);
}

/**
 * Compress raw binary using DVGB gzip block container format
 * 
 * Container format:
 * - Magic: 4 bytes "DVGB" (ASCII)
 * - Version: 1 byte (= 1)
 * - BlockSize: 4 bytes little-endian (= 1048576)
 * - BlockCount: 4 bytes little-endian
 * - Blocks: repeat BlockCount times
 *   - UncompressedLen: 4 bytes little-endian
 *   - CompressedLen: 4 bytes little-endian
 *   - GzipBytes: CompressedLen bytes
 * 
 * @param {Buffer} rawBinary - Raw pb64 binary data
 * @returns {Buffer} DVGB container binary
 */
function compressToDvgbContainer(rawBinary) {
    // Split into blocks
    const blocks = [];
    let offset = 0;
    
    while (offset < rawBinary.length) {
        const blockEnd = Math.min(offset + DVGB_BLOCK_SIZE, rawBinary.length);
        const block = rawBinary.slice(offset, blockEnd);
        
        // Compress block with gzip
        const compressed = gzipSync(block, { level: 9 });
        
        blocks.push({
            uncompressedLen: block.length,
            compressedLen: compressed.length,
            data: compressed
        });
        
        offset = blockEnd;
    }
    
    // Build container
    const headerParts = [
        DVGB_MAGIC,                      // 4 bytes: "DVGB"
        Buffer.from([DVGB_VERSION]),     // 1 byte: version
        writeUInt32LE(DVGB_BLOCK_SIZE),  // 4 bytes: blockSize
        writeUInt32LE(blocks.length)     // 4 bytes: blockCount
    ];
    
    const blockParts = [];
    for (const block of blocks) {
        blockParts.push(writeUInt32LE(block.uncompressedLen));
        blockParts.push(writeUInt32LE(block.compressedLen));
        blockParts.push(block.data);
    }
    
    return Buffer.concat([...headerParts, ...blockParts]);
}

/**
 * Generate pb64 binary data with gzip block compression
 * Returns base64 encoded DVGB container
 * 
 * @param {Array} rows - Valid rows to export
 * @param {Array} fields - Field definitions
 * @returns {string} Base64 encoded DVGB container
 */
function generatePb64Binary(rows, fields) {
    // Generate raw binary (existing format)
    const rawBinary = generateRawPb64Binary(rows, fields);
    
    if (rawBinary.length === 0) {
        return '';
    }
    
    // Compress to DVGB container
    const container = compressToDvgbContainer(rawBinary);
    
    // Return as base64
    return container.toString('base64');
}

/**
 * Generate Unity TextAsset YAML content
 * @param {string} tableName - Table name (= m_Name)
 * @param {string} base64Data - Base64 encoded pb64 binary data
 * @returns {string} Complete YAML content
 */
function generateTextAssetYaml(tableName, base64Data) {
    // Template is fixed - do not modify field names, order, indentation, or spacing
    return `%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!49 &4900000
TextAsset:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: ${tableName}
  m_Script: ${base64Data}
`;
}

/**
 * Generate Unity TextAsset .asset file for a table (table-level, single file)
 * SSOT: skills/devian/32-json-row-io/SKILL.md - pb64 export 규칙
 * 
 * Rules:
 * - Only tables with pk option (table.keyField exists) are exported
 * - If ANY row has empty PK value, the ENTIRE table is skipped (no partial export)
 * - Output: single {TableName}.asset file per table
 * - m_Script contains DVGB gzip block container (base64 encoded)
 * 
 * @param {Object} table - Table definition from parseXlsx
 * @returns {Object} { tableName: string, yaml: string, rowCount: number } or null if skipped
 */
export function generateTableAsset(table) {
    // Rule: Only tables with pk option are exported
    if (!table.keyField) {
        return null; // No pk option → no .asset export (silent skip)
    }

    const pkFieldName = table.keyField.name;
    const rows = table.rows || [];

    if (rows.length === 0) {
        console.log(`[Skip] Asset export skipped (no rows): ${table.name}`);
        return null;
    }

    // Rule: If ANY row has empty PK, skip the ENTIRE table
    for (const row of rows) {
        const pkValue = row[pkFieldName];
        if (pkValue === null || pkValue === undefined || pkValue === '') {
            console.log(`[Skip] Asset export skipped (empty PK row): ${table.name}`);
            return null;
        }
    }

    // Generate pb64 binary (DVGB gzip block container)
    const base64Data = generatePb64Binary(rows, table.fields);

    if (!base64Data || base64Data.length === 0) {
        console.log(`[Skip] Asset export skipped (empty data): ${table.name}`);
        return null;
    }

    // Wrap in Unity TextAsset YAML
    const yaml = generateTextAssetYaml(table.name, base64Data);

    return {
        tableName: table.name,
        yaml: yaml,
        rowCount: rows.length
    };
}

// ============================================================================
// Enum Generation (gen: option)
// SSOT: skills/devian/45-tablegen-enumgen/SKILL.md
// ============================================================================

const IDENTIFIER_REGEX = /^[A-Za-z_][A-Za-z0-9_]*$/;

/**
 * Collect enum generation specs from tables
 * 
 * Rules (SSOT: skills/devian/45-tablegen-enumgen/SKILL.md):
 * - gen column = PK column (same column, must have pk)
 * - gen column value = enum member NAME
 * - enum member VALUE = deterministic auto-assignment (name sorted, 0..N-1)
 * - Only 1 gen column per table
 * 
 * @param {Array} tables - Array of table definitions from parseXlsx
 * @returns {Array} Array of enum specs: [{ tableName, enumName, genFieldName, members:[{name,value}] }]
 */
export function collectEnumGenSpecs(tables) {
    const specs = [];

    for (const table of tables) {
        // Find fields with gen: option
        const genFields = table.fields.filter(f => f.gen);
        if (genFields.length === 0) continue;

        // Validate: only 1 gen column per table
        if (genFields.length > 1) {
            throw new Error(`[gen:] Table '${table.name}': only one gen column allowed per table, found ${genFields.length}`);
        }

        const genField = genFields[0];
        const enumName = genField.gen;

        // Validate: enum name must be valid identifier
        if (!enumName || !IDENTIFIER_REGEX.test(enumName)) {
            throw new Error(`[gen:] Table '${table.name}': invalid enum name '${enumName}'`);
        }

        // Validate: gen field must be pk (gen column = PK column)
        if (!table.keyField) {
            throw new Error(`[gen:] Table '${table.name}': gen field must be pk (gen column is the PK)`);
        }
        if (genField.name !== table.keyField.name) {
            throw new Error(`[gen:] Table '${table.name}': gen field must be pk (gen column is the PK)`);
        }

        // Collect member names from rows (gen/PK column value = member name)
        const memberNames = [];
        const seenNames = new Set();

        for (let i = 0; i < table.rows.length; i++) {
            const row = table.rows[i];
            const memberName = row[genField.name];  // enum name from gen/PK column

            // Validate: member name is not empty
            if (!memberName || String(memberName).trim() === '') {
                throw new Error(`[gen:] Table '${table.name}': empty enum member name at row ${i + 5}`);
            }

            // Validate: member name is valid identifier
            const nameStr = String(memberName).trim();
            if (!IDENTIFIER_REGEX.test(nameStr)) {
                throw new Error(`[gen:] Table '${table.name}': invalid member name '${nameStr}' at row ${i + 5}`);
            }

            // Validate: no duplicate names
            if (seenNames.has(nameStr)) {
                throw new Error(`[gen:] Table '${table.name}': duplicate member name '${nameStr}'`);
            }
            seenNames.add(nameStr);

            memberNames.push(nameStr);
        }

        // Sort member names ascending (deterministic)
        memberNames.sort();

        // Assign values 0..N-1 based on sorted order
        const members = memberNames.map((name, index) => ({ name, value: index }));

        specs.push({
            tableName: table.name,
            enumName: enumName,
            genFieldName: genField.name,
            members: members,
        });
    }

    return specs;
}

/**
 * Generate C# enum code block
 * @param {Array} enumSpecs - Array of enum specs from collectEnumGenSpecs
 * @returns {string} C# enum code block (to be inserted inside namespace)
 */
export function generateCSharpEnums(enumSpecs) {
    if (!enumSpecs || enumSpecs.length === 0) return '';

    const lines = [];
    lines.push('    // ========== Enums (gen:) ==========');
    lines.push('');

    for (const spec of enumSpecs) {
        lines.push(`    /// <summary>Auto-generated enum from TB_${spec.tableName}.${spec.genFieldName}</summary>`);
        lines.push(`    public enum ${spec.enumName} : int`);
        lines.push('    {');
        for (const member of spec.members) {
            lines.push(`        ${member.name} = ${member.value},`);
        }
        lines.push('    }');
        lines.push('');
    }

    return lines.join('\n');
}

/**
 * Generate TypeScript enum code block
 * @param {Array} enumSpecs - Array of enum specs from collectEnumGenSpecs
 * @returns {string} TypeScript enum code block
 */
export function generateTypeScriptEnums(enumSpecs) {
    if (!enumSpecs || enumSpecs.length === 0) return '';

    const lines = [];
    lines.push('// ========== Enums (gen:) ==========');
    lines.push('');

    for (const spec of enumSpecs) {
        lines.push(`/** Auto-generated enum from TB_${spec.tableName}.${spec.genFieldName} */`);
        lines.push(`export enum ${spec.enumName} {`);
        for (const member of spec.members) {
            lines.push(`    ${member.name} = ${member.value},`);
        }
        lines.push('}');
        lines.push('');
    }

    return lines.join('\n');
}

/**
 * Get enum specs for a specific table
 * @param {Object} table - Table definition
 * @param {Array} allEnumSpecs - All enum specs from collectEnumGenSpecs
 * @returns {Array} Enum specs for this table
 */
export function getTableEnumSpecs(table, allEnumSpecs) {
    return allEnumSpecs.filter(spec => spec.tableName === table.name);
}

/**
 * Get C# key type for a table (for {TableName}_ID generation)
 * @param {Object} table - Table definition with keyField
 * @returns {string} C# type string for the key field
 */
export function getCSharpKeyTypeForTable(table) {
    if (!table.keyField) {
        throw new Error(`Table '${table.name}' has no keyField`);
    }
    return mapTableTypeToCSharp(table.keyField.type, false);
}

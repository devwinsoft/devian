// <auto-generated>
// Devian Build System v10 - Table Generator
// SSOT: skills/devian/03-ssot/SKILL.md
// Namespace: Devian.Tables, Container: Table.TB_{TableName}
// </auto-generated>

import XLSX from 'xlsx';

/**
 * Parse XLSX file and extract table definitions
 * @param {string} filePath - Path to XLSX file
 * @returns {Array} Array of table definitions
 */
export function parseXlsx(filePath) {
    const workbook = XLSX.readFile(filePath);
    const tables = [];

    for (const sheetName of workbook.SheetNames) {
        const sheet = workbook.Sheets[sheetName];
        const table = parseSheet(sheet, sheetName);
        if (table) {
            tables.push(table);
        }
    }

    return tables;
}

/**
 * Parse a single sheet into table definition
 * @param {Object} sheet - XLSX sheet object
 * @param {string} sheetName - Sheet name
 * @returns {Object|null} Table definition or null if invalid
 */
function parseSheet(sheet, sheetName) {
    const range = XLSX.utils.decode_range(sheet['!ref'] || 'A1');
    const fields = [];
    let keyField = null;

    // Parse header (4 rows fixed per SSOT)
    // Row 1: FieldName, Row 2: Type, Row 3: Options, Row 4: Comment
    for (let col = range.s.c; col <= range.e.c; col++) {
        const fieldName = getCellValue(sheet, 0, col);
        let fieldType = getCellValue(sheet, 1, col);
        if (!fieldType) fieldType = 'string';

        // Header Stop Rule: Empty FieldName → stop scanning
        if (!fieldName) break

        const options = parseOptions(getCellValue(sheet, 2, col));
        const comment = getCellValue(sheet, 3, col);

        const field = {
            name: fieldName,
            type: fieldType,
            optional: options.optional === 'true',
            isKey: options.key === 'true',
            comment: comment || '',
        };

        fields.push(field);

        if (field.isKey) {
            if (keyField) {
                throw new Error(`Multiple key fields not allowed: ${sheetName}`);
            }
            keyField = field;
        }
    }

    if (fields.length === 0) return null;

    // Parse data rows (Row 5+, 0-indexed: row 4+)
    const rows = [];
    for (let row = 4; row <= range.e.r; row++) {
        const rowData = {};
        let isEmpty = true;
        let keyValue = null;

        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            const value = getCellValue(sheet, row, i);

            if (value !== null && value !== undefined && value !== '') {
                isEmpty = false;
            }

            // Parse value based on type
            rowData[field.name] = parseValue(value, field.type);

            if (field.isKey) {
                keyValue = rowData[field.name];
            }
        }

        // Data Stop Rule: Empty key → stop loading
        if (keyField && (keyValue === null || keyValue === undefined || keyValue === '')) {
            break;
        }

        // Empty row: skip (do not terminate)
        if (isEmpty) {
            continue;
        }

        rows.push(rowData);
    }

    return {
        name: sheetName,
        fields: fields,
        keyField: keyField,
        rows: rows,
    };
}

/**
 * Get cell value from sheet
 */
function getCellValue(sheet, row, col) {
    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
    const cell = sheet[cellAddress];
    return cell ? cell.v : null;
}

/**
 * Parse options string (comma-separated key:value pairs)
 *
 * SSOT: skills/devian/24-table-authoring-rules/SKILL.md
 * Example: "key:true, optional:true"
 */
function parseOptions(optionStr) {
    const options = {};
    if (!optionStr) return options;

    // Split by comma, allow extra spaces
    const parts = String(optionStr)
        .split(',')
        .map(p => p.trim())
        .filter(p => p.length > 0);

    for (const part of parts) {
        const idx = part.indexOf(':');
        if (idx <= 0) continue;
        const key = part.slice(0, idx).trim();
        const value = part.slice(idx + 1).trim();
        if (key && value !== undefined) {
            options[key] = value;
        }
    }
    return options;
}

/**
 * Parse value based on type
 */
function parseValue(value, type) {
    if (value === null || value === undefined || value === '') {
        return getDefaultForType(type);
    }

    const baseType = type.replace('[]', '');
    const isArray = type.endsWith('[]');

    if (isArray) {
        // Parse array value (DFF format: "a,b,c" or "{a,b,c}" or "[a,b,c]")
        let arrayStr = String(value);
        arrayStr = arrayStr.replace(/^[\[{]/, '').replace(/[\]}]$/, '');
        const items = arrayStr.split(',').map(s => s.trim()).filter(s => s !== '');
        return items.map(item => parseSingleValue(item, baseType));
    }

    return parseSingleValue(value, baseType);
}

function parseSingleValue(value, type) {
    if (value === null || value === undefined) return null;

    switch (type) {
        case 'byte':
        case 'ubyte':
        case 'short':
        case 'ushort':
        case 'int':
        case 'uint':
            return parseInt(value, 10);
        case 'long':
        case 'ulong':
            return String(value); // 64-bit as string for JSON
        case 'float':
        case 'double':
            return parseFloat(value);
        case 'bool':
            return value === true || value === 'true' || value === '1';
        case 'string':
            return String(value);
        default:
            // enum:Name or class:Name
            if (type.startsWith('enum:')) {
                return String(value); // enum stored as name string
            }
            if (type.startsWith('class:')) {
                // Parse nested JSON object
                if (typeof value === 'string' && value.trim()) {
                    try {
                        return JSON.parse(value);
                    } catch (e) {
                        // If parsing fails, return null
                        return null;
                    }
                }
                return null;
            }
            return value;
    }
}

function getDefaultForType(type) {
    if (type.endsWith('[]')) return [];
    switch (type) {
        case 'byte':
        case 'ubyte':
        case 'short':
        case 'ushort':
        case 'int':
        case 'uint':
        case 'float':
        case 'double':
            return 0;
        case 'long':
        case 'ulong':
            return '0';
        case 'bool':
            return false;
        case 'string':
            return '';
        default:
            return null;
    }
}

// ============================================================================
// C# Table Generator
// ============================================================================

/**
 * Generate C# table container code
 * @param {Object} table - Table definition from parseXlsx
 * @param {string} domainName - Domain name
 * @returns {string} Generated C# code
 */
export function generateCSharpTable(table, domainName) {
    const lines = [];
    const tableName = table.name;
    const rowClassName = tableName;

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push('// </auto-generated>');
    lines.push('');
    lines.push('#nullable enable');
    lines.push('');
    lines.push('using System;');
    lines.push('using System.Collections.Generic;');
    lines.push('using System.IO;');
    lines.push('using Newtonsoft.Json;');
    lines.push('');

    // Namespace: Devian.Tables (SSOT A안)
    lines.push('namespace Devian.Tables');
    lines.push('{');

    // Row class
    generateRowClass(lines, table, rowClassName);
    lines.push('');

    // Container: public static partial class Table
    lines.push('    public static partial class Table');
    lines.push('    {');

    // Table container: TB_{TableName}
    generateTableContainer(lines, table, tableName, rowClassName);

    lines.push('    }'); // end Table
    lines.push('}'); // end namespace

    return lines.join('\n');
}

/**
 * Generate C# table entity body only (no header, no namespace wrapper)
 * @param {Object} table - Table definition from parseXlsx
 * @returns {string} Generated C# entity body code
 */
export function generateCSharpTableEntityBody(table) {
    const lines = [];
    const rowClassName = table.name;
    generateRowClass(lines, table, rowClassName);
    return lines.join('\n');
}

/**
 * Generate C# table container body only (inside partial class Table)
 * @param {Object} table - Table definition from parseXlsx
 * @returns {string} Generated C# container body code
 */
export function generateCSharpTableContainerBody(table) {
    const lines = [];
    const tableName = table.name;
    const rowClassName = table.name;
    generateTableContainer(lines, table, tableName, rowClassName);
    return lines.join('\n');
}

function generateRowClass(lines, table, rowClassName) {
    const keyField = table.keyField;

    lines.push(`    /// <summary>${table.name} row</summary>`);

    if (keyField) {
        const keyType = mapTableTypeToCSharp(keyField.type, false);
        lines.push(`    public sealed class ${rowClassName} : IEntityKey<${keyType}>`);
    } else {
        lines.push(`    public sealed class ${rowClassName} : IEntity`);
    }

    lines.push('    {');

    for (const field of table.fields) {
        const csType = mapTableTypeToCSharp(field.type, field.optional);
        const propName = capitalize(field.name);
        const defaultValue = getTableDefaultValue(field.type);
        lines.push(`        public ${csType} ${propName} { get; set; }${defaultValue}`);
    }

    // GetKey method (IEntityKey<T> implementation) - only if key exists
    if (keyField) {
        const keyType = mapTableTypeToCSharp(keyField.type, false);
        lines.push('');
        lines.push(`        public ${keyType} GetKey() => ${capitalize(keyField.name)};`);
    }

    lines.push('    }');
}

function generateTableContainer(lines, table, tableName, rowClassName) {
    const keyType = table.keyField ? mapTableTypeToCSharp(table.keyField.type, false) : 'int';
    const keyProp = table.keyField ? capitalize(table.keyField.name) : 'Id';

    lines.push(`    /// <summary>TB_${tableName} container</summary>`);
    lines.push(`    public static class TB_${tableName}`);
    lines.push('    {');

    // Storage
    if (table.keyField) {
        lines.push(`        private static readonly Dictionary<${keyType}, ${rowClassName}> _dict = new();`);
    }
    lines.push(`        private static readonly List<${rowClassName}> _list = new();`);
    lines.push('');

    // Count property
    lines.push('        public static int Count => _list.Count;');
    lines.push('');

    // Clear
    lines.push('        public static void Clear()');
    lines.push('        {');
    if (table.keyField) {
        lines.push('            _dict.Clear();');
    }
    lines.push('            _list.Clear();');
    lines.push('        }');
    lines.push('');

    // GetAll
    lines.push(`        public static IReadOnlyList<${rowClassName}> GetAll() => _list;`);
    lines.push('');

    // Get/TryGet (if key exists)
    if (table.keyField) {
        lines.push(`        public static ${rowClassName}? Get(${keyType} key)`);
        lines.push('        {');
        lines.push('            return _dict.TryGetValue(key, out var row) ? row : null;');
        lines.push('        }');
        lines.push('');
        lines.push(`        public static bool TryGet(${keyType} key, out ${rowClassName}? row)`);
        lines.push('        {');
        lines.push('            return _dict.TryGetValue(key, out row);');
        lines.push('        }');
        lines.push('');
    }

    // LoadFromJson
    lines.push('        public static void LoadFromJson(string json)');
    lines.push('        {');
    lines.push('            Clear();');
    lines.push(`            var rows = JsonConvert.DeserializeObject<List<${rowClassName}>>(json);`);
    lines.push('            if (rows == null) return;');
    lines.push('            foreach (var row in rows)');
    lines.push('            {');
    lines.push('                if (row == null) continue;');
    lines.push('                _list.Add(row);');
    if (table.keyField) {
        lines.push(`                _dict[row.${keyProp}] = row;`);
    }
    lines.push('            }');
    lines.push('        }');
    lines.push('');

    // LoadFromNdjson
    lines.push('        public static void LoadFromNdjson(string ndjson)');
    lines.push('        {');
    lines.push('            Clear();');
    lines.push('            using var reader = new StringReader(ndjson);');
    lines.push('            string? line;');
    lines.push('            while ((line = reader.ReadLine()) != null)');
    lines.push('            {');
    lines.push('                if (string.IsNullOrWhiteSpace(line)) continue;');
    lines.push(`                var row = JsonConvert.DeserializeObject<${rowClassName}>(line);`);
    lines.push('                if (row == null) continue;');
    lines.push('                _list.Add(row);');
    if (table.keyField) {
        lines.push(`                _dict[row.${keyProp}] = row;`);
    }
    lines.push('            }');
    lines.push('        }');

    lines.push('    }');
}

function mapTableTypeToCSharp(type, optional) {
    const isArray = type.endsWith('[]');
    const baseType = isArray ? type.slice(0, -2) : type;

    const typeMap = {
        'byte': 'sbyte',
        'ubyte': 'byte',
        'short': 'short',
        'ushort': 'ushort',
        'int': 'int',
        'uint': 'uint',
        'long': 'long',
        'ulong': 'ulong',
        'float': 'float',
        'double': 'double',
        'string': 'string',
        'bool': 'bool',
    };

    let csType = typeMap[baseType];

    if (!csType) {
        // enum:Name or class:Name
        if (baseType.startsWith('enum:')) {
            csType = baseType.slice(5);
            if (csType.includes('.')) {
                const [ns, name] = csType.split('.');
                csType = `Devian.${ns}.${name}`;
            }
        } else if (baseType.startsWith('class:')) {
            csType = baseType.slice(6);
            if (csType.includes('.')) {
                const [ns, name] = csType.split('.');
                csType = `Devian.${ns}.${name}`;
            }
            // class types are nullable (reference types can be null in data)
            if (!isArray) {
                csType = `${csType}?`;
            }
        } else {
            csType = baseType;
        }
    }

    if (isArray) {
        return `List<${csType}>`;
    }

    if (optional && ['string'].includes(baseType)) {
        return `${csType}?`;
    }

    return csType;
}

function getTableDefaultValue(type) {
    if (type.endsWith('[]')) return ' = new();';
    if (type === 'string') return ' = string.Empty;';
    return '';
}

// ============================================================================
// TypeScript Table Generator
// ============================================================================

/**
 * Map table type to TypeScript type
 * @param {string} type - Table type (e.g., int, string, enum:Name)
 * @returns {string} TypeScript type
 */
function mapTableTypeToTypeScript(type) {
    const isArray = type.endsWith('[]');
    const baseType = isArray ? type.slice(0, -2) : type;

    const typeMap = {
        'byte': 'number',
        'ubyte': 'number',
        'short': 'number',
        'ushort': 'number',
        'int': 'number',
        'uint': 'number',
        'long': 'number',
        'ulong': 'number',
        'float': 'number',
        'double': 'number',
        'string': 'string',
        'bool': 'boolean',
    };

    let tsType = typeMap[baseType];
    let isClassType = false;

    if (!tsType) {
        // enum:Name or class:Name
        if (baseType.startsWith('enum:')) {
            tsType = baseType.slice(5);
            // Remove namespace prefix if exists (e.g., Common.UserType → UserType)
            if (tsType.includes('.')) {
                tsType = tsType.split('.').pop();
            }
        } else if (baseType.startsWith('class:')) {
            tsType = baseType.slice(6);
            if (tsType.includes('.')) {
                tsType = tsType.split('.').pop();
            }
            isClassType = true;
        } else {
            tsType = baseType;
        }
    }

    if (isArray) {
        return `${tsType}[]`;
    }

    // class types are nullable (can be null in data)
    if (isClassType) {
        return `${tsType} | null`;
    }

    return tsType;
}

/**
 * Generate TypeScript table row interface
 * @param {Object} table - Table definition from parseXlsx
 * @returns {string} Generated TypeScript code
 */
export function generateTypeScriptTable(table) {
    const lines = [];
    const interfaceName = table.name;

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System');
    lines.push('// </auto-generated>');
    lines.push('');

    // Interface
    lines.push(`export interface ${interfaceName} {`);

    for (const field of table.fields) {
        const tsType = mapTableTypeToTypeScript(field.type);
        const optional = field.optional && !field.isKey ? '?' : '';
        const propName = field.name;
        lines.push(`  ${propName}${optional}: ${tsType};`);
    }

    lines.push('}');

    return lines.join('\n');
}

/**
 * Generate TypeScript table interface body only (no header)
 * @param {Object} table - Table definition from parseXlsx
 * @returns {string} Generated TypeScript interface body code
 */
export function generateTypeScriptTableBody(table) {
    const lines = [];
    const interfaceName = table.name;
    const keyField = table.keyField;

    if (keyField) {
        const keyType = mapTableTypeToTypeScript(keyField.type);
        lines.push(`export interface ${interfaceName} extends IEntityKey<${keyType}> {`);
    } else {
        lines.push(`export interface ${interfaceName} extends IEntity {`);
    }

    for (const field of table.fields) {
        const tsType = mapTableTypeToTypeScript(field.type);
        const optional = field.optional && !field.isKey ? '?' : '';
        // Use PascalCase to match NDJSON field names (C# compatibility)
        const propName = capitalize(field.name);
        lines.push(`    ${propName}${optional}: ${tsType};`);
    }

    // getKey method signature (IEntityKey<T> implementation) - only if key exists
    if (keyField) {
        const keyType = mapTableTypeToTypeScript(keyField.type);
        lines.push(`    getKey(): ${keyType};`);
    }

    lines.push('}');

    return lines.join('\n');
}

function lowerFirst(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
}

/**
 * Generate TypeScript table container body
 * @param {Object} table - Table definition from parseXlsx
 * @returns {string} Generated TypeScript container body code
 */
export function generateTypeScriptTableContainerBody(table) {
    const lines = [];
    const tableName = table.name;
    const keyField = table.keyField;
    const keyType = keyField ? mapTableTypeToTypeScript(keyField.type) : null;
    // Use PascalCase to match NDJSON field names (C# compatibility)
    const keyProp = keyField ? capitalize(keyField.name) : null;

    lines.push(`export class TB_${tableName} {`);

    // Storage
    if (keyField) {
        lines.push(`    private static _dict: Map<${keyType}, ${tableName}> = new Map();`);
    }
    lines.push(`    private static _list: ${tableName}[] = [];`);
    lines.push('');

    // Count property
    lines.push('    static get count(): number { return this._list.length; }');
    lines.push('');

    // Clear
    lines.push('    static clear(): void {');
    if (keyField) {
        lines.push('        this._dict.clear();');
    }
    lines.push('        this._list = [];');
    lines.push('    }');
    lines.push('');

    // GetAll
    lines.push(`    static getAll(): readonly ${tableName}[] { return this._list; }`);
    lines.push('');

    // Get/Has (if key exists)
    if (keyField) {
        lines.push(`    static get(key: ${keyType}): ${tableName} | undefined {`);
        lines.push('        return this._dict.get(key);');
        lines.push('    }');
        lines.push('');
        lines.push(`    static has(key: ${keyType}): boolean {`);
        lines.push('        return this._dict.has(key);');
        lines.push('    }');
        lines.push('');
    }

    // LoadFromJson (NDJSON)
    lines.push('    static loadFromJson(json: string): void {');
    lines.push('        this.clear();');
    lines.push('        const lines = json.split(\'\\n\').filter(l => l.trim());');
    lines.push('        for (const line of lines) {');
    lines.push(`            const row = JSON.parse(line) as ${tableName};`);
    lines.push('            this._list.push(row);');
    if (keyField) {
        lines.push(`            this._dict.set(row.${keyProp}, row);`);
    }
    lines.push('        }');
    lines.push('    }');
    lines.push('');

    // SaveToJson (NDJSON)
    lines.push('    static saveToJson(): string {');
    lines.push('        return this._list.map(r => JSON.stringify(r)).join(\'\\n\');');
    lines.push('    }');

    lines.push('}');

    return lines.join('\n');
}

function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

// ============================================================================
// NDJSON Data Generator
// ============================================================================

/**
 * Generate NDJSON data from table
 * @param {Object} table - Table definition from parseXlsx
 * @returns {string} NDJSON string (one JSON per line)
 */
export function generateTableData(table) {
    const lines = [];

    for (const row of table.rows) {
        // Convert row to JSON with proper property order (SSOT: Excel column order)
        const orderedRow = {};
        for (const field of table.fields) {
            const value = row[field.name];
            // SSOT: 64-bit integers → string, enum → name string
            if (['long', 'ulong'].includes(field.type)) {
                orderedRow[capitalize(field.name)] = String(value);
            } else {
                orderedRow[capitalize(field.name)] = value;
            }
        }
        lines.push(JSON.stringify(orderedRow));
    }

    return lines.join('\n');
}

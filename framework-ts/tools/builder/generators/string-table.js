// <auto-generated>
// Devian Build System v10 - String Table Generator
// SSOT: skills/devian-data/33-string-table/SKILL.md
// </auto-generated>

import XLSX from 'xlsx';
import { encodeNdjsonFromObjects } from './ndjson-storage.js';

// ============================================================================
// SystemLanguage enum (Unity)
// https://docs.unity3d.com/ScriptReference/SystemLanguage.html
// ============================================================================

const SYSTEM_LANGUAGE_ENUM = new Set([
    'Afrikaans', 'Arabic', 'Basque', 'Belarusian', 'Bulgarian', 'Catalan',
    'Chinese', 'ChineseSimplified', 'ChineseTraditional', 'Czech', 'Danish',
    'Dutch', 'English', 'Estonian', 'Faroese', 'Finnish', 'French', 'German',
    'Greek', 'Hebrew', 'Hungarian', 'Icelandic', 'Indonesian', 'Italian',
    'Japanese', 'Korean', 'Latvian', 'Lithuanian', 'Norwegian', 'Polish',
    'Portuguese', 'Romanian', 'Russian', 'SerboCroatian', 'Slovak', 'Slovenian',
    'Spanish', 'Swedish', 'Thai', 'Turkish', 'Ukrainian', 'Unknown', 'Vietnamese'
]);

// ============================================================================
// pb64 Chunk Settings (SSOT: 33-string-table)
// ============================================================================

const TARGET_CHUNK_BYTES = 65536;
const MAX_ENTRIES_PER_CHUNK = 256;

// ============================================================================
// Protobuf Wire Format Encoder (minimal, no external dependency)
// ============================================================================

/**
 * Encode a varint (unsigned)
 * @param {number} value 
 * @returns {number[]}
 */
function encodeVarint(value) {
    const bytes = [];
    let v = value >>> 0; // ensure unsigned
    while (v > 0x7f) {
        bytes.push((v & 0x7f) | 0x80);
        v >>>= 7;
    }
    bytes.push(v);
    return bytes;
}

/**
 * Encode a string as length-delimited bytes
 * @param {string} str 
 * @returns {number[]}
 */
function encodeString(str) {
    const buf = Buffer.from(str, 'utf8');
    return [...encodeVarint(buf.length), ...buf];
}

/**
 * Encode a StringEntry message
 * message StringEntry { string id = 1; string text = 2; }
 * @param {string} id 
 * @param {string} text 
 * @returns {number[]}
 */
function encodeStringEntry(id, text) {
    const bytes = [];
    // field 1: id (string, wire type 2 = length-delimited)
    bytes.push((1 << 3) | 2); // tag
    bytes.push(...encodeString(id));
    // field 2: text (string, wire type 2)
    bytes.push((2 << 3) | 2); // tag
    bytes.push(...encodeString(text));
    return bytes;
}

/**
 * Encode a StringChunk message
 * message StringChunk { repeated StringEntry entries = 1; }
 * @param {Array<{id: string, text: string}>} entries 
 * @returns {number[]}
 */
function encodeStringChunk(entries) {
    const bytes = [];
    for (const entry of entries) {
        const entryBytes = encodeStringEntry(entry.id, entry.text);
        // field 1: entries (embedded message, wire type 2)
        bytes.push((1 << 3) | 2); // tag
        bytes.push(...encodeVarint(entryBytes.length));
        bytes.push(...entryBytes);
    }
    return bytes;
}

// ============================================================================
// String Table Sheet Detection & Parsing
// ============================================================================

/**
 * Check if a sheet is a String Table
 * Required: id, description, and at least one valid language column
 * @param {string[]} headers 
 * @returns {{isStringTable: boolean, languages: string[], invalidLanguages: string[]}}
 */
function detectStringTableSheet(headers) {
    const hasId = headers.includes('id');
    const hasDescription = headers.includes('description');
    
    if (!hasId || !hasDescription) {
        return { isStringTable: false, languages: [], invalidLanguages: [] };
    }
    
    const languages = [];
    const invalidLanguages = [];
    
    for (const header of headers) {
        if (header === 'id' || header === 'description') continue;
        
        if (SYSTEM_LANGUAGE_ENUM.has(header)) {
            languages.push(header);
        } else {
            // Could be an invalid language column or just a different column
            // Only report as invalid if it looks like it could be a language (starts with uppercase)
            if (/^[A-Z]/.test(header)) {
                invalidLanguages.push(header);
            }
        }
    }
    
    return {
        isStringTable: languages.length > 0,
        languages,
        invalidLanguages
    };
}

/**
 * Parse string tables from an XLSX file
 * @param {string} filePath 
 * @returns {Array<{tableName: string, byLanguage: Map<string, Map<string, string>>}>}
 * @throws {Error} on validation failure
 */
export function parseStringTablesFromXlsx(filePath) {
    const workbook = XLSX.readFile(filePath);
    const results = [];
    
    for (const sheetName of workbook.SheetNames) {
        const sheet = workbook.Sheets[sheetName];
        const data = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: '' });
        
        if (data.length < 2) continue; // Need header + at least 1 row
        
        const headers = data[0].map(h => String(h).trim());
        const detection = detectStringTableSheet(headers);
        
        if (!detection.isStringTable) continue;
        
        // Validate: no invalid language columns
        if (detection.invalidLanguages.length > 0) {
            throw new Error(
                `[FAIL] Invalid language column names in sheet '${sheetName}':\n` +
                `  Invalid: ${detection.invalidLanguages.join(', ')}\n` +
                `  Language columns must match UnityEngine.SystemLanguage enum names exactly.\n` +
                `  Valid examples: English, Korean, Japanese, ChineseSimplified, etc.`
            );
        }
        
        // Find column indices
        const idCol = headers.indexOf('id');
        const langCols = new Map();
        for (const lang of detection.languages) {
            langCols.set(lang, headers.indexOf(lang));
        }
        
        // Parse rows
        const byLanguage = new Map();
        for (const lang of detection.languages) {
            byLanguage.set(lang, new Map());
        }
        
        const seenIds = new Set();
        
        for (let rowIdx = 1; rowIdx < data.length; rowIdx++) {
            const row = data[rowIdx];
            const id = String(row[idCol] ?? '').trim();
            
            if (id === '') {
                throw new Error(
                    `[FAIL] Empty id in sheet '${sheetName}' row ${rowIdx + 1}.\n` +
                    `  The 'id' column cannot be empty.`
                );
            }
            
            if (seenIds.has(id)) {
                throw new Error(
                    `[FAIL] Duplicate id '${id}' in sheet '${sheetName}' row ${rowIdx + 1}.\n` +
                    `  Each id must be unique within the sheet.`
                );
            }
            seenIds.add(id);
            
            for (const [lang, colIdx] of langCols) {
                const text = String(row[colIdx] ?? '');
                byLanguage.get(lang).set(id, text);
            }
        }
        
        results.push({
            tableName: sheetName,
            byLanguage
        });
    }
    
    return results;
}

// ============================================================================
// Output Generation
// ============================================================================

/**
 * Generate ndjson content for a string table
 * Format: one JSON object per line {"id":"...","text":"..."}
 * SSOT: skills/devian-data/34-ndjson-storage/SKILL.md
 * @param {Map<string, string>} entries - Map of id -> text
 * @returns {string}
 */
export function generateStringNdjson(entries) {
    const objects = [];
    for (const [id, text] of entries) {
        objects.push({ id, text });
    }
    return encodeNdjsonFromObjects(objects);
}

/**
 * Generate pb64 content for a string table (chunked)
 * Format: multiple lines, each line is base64(StringChunk bytes)
 * @param {Map<string, string>} entries - Map of id -> text
 * @returns {string}
 */
export function generateStringPb64(entries) {
    const lines = [];
    let chunkEntries = [];
    let chunkBytes = 0;
    
    const flushChunk = () => {
        if (chunkEntries.length === 0) return;
        
        const chunkData = encodeStringChunk(chunkEntries);
        const base64 = Buffer.from(chunkData).toString('base64');
        lines.push(base64);
        
        chunkEntries = [];
        chunkBytes = 0;
    };
    
    for (const [id, text] of entries) {
        const entryBytes = encodeStringEntry(id, text);
        const entrySize = entryBytes.length + encodeVarint(entryBytes.length).length + 1; // +1 for tag
        
        // Check if we need to flush before adding
        if (chunkEntries.length > 0) {
            if (chunkBytes + entrySize >= TARGET_CHUNK_BYTES || 
                chunkEntries.length >= MAX_ENTRIES_PER_CHUNK) {
                flushChunk();
            }
        }
        
        chunkEntries.push({ id, text });
        chunkBytes += entrySize;
    }
    
    // Flush remaining
    flushChunk();
    
    return lines.join('\n');
}

// ============================================================================
// Export for build.js
// ============================================================================

export { SYSTEM_LANGUAGE_ENUM };

// ============================================================================
// Unity TextAsset YAML Generation for String Table pb64
// SSOT: skills/devian-upm/30-unity-components/13-pb64-storage/SKILL.md
// ============================================================================

/**
 * Generate Unity TextAsset YAML for String Table pb64
 * Uses block scalar (|) for multi-line pb64 content
 * @param {string} tableName - Table name (used for m_Name)
 * @param {string} pb64Text - Multi-line pb64 content (each line is base64(StringChunk))
 * @returns {string} Complete YAML content
 */
export function generateStringPb64TextAssetYaml(tableName, pb64Text) {
    // Split pb64 content into lines and indent each line with 4 spaces
    const lines = pb64Text.split('\n');
    const indentedLines = lines.map(line => `    ${line}`).join('\n');
    
    // Template is fixed - do not modify field names, order, indentation, or spacing
    // m_Script uses block scalar (|) for multi-line content
    return `%YAML 1.1
%TAG !u! tag:unity3d.com,2011:
--- !u!49 &4900000
TextAsset:
  m_ObjectHideFlags: 0
  m_CorrespondingSourceObject: {fileID: 0}
  m_PrefabInstance: {fileID: 0}
  m_PrefabAsset: {fileID: 0}
  m_Name: ${tableName}
  m_Script: |
${indentedLines}
`;
}

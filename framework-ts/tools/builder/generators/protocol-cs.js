// <auto-generated>
// Devian Build System v10 - C# Protocol Generator
// SSOT: skills/devian-core/03-ssot/SKILL.md
// Namespace: Devian.Protocol.{Group} + static partial class {ProtocolName}
// </auto-generated>

import { isComplexAlias, mapCSharpBaseType as mapComplexAlias, scanProtocolUsesComplexAliases } from './protocol-type-mapper.js';

/**
 * Generate C# protocol code from protocol spec
 * @param {Object} spec - Protocol specification
 * @param {string} protocolName - Protocol name (e.g., "C2Game")
 * @param {string} groupName - Protocol group name (e.g., "Game")
 * @returns {string} Generated C# code
 */
export function generateCSharpProtocol(spec, protocolName, groupName) {
    const lines = [];
    
    // Check if protocol uses complex aliases
    const usesComplexAliases = scanProtocolUsesComplexAliases(spec);

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push('// </auto-generated>');
    lines.push('');
    lines.push('#nullable enable');
    lines.push('');
    lines.push('using System;');
    lines.push('using System.Buffers;');
    lines.push('using System.Collections.Generic;');
    lines.push('using System.IO;');
    lines.push('using System.Text;');
    // Note: System.Text.Json 미사용 (Unity 호환성)
    lines.push('using Devian;');
    if (usesComplexAliases) {
        lines.push('using Newtonsoft.Json;');
    }
    lines.push('');

    // Namespace: Devian.Protocol.{Group} (block style)
    lines.push(`namespace Devian.Protocol.${groupName}`);
    lines.push('{');

    // Direction comment
    if (spec.direction && spec.direction !== 'bidirectional') {
        lines.push(`    // Direction: ${spec.direction}`);
        lines.push('');
    }

    // Container: public static partial class {ProtocolName}
    lines.push('    /// <summary>');
    lines.push(`    /// ${protocolName} protocol container.`);
    lines.push('    /// </summary>');
    lines.push(`    public static partial class ${protocolName}`);
    lines.push('    {');

    // Frame helper
    generateFrameHelper(lines);
    lines.push('');

    // EnvelopeMeta
    generateEnvelopeMeta(lines);
    lines.push('');

    // PacketEnvelope (ref struct)
    generatePacketEnvelope(lines);
    lines.push('');

    // PacketPool<T>
    generatePacketPool(lines);
    lines.push('');

    // ProtoReader (ref struct)
    generateProtoReader(lines);
    lines.push('');

    // ProtoWriter helper
    generateProtoWriter(lines);
    lines.push('');

    // Message classes
    for (const message of spec.messages || []) {
        generateMessageClass(lines, message);
        lines.push('');
    }

    // Opcodes class
    generateOpcodesClass(lines, spec.messages || [], protocolName);
    lines.push('');

    // ICodec interface
    generateICodec(lines, protocolName);
    lines.push('');

    // CodecJson (Newtonsoft.Json) - generated when complex aliases are used
    if (usesComplexAliases) {
        generateCodecJson(lines, spec.messages || [], protocolName);
        lines.push('');
    }

    // CodecProtobuf
    generateCodecProtobuf(lines, spec.messages || [], protocolName, usesComplexAliases);
    lines.push('');

    // ISender interface
    generateISender(lines);
    lines.push('');

    // Stub (abstract class)
    generateStub(lines, spec.messages || [], protocolName, usesComplexAliases);
    lines.push('');

    // Runtime Adapter (INetRuntime implementation)
    generateRuntimeAdapter(lines, spec.messages || [], protocolName, usesComplexAliases);
    lines.push('');

    // Proxy
    generateProxy(lines, spec.messages || [], protocolName, usesComplexAliases);

    // Pooling API (RentDecodePooled / ReturnPooled)
    if (!usesComplexAliases && (spec.messages || []).length > 0) {
        lines.push('');
        generatePoolingApi(lines, spec.messages || []);
    }

    lines.push('    }'); // end static class
    lines.push('}'); // end namespace

    return lines.join('\n');
}

// ============================================================================
// Helper Generators
// ============================================================================

function generateFrameHelper(lines) {
    lines.push('        /// <summary>');
    lines.push('        /// Frame helper for protocol framing.');
    lines.push('        /// Frame format: [opcode:int32LE][payload...]');
    lines.push('        /// </summary>');
    lines.push('        internal static class Frame');
    lines.push('        {');
    lines.push('            public static int ReadOpcode(ReadOnlySpan<byte> frame)');
    lines.push('            {');
    lines.push('                if (frame.Length < 4) throw new ArgumentException("Frame too short");');
    lines.push('                return BitConverter.ToInt32(frame.Slice(0, 4));');
    lines.push('            }');
    lines.push('');
    lines.push('            public static ReadOnlySpan<byte> ReadPayload(ReadOnlySpan<byte> frame)');
    lines.push('            {');
    lines.push('                if (frame.Length < 4) return ReadOnlySpan<byte>.Empty;');
    lines.push('                return frame.Slice(4);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static byte[] Pack(int opcode, ReadOnlySpan<byte> payload)');
    lines.push('            {');
    lines.push('                var frame = new byte[4 + payload.Length];');
    lines.push('                BitConverter.TryWriteBytes(frame.AsSpan(0, 4), opcode);');
    lines.push('                payload.CopyTo(frame.AsSpan(4));');
    lines.push('                return frame;');
    lines.push('            }');
    lines.push('        }');
}

function generateEnvelopeMeta(lines) {
    lines.push('        /// <summary>Envelope metadata (sessionId 등)</summary>');
    lines.push('        public readonly struct EnvelopeMeta');
    lines.push('        {');
    lines.push('            public int SessionId { get; }');
    lines.push('');
    lines.push('            public EnvelopeMeta(int sessionId)');
    lines.push('            {');
    lines.push('                SessionId = sessionId;');
    lines.push('            }');
    lines.push('        }');
}

function generatePacketEnvelope(lines) {
    lines.push('        /// <summary>');
    lines.push('        /// Packet envelope (ref struct - 복사/할당 방지)');
    lines.push('        /// </summary>');
    lines.push('        public ref struct PacketEnvelope');
    lines.push('        {');
    lines.push('            public int Opcode { get; }');
    lines.push('            public ReadOnlySpan<byte> Payload { get; }');
    lines.push('            public EnvelopeMeta Meta { get; }');
    lines.push('');
    lines.push('            public PacketEnvelope(int opcode, ReadOnlySpan<byte> payload, EnvelopeMeta meta)');
    lines.push('            {');
    lines.push('                Opcode = opcode;');
    lines.push('                Payload = payload;');
    lines.push('                Meta = meta;');
    lines.push('            }');
    lines.push('        }');
}

function generatePacketPool(lines) {
    lines.push('        /// <summary>');
    lines.push('        /// Generic packet pool for message object reuse.');
    lines.push('        /// </summary>');
    lines.push('        internal sealed class PacketPool<T> where T : class, new()');
    lines.push('        {');
    lines.push('            private readonly Stack<T> _stack;');
    lines.push('            private readonly int _max;');
    lines.push('');
    lines.push('            public PacketPool(int max = 256)');
    lines.push('            {');
    lines.push('                _max = max;');
    lines.push('                _stack = new Stack<T>(Math.Min(max, 32));');
    lines.push('            }');
    lines.push('');
    lines.push('            public T Rent()');
    lines.push('            {');
    lines.push('                lock (_stack)');
    lines.push('                {');
    lines.push('                    return _stack.Count > 0 ? _stack.Pop() : new T();');
    lines.push('                }');
    lines.push('            }');
    lines.push('');
    lines.push('            public void Return(T item)');
    lines.push('            {');
    lines.push('                lock (_stack)');
    lines.push('                {');
    lines.push('                    if (_stack.Count < _max) _stack.Push(item);');
    lines.push('                }');
    lines.push('            }');
    lines.push('        }');
}

function generateProtoReader(lines) {
    lines.push('        /// <summary>');
    lines.push('        /// Span-based protobuf reader (zero-copy, zero-alloc for string decode)');
    lines.push('        /// </summary>');
    lines.push('        internal ref struct ProtoReader');
    lines.push('        {');
    lines.push('            // Static UTF8 encoder to avoid repeated Encoding.UTF8 property access');
    lines.push('            private static readonly Encoding Utf8 = Encoding.UTF8;');
    lines.push('');
    lines.push('            private ReadOnlySpan<byte> _data;');
    lines.push('            private int _pos;');
    lines.push('');
    lines.push('            public ProtoReader(ReadOnlySpan<byte> data)');
    lines.push('            {');
    lines.push('                _data = data;');
    lines.push('                _pos = 0;');
    lines.push('            }');
    lines.push('');
    lines.push('            public bool HasMore => _pos < _data.Length;');
    lines.push('            public int Position => _pos;');
    lines.push('            public int Remaining => _data.Length - _pos;');
    lines.push('');
    lines.push('            public (int tag, int wireType) ReadTag()');
    lines.push('            {');
    lines.push('                var varint = ReadVarint();');
    lines.push('                return ((int)(varint >> 3), (int)(varint & 0x7));');
    lines.push('            }');
    lines.push('');
    lines.push('            public long ReadVarint()');
    lines.push('            {');
    lines.push('                long result = 0;');
    lines.push('                int shift = 0;');
    lines.push('                while (_pos < _data.Length)');
    lines.push('                {');
    lines.push('                    byte b = _data[_pos++];');
    lines.push('                    result |= (long)(b & 0x7F) << shift;');
    lines.push('                    if ((b & 0x80) == 0) break;');
    lines.push('                    shift += 7;');
    lines.push('                }');
    lines.push('                return result;');
    lines.push('            }');
    lines.push('');
    lines.push('            public int ReadInt32() => (int)ReadVarint();');
    lines.push('            public long ReadInt64() => ReadVarint();');
    lines.push('            public uint ReadUInt32() => (uint)ReadVarint();');
    lines.push('            public ulong ReadUInt64() => (ulong)ReadVarint();');
    lines.push('            public bool ReadBool() => ReadVarint() != 0;');
    lines.push('');
    lines.push('            public int ReadSInt32()');
    lines.push('            {');
    lines.push('                var n = (uint)ReadVarint();');
    lines.push('                return (int)((n >> 1) ^ -(int)(n & 1));');
    lines.push('            }');
    lines.push('');
    lines.push('            public long ReadSInt64()');
    lines.push('            {');
    lines.push('                var n = (ulong)ReadVarint();');
    lines.push('                return (long)(n >> 1) ^ -(long)(n & 1);');
    lines.push('            }');
    lines.push('');
    lines.push('            public float ReadFloat()');
    lines.push('            {');
    lines.push('                var span = _data.Slice(_pos, 4);');
    lines.push('                _pos += 4;');
    lines.push('                return BitConverter.ToSingle(span);');
    lines.push('            }');
    lines.push('');
    lines.push('            public double ReadDouble()');
    lines.push('            {');
    lines.push('                var span = _data.Slice(_pos, 8);');
    lines.push('                _pos += 8;');
    lines.push('                return BitConverter.ToDouble(span);');
    lines.push('            }');
    lines.push('');
    lines.push('            /// <summary>');
    lines.push('            /// Read string using span-based UTF8 decode (zero temp byte[] allocation).');
    lines.push('            /// Only allocates the final string object.');
    lines.push('            /// </summary>');
    lines.push('            public string ReadString()');
    lines.push('            {');
    lines.push('                var len = (int)ReadVarint();');
    lines.push('                if (len == 0) return string.Empty;');
    lines.push('                // Zero-alloc path: decode directly from contiguous span');
    lines.push('                var span = _data.Slice(_pos, len);');
    lines.push('                _pos += len;');
    lines.push('                return Utf8.GetString(span);');
    lines.push('            }');
    lines.push('');
    lines.push('            /// <summary>');
    lines.push('            /// Read bytes field. Note: bytes fields inherently need array allocation');
    lines.push('            /// since the message field type is byte[].');
    lines.push('            /// </summary>');
    lines.push('            public byte[] ReadBytes()');
    lines.push('            {');
    lines.push('                var len = (int)ReadVarint();');
    lines.push('                if (len == 0) return Array.Empty<byte>();');
    lines.push('                var result = _data.Slice(_pos, len).ToArray();');
    lines.push('                _pos += len;');
    lines.push('                return result;');
    lines.push('            }');
    lines.push('');
    lines.push('            /// <summary>');
    lines.push('            /// Read length-delimited block length and return end position for packed repeated.');
    lines.push('            /// Use with ReadPackedInt32/etc for zero-copy packed repeated decode.');
    lines.push('            /// </summary>');
    lines.push('            public int ReadLengthDelimitedEnd()');
    lines.push('            {');
    lines.push('                var len = (int)ReadVarint();');
    lines.push('                return _pos + len;');
    lines.push('            }');
    lines.push('');
    lines.push('            public void Skip(int wireType)');
    lines.push('            {');
    lines.push('                switch (wireType)');
    lines.push('                {');
    lines.push('                    case 0: ReadVarint(); break;');
    lines.push('                    case 1: _pos += 8; break;');
    lines.push('                    case 2: _pos += (int)ReadVarint(); break;');
    lines.push('                    case 5: _pos += 4; break;');
    lines.push('                }');
    lines.push('            }');
    lines.push('        }');
}

function generateProtoWriter(lines) {
    lines.push('        /// <summary>');
    lines.push('        /// Protobuf wire format writer helper (IBufferWriter-based, zero-alloc)');
    lines.push('        /// </summary>');
    lines.push('        private static class ProtoWriter');
    lines.push('        {');
    lines.push('            public static void WriteVarint(IBufferWriter<byte> w, ulong value)');
    lines.push('            {');
    lines.push('                Span<byte> buf = stackalloc byte[10];');
    lines.push('                var i = 0;');
    lines.push('                while (value >= 0x80)');
    lines.push('                {');
    lines.push('                    buf[i++] = (byte)(value | 0x80);');
    lines.push('                    value >>= 7;');
    lines.push('                }');
    lines.push('                buf[i++] = (byte)value;');
    lines.push('                var span = w.GetSpan(i);');
    lines.push('                buf.Slice(0, i).CopyTo(span);');
    lines.push('                w.Advance(i);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteTag(IBufferWriter<byte> w, int tag, int wireType)');
    lines.push('            {');
    lines.push('                WriteVarint(w, (ulong)((tag << 3) | wireType));');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteString(IBufferWriter<byte> w, int tag, string? value)');
    lines.push('            {');
    lines.push('                if (string.IsNullOrEmpty(value)) return;');
    lines.push('                WriteTag(w, tag, 2);');
    lines.push('                var byteCount = Encoding.UTF8.GetByteCount(value);');
    lines.push('                WriteVarint(w, (ulong)byteCount);');
    lines.push('                if (byteCount <= 256)');
    lines.push('                {');
    lines.push('                    // Small string: write directly to span');
    lines.push('                    var span = w.GetSpan(byteCount);');
    lines.push('                    Encoding.UTF8.GetBytes(value.AsSpan(), span);');
    lines.push('                    w.Advance(byteCount);');
    lines.push('                }');
    lines.push('                else');
    lines.push('                {');
    lines.push('                    // Large string: use pooled buffer');
    lines.push('                    var rented = ArrayPool<byte>.Shared.Rent(byteCount);');
    lines.push('                    try');
    lines.push('                    {');
    lines.push('                        Encoding.UTF8.GetBytes(value.AsSpan(), rented.AsSpan(0, byteCount));');
    lines.push('                        var span = w.GetSpan(byteCount);');
    lines.push('                        rented.AsSpan(0, byteCount).CopyTo(span);');
    lines.push('                        w.Advance(byteCount);');
    lines.push('                    }');
    lines.push('                    finally');
    lines.push('                    {');
    lines.push('                        ArrayPool<byte>.Shared.Return(rented);');
    lines.push('                    }');
    lines.push('                }');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteInt32(IBufferWriter<byte> w, int tag, int value)');
    lines.push('            {');
    lines.push('                if (value == 0) return;');
    lines.push('                WriteTag(w, tag, 0);');
    lines.push('                WriteVarint(w, (ulong)value);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteInt64(IBufferWriter<byte> w, int tag, long value)');
    lines.push('            {');
    lines.push('                if (value == 0) return;');
    lines.push('                WriteTag(w, tag, 0);');
    lines.push('                WriteVarint(w, (ulong)value);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteBool(IBufferWriter<byte> w, int tag, bool value)');
    lines.push('            {');
    lines.push('                if (!value) return;');
    lines.push('                WriteTag(w, tag, 0);');
    lines.push('                var span = w.GetSpan(1);');
    lines.push('                span[0] = 1;');
    lines.push('                w.Advance(1);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteBytes(IBufferWriter<byte> w, int tag, byte[]? value)');
    lines.push('            {');
    lines.push('                if (value == null || value.Length == 0) return;');
    lines.push('                WriteTag(w, tag, 2);');
    lines.push('                WriteVarint(w, (ulong)value.Length);');
    lines.push('                var span = w.GetSpan(value.Length);');
    lines.push('                value.AsSpan().CopyTo(span);');
    lines.push('                w.Advance(value.Length);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteFloat(IBufferWriter<byte> w, int tag, float value)');
    lines.push('            {');
    lines.push('                if (value == 0) return;');
    lines.push('                WriteTag(w, tag, 5);');
    lines.push('                var span = w.GetSpan(4);');
    lines.push('                BitConverter.TryWriteBytes(span, value);');
    lines.push('                w.Advance(4);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteDouble(IBufferWriter<byte> w, int tag, double value)');
    lines.push('            {');
    lines.push('                if (value == 0) return;');
    lines.push('                WriteTag(w, tag, 1);');
    lines.push('                var span = w.GetSpan(8);');
    lines.push('                BitConverter.TryWriteBytes(span, value);');
    lines.push('                w.Advance(8);');
    lines.push('            }');
    lines.push('        }');
}

function generateMessageClass(lines, message) {
    const className = message.name;
    lines.push(`        /// <summary>${className} message</summary>`);
    lines.push(`        public sealed class ${className}`);
    lines.push('        {');

    // Properties
    for (const field of message.fields || []) {
        const csType = mapToCSharpType(field.type, field.optional);
        const propName = capitalize(field.name);
        lines.push(`            public ${csType} ${propName} { get; set; }${getDefaultValue(field.type, field.optional)}`);
    }

    // _Reset method for pooling
    lines.push('');
    lines.push('            internal void _Reset()');
    lines.push('            {');
    for (const field of message.fields || []) {
        const propName = capitalize(field.name);
        // List<T>? fields: use Clear() instead of null assignment
        if (field.type.endsWith('[]')) {
            lines.push(`                if (${propName} != null) ${propName}.Clear();`);
        } else {
            const resetValue = getResetValue(field.type, field.optional);
            lines.push(`                ${propName} = ${resetValue};`);
        }
    }
    lines.push('            }');

    lines.push('        }');
}

function generateOpcodesClass(lines, messages, protocolName) {
    lines.push('        /// <summary>Opcode constants</summary>');
    lines.push('        public static class Opcodes');
    lines.push('        {');
    for (const msg of messages) {
        lines.push(`            public const int ${msg.name} = ${msg.opcode};`);
    }
    lines.push('');
    lines.push('            public static string? GetName(int opcode) => opcode switch');
    lines.push('            {');
    for (const msg of messages) {
        lines.push(`                ${msg.opcode} => nameof(${msg.name}),`);
    }
    lines.push('                _ => null');
    lines.push('            };');
    lines.push('        }');
}

function generateICodec(lines, protocolName) {
    lines.push('        /// <summary>Codec interface</summary>');
    lines.push('        public interface ICodec');
    lines.push('        {');
    lines.push('            /// <summary>Encode to byte array (legacy, avoid in hot path)</summary>');
    lines.push('            byte[] Encode<T>(T message) where T : class;');
    lines.push('            /// <summary>Encode directly to IBufferWriter (zero-alloc send path)</summary>');
    lines.push('            void EncodeTo<T>(IBufferWriter<byte> writer, T message) where T : class;');
    lines.push('            T Decode<T>(ReadOnlySpan<byte> data) where T : class, new();');
    lines.push('            object? Decode(int opcode, ReadOnlySpan<byte> data);');
    lines.push('        }');
}

function generateCodecJson(lines, messages, protocolName) {
    lines.push('        /// <summary>JSON Codec implementation using Newtonsoft.Json</summary>');
    lines.push('        public sealed class CodecJson : ICodec');
    lines.push('        {');
    lines.push('            public byte[] Encode<T>(T message) where T : class');
    lines.push('            {');
    lines.push('                var json = JsonConvert.SerializeObject(message);');
    lines.push('                return Encoding.UTF8.GetBytes(json);');
    lines.push('            }');
    lines.push('');
    lines.push('            public void EncodeTo<T>(IBufferWriter<byte> writer, T message) where T : class');
    lines.push('            {');
    lines.push('                var json = JsonConvert.SerializeObject(message);');
    lines.push('                var byteCount = Encoding.UTF8.GetByteCount(json);');
    lines.push('                var span = writer.GetSpan(byteCount);');
    lines.push('                Encoding.UTF8.GetBytes(json.AsSpan(), span);');
    lines.push('                writer.Advance(byteCount);');
    lines.push('            }');
    lines.push('');
    lines.push('            public T Decode<T>(ReadOnlySpan<byte> data) where T : class, new()');
    lines.push('            {');
    lines.push('                var json = Encoding.UTF8.GetString(data);');
    lines.push('                return JsonConvert.DeserializeObject<T>(json) ?? new T();');
    lines.push('            }');
    lines.push('');
    lines.push('            public object? Decode(int opcode, ReadOnlySpan<byte> data)');
    lines.push('            {');
    lines.push('                return opcode switch');
    lines.push('                {');
    for (const msg of messages) {
        lines.push(`                    Opcodes.${msg.name} => Decode<${msg.name}>(data),`);
    }
    lines.push('                    _ => null');
    lines.push('                };');
    lines.push('            }');
    lines.push('        }');
}

function generateCodecProtobuf(lines, messages, protocolName, usesComplexAliases = false) {
    lines.push('        /// <summary>Protobuf Codec implementation</summary>');
    lines.push('        public sealed class CodecProtobuf : ICodec');
    lines.push('        {');

    // Encode (legacy, uses EncodeTo internally)
    lines.push('            public byte[] Encode<T>(T message) where T : class');
    lines.push('            {');
    if (usesComplexAliases) {
        lines.push('                throw new NotSupportedException("cint/cfloat/cstring is not supported in protobuf codec; use CodecJson.");');
    } else {
        lines.push('                // Legacy path: uses PooledBufferWriter then copies to byte[]');
        lines.push('                using var bw = new PooledBufferWriter(256);');
        lines.push('                EncodeTo(bw, message);');
        lines.push('                return bw.WrittenSpan.ToArray();');
    }
    lines.push('            }');
    lines.push('');

    // EncodeTo (zero-alloc path)
    lines.push('            public void EncodeTo<T>(IBufferWriter<byte> writer, T message) where T : class');
    lines.push('            {');
    if (usesComplexAliases) {
        lines.push('                throw new NotSupportedException("cint/cfloat/cstring is not supported in protobuf codec; use CodecJson.");');
    } else {
        lines.push('                switch (message)');
        lines.push('                {');
        for (const msg of messages) {
            lines.push(`                    case ${msg.name} m: Encode${msg.name}(writer, m); break;`);
        }
        lines.push('                    default: throw new ArgumentException($"Unknown message type: {typeof(T).Name}");');
        lines.push('                }');
    }
    lines.push('            }');
    lines.push('');

    // Decode<T>
    lines.push('            public T Decode<T>(ReadOnlySpan<byte> data) where T : class, new()');
    lines.push('            {');
    if (usesComplexAliases) {
        lines.push('                throw new NotSupportedException("cint/cfloat/cstring is not supported in protobuf codec; use CodecJson.");');
    } else {
        lines.push('                var result = new T();');
        lines.push('                switch (result)');
        lines.push('                {');
        for (const msg of messages) {
            lines.push(`                    case ${msg.name} m: Decode${msg.name}(data, m); break;`);
        }
        lines.push('                }');
        lines.push('                return result;');
    }
    lines.push('            }');
    lines.push('');

    // Decode by opcode
    lines.push('            public object? Decode(int opcode, ReadOnlySpan<byte> data)');
    lines.push('            {');
    if (usesComplexAliases) {
        lines.push('                throw new NotSupportedException("cint/cfloat/cstring is not supported in protobuf codec; use CodecJson.");');
    } else {
        lines.push('                return opcode switch');
        lines.push('                {');
        for (const msg of messages) {
            lines.push(`                    Opcodes.${msg.name} => Decode<${msg.name}>(data),`);
        }
        lines.push('                    _ => null');
        lines.push('                };');
    }
    lines.push('            }');
    lines.push('');

    // Per-message encode/decode methods only if no complex aliases
    if (!usesComplexAliases) {
        // Per-message encode methods
        for (const msg of messages) {
            generateEncodeMethod(lines, msg);
            lines.push('');
        }

        // Per-message decode methods
        for (const msg of messages) {
            generateDecodeMethod(lines, msg);
            lines.push('');
        }
    }

    lines.push('        }');
}

function generateEncodeMethod(lines, message) {
    lines.push(`            private static void Encode${message.name}(IBufferWriter<byte> writer, ${message.name} m)`);
    lines.push('            {');
    for (const field of message.fields || []) {
        const tag = field.tag;
        const propName = capitalize(field.name);
        const writeMethod = getWriteMethod(field.type);

        if (field.type.endsWith('[]')) {
            // Array handling
            const baseType = field.type.slice(0, -2);
            lines.push(`                if (m.${propName} != null)`);
            lines.push('                {');
            lines.push(`                    foreach (var item in m.${propName})`);
            lines.push('                    {');
            lines.push(`                        ${getArrayWriteCall(baseType, tag)}`);
            lines.push('                    }');
            lines.push('                }');
        } else if (writeMethod) {
            lines.push(`                ProtoWriter.${writeMethod}(writer, ${tag}, m.${propName});`);
        }
    }
    lines.push('            }');
}

function generateDecodeMethod(lines, message) {
    // internal static to allow access from pooling API
    lines.push(`            internal static void Decode${message.name}(ReadOnlySpan<byte> data, ${message.name} m)`);
    lines.push('            {');

    // Check if message has any array fields - need to clear them before decode
    const arrayFields = (message.fields || []).filter(f => f.type.endsWith('[]'));
    if (arrayFields.length > 0) {
        lines.push('                // Clear collections before decode (reuse pattern - no new List allocation)');
        for (const field of arrayFields) {
            const propName = capitalize(field.name);
            lines.push(`                m.${propName}?.Clear();`);
        }
        lines.push('');
    }

    lines.push('                var reader = new ProtoReader(data);');
    lines.push('                while (reader.HasMore)');
    lines.push('                {');
    lines.push('                    var (tag, wireType) = reader.ReadTag();');
    lines.push('                    switch (tag)');
    lines.push('                    {');

    for (const field of message.fields || []) {
        const tag = field.tag;
        const propName = capitalize(field.name);
        const readCall = getReadCall(field.type);

        if (field.type.endsWith('[]')) {
            const baseType = field.type.slice(0, -2);
            lines.push(`                        case ${tag}:`);
            // Only create list if null (first decode), never replace existing list
            lines.push(`                            (m.${propName} ??= new List<${mapToCSharpBaseType(baseType)}>()).Add(${getArrayReadCall(baseType)});`);
            lines.push('                            break;');
        } else if (readCall) {
            lines.push(`                        case ${tag}: m.${propName} = ${readCall}; break;`);
        }
    }

    lines.push('                        default: reader.Skip(wireType); break;');
    lines.push('                    }');
    lines.push('                }');
    lines.push('            }');
}

function generateISender(lines) {
    lines.push('        /// <summary>Sender interface for Proxy</summary>');
    lines.push('        public interface ISender');
    lines.push('        {');
    lines.push('            void SendTo(ReadOnlySpan<byte> frame);');
    lines.push('        }');
}

function generateStub(lines, messages, protocolName, usesComplexAliases = false) {
    const defaultCodec = usesComplexAliases ? 'CodecJson' : 'CodecProtobuf';
    lines.push('        /// <summary>');
    lines.push(`        /// Abstract stub for ${protocolName} handlers.`);
    lines.push('        /// Inherit and implement all On* methods.');
    lines.push('        /// </summary>');
    lines.push('        public abstract class Stub');
    lines.push('        {');
    lines.push('            protected ICodec Codec { get; }');
    lines.push('');
    lines.push('            protected Stub(ICodec? codec = null)');
    lines.push('            {');
    lines.push(`                Codec = codec ?? new ${defaultCodec}();`);
    lines.push('            }');
    lines.push('');

    // Dispatch method
    lines.push('            public void Dispatch(PacketEnvelope envelope)');
    lines.push('            {');
    lines.push('                switch (envelope.Opcode)');
    lines.push('                {');
    for (const msg of messages) {
        lines.push(`                    case Opcodes.${msg.name}:`);
        lines.push(`                        var ${lowerFirst(msg.name)} = Codec.Decode<${msg.name}>(envelope.Payload);`);
        lines.push(`                        On${msg.name}(envelope.Meta, ${lowerFirst(msg.name)});`);
        lines.push('                        break;');
    }
    lines.push('                }');
    lines.push('            }');
    lines.push('');

    // Abstract handler methods
    for (const msg of messages) {
        lines.push(`            protected abstract void On${msg.name}(EnvelopeMeta meta, ${msg.name} message);`);
    }

    lines.push('        }');
}

function generateRuntimeAdapter(lines, messages, protocolName, usesComplexAliases = false) {
    lines.push('        /// <summary>');
    lines.push(`        /// Runtime adapter implementing INetRuntime for ${protocolName}.`);
    lines.push('        /// Bridges NetClient and generated Stub.');
    lines.push('        /// </summary>');
    lines.push('        public sealed class Runtime : Devian.INetRuntime');
    lines.push('        {');
    lines.push('            private readonly Stub _stub;');
    lines.push('');
    lines.push('            public Runtime(Stub stub)');
    lines.push('            {');
    lines.push('                _stub = stub ?? throw new ArgumentNullException(nameof(stub));');
    lines.push('            }');
    lines.push('');
    lines.push('            /// <summary>');
    lines.push('            /// Try to dispatch inbound packet. Returns true if opcode belongs to this protocol.');
    lines.push('            /// </summary>');
    lines.push('            public bool TryDispatchInbound(int sessionId, int opcode, ReadOnlySpan<byte> payload)');
    lines.push('            {');

    if (messages.length === 0) {
        // No messages - always return false
        lines.push('                return false;');
    } else {
        lines.push('                switch (opcode)');
        lines.push('                {');
        // Generate case labels for all opcodes
        for (const msg of messages) {
            lines.push(`                    case Opcodes.${msg.name}:`);
        }
        // Shared block for all cases
        lines.push('                    {');
        lines.push('                        var meta = new EnvelopeMeta(sessionId);');
        lines.push('                        var envelope = new PacketEnvelope(opcode, payload, meta);');
        lines.push('                        _stub.Dispatch(envelope);');
        lines.push('                        return true;');
        lines.push('                    }');
        lines.push('                    default:');
        lines.push('                        return false;');
        lines.push('                }');
    }

    lines.push('            }');
    lines.push('        }');
}

/**
 * Get the paired inbound protocol name for a given outbound protocol.
 * Mapping: C2{X} ↔ {X}2C
 * Examples: C2Game → Game2C, Game2C → C2Game
 */
function getInboundProtocolName(outboundProtocolName) {
    // Pattern: C2{GroupName} → {GroupName}2C
    if (outboundProtocolName.startsWith('C2')) {
        const groupName = outboundProtocolName.slice(2); // Remove 'C2' prefix
        return `${groupName}2C`;
    }
    // Pattern: {GroupName}2C → C2{GroupName}
    if (outboundProtocolName.endsWith('2C')) {
        const groupName = outboundProtocolName.slice(0, -2); // Remove '2C' suffix
        return `C2${groupName}`;
    }
    // Fallback: same protocol (bidirectional or unknown pattern)
    return outboundProtocolName;
}

function generateProxy(lines, messages, protocolName, usesComplexAliases = false) {
    const defaultCodec = usesComplexAliases ? 'CodecJson' : 'CodecProtobuf';
    const inboundProtocolName = getInboundProtocolName(protocolName);

    lines.push('        /// <summary>');
    lines.push(`        /// Proxy for sending ${protocolName} messages.`);
    lines.push('        /// Uses INetSession/INetConnector for protocol-agnostic session management.');
    lines.push(`        /// Inbound dispatch uses ${inboundProtocolName}.Runtime.`);
    lines.push('        /// </summary>');
    lines.push('        public sealed class Proxy : IDisposable');
    lines.push('        {');
    lines.push('            // ======== Session (interface-based, no concrete types) ========');
    lines.push('            private INetSession? _session;');
    lines.push('            private string _url = string.Empty;');
    lines.push('            private string _lastError = string.Empty;');
    lines.push('            private volatile bool _isConnecting; // Re-entry guard flag');
    lines.push('            private bool _errorNotified; // Error dedup guard (max 1 OnError per attempt)');
    lines.push('');
    lines.push('            // ======== Codec ========');
    lines.push('            private readonly ICodec _codec;');
    lines.push('');
    lines.push('            // ======== Events ========');
    lines.push('            public event Action? OnOpen;');
    lines.push('            public event Action<ushort, string>? OnClose;');
    lines.push('            public event Action<Exception>? OnError;');
    lines.push('');
    lines.push('            // ======== Properties ========');
    lines.push('            public bool IsConnected => _session?.State == NetClientState.Connected;');
    lines.push('            public bool IsConnecting => _isConnecting;');
    lines.push('            public string Url => _url;');
    lines.push('            public string LastError => _lastError;');
    lines.push('');
    lines.push('            // ======== Constructor ========');
    lines.push('            public Proxy(ICodec? codec = null)');
    lines.push('            {');
    lines.push(`                _codec = codec ?? new ${defaultCodec}();`);
    lines.push('            }');
    lines.push('');
    lines.push('            // ======== Connection Lifecycle API ========');
    lines.push('');
    lines.push('            /// <summary>');
    lines.push('            /// Connect to server using the provided connector.');
    lines.push('            /// Previous session is always disposed before creating a new one.');
    lines.push(`            /// Stub must be ${inboundProtocolName}.Stub for inbound message dispatch.`);
    lines.push('            /// </summary>');
    lines.push(`            public void Connect(${inboundProtocolName}.Stub stub, string url, INetConnector connector)`);
    lines.push('            {');
    lines.push('                if (stub == null) throw new ArgumentNullException(nameof(stub));');
    lines.push('                if (string.IsNullOrEmpty(url)) throw new ArgumentException("url is empty", nameof(url));');
    lines.push('                if (connector == null) throw new ArgumentNullException(nameof(connector));');
    lines.push('');
    lines.push('                // Always dispose previous session to prevent stale event handler leaks.');
    lines.push('                // Without this, prior session continuations can fire HandleError on the');
    lines.push('                // current Proxy after a new session is already created.');
    lines.push('                if (_session != null)');
    lines.push('                    DisposeConnection();');
    lines.push('');
    lines.push('                _url = url;');
    lines.push('                _lastError = string.Empty;');
    lines.push('                _isConnecting = true; // Set before session creation to prevent re-entry');
    lines.push('                _errorNotified = false; // Reset error dedup guard for new attempt');
    lines.push('');
    lines.push(`                // Inbound dispatch runtime (${inboundProtocolName})`);
    lines.push(`                var runtime = new ${inboundProtocolName}.Runtime(stub);`);
    lines.push('');
    lines.push('                // Create session via connector (no concrete types here)');
    lines.push('                var session = connector.CreateSession(runtime, url);');
    lines.push('                session.OnOpen += HandleOpen;');
    lines.push('                session.OnClose += HandleClose;');
    lines.push('                session.OnError += HandleError;');
    lines.push('');
    lines.push('                _session = session;');
    lines.push('                _ = session.ConnectAsync().ContinueWith(t => { var ex = t.Exception; }, System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted | System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously);');
    lines.push('            }');
    lines.push('');
    lines.push('            /// <summary>');
    lines.push('            /// Process network events. Call from Update() loop.');
    lines.push('            /// </summary>');
    lines.push('            public void Tick()');
    lines.push('            {');
    lines.push('                _session?.Tick();');
    lines.push('            }');
    lines.push('');
    lines.push('            /// <summary>');
    lines.push('            /// Request graceful disconnect.');
    lines.push('            /// </summary>');
    lines.push('            public void Disconnect()');
    lines.push('            {');
    lines.push('                if (_session == null) return;');
    lines.push('                _ = _session.CloseAsync();');
    lines.push('            }');
    lines.push('');
    lines.push('            /// <summary>');
    lines.push('            /// Dispose connection resources.');
    lines.push('            /// </summary>');
    lines.push('            public void Dispose()');
    lines.push('            {');
    lines.push('                DisposeConnection();');
    lines.push('            }');
    lines.push('');
    lines.push('            private void DisposeConnection()');
    lines.push('            {');
    lines.push('                _isConnecting = false; // Clear flag first');
    lines.push('                _errorNotified = false; // Reset error dedup guard');
    lines.push('');
    lines.push('                var s = _session;');
    lines.push('                if (s == null) return;');
    lines.push('');
    lines.push('                s.OnOpen -= HandleOpen;');
    lines.push('                s.OnClose -= HandleClose;');
    lines.push('                s.OnError -= HandleError;');
    lines.push('');
    lines.push('                if (s is IDisposable d) d.Dispose();');
    lines.push('                _session = null;');
    lines.push('            }');
    lines.push('');
    lines.push('            // ======== Internal Event Handlers ========');
    lines.push('');
    lines.push('            private void HandleOpen()');
    lines.push('            {');
    lines.push('                _isConnecting = false;');
    lines.push('                _errorNotified = false; // Reset for connected state');
    lines.push('                OnOpen?.Invoke();');
    lines.push('            }');
    lines.push('');
    lines.push('            private void HandleClose(ushort code, string reason)');
    lines.push('            {');
    lines.push('                _isConnecting = false;');
    lines.push('                OnClose?.Invoke(code, reason);');
    lines.push('            }');
    lines.push('');
    lines.push('            private void HandleError(Exception ex)');
    lines.push('            {');
    lines.push('                _isConnecting = false;');
    lines.push('                _lastError = ex.Message;');
    lines.push('                if (_errorNotified)');
    lines.push('                    return;');
    lines.push('                _errorNotified = true;');
    lines.push('                OnError?.Invoke(ex);');
    lines.push('            }');
    lines.push('');
    lines.push('            // ======== Session Attachment (for WsClient shared session) ========');
    lines.push('');
    lines.push('            /// <summary>');
    lines.push('            /// Attach an externally created session for sending.');
    lines.push('            /// Used by WsClient to share a single session across protocols.');
    lines.push('            /// </summary>');
    lines.push('            public void AttachSession(INetSession session)');
    lines.push('            {');
    lines.push('                _session = session ?? throw new ArgumentNullException(nameof(session));');
    lines.push('            }');
    lines.push('');
    lines.push('            // ======== Send Methods ========');
    lines.push('            // Uses PooledBufferWriter + EncodeTo for zero GC allocation.');
    lines.push('            // Frame format: [opcode:int32LE][payload...]');
    lines.push('');

    for (const msg of messages) {
        lines.push(`            public void Send${msg.name}(${msg.name} message)`);
        lines.push('            {');
        lines.push('                var session = _session ?? throw new InvalidOperationException("Proxy is not connected. Call Connect() or AttachSession() first.");');
        lines.push('');
        lines.push('                using var bw = new PooledBufferWriter(256);');
        lines.push('');
        lines.push('                // Write opcode (4 bytes LE)');
        lines.push('                var span = bw.GetSpan(4);');
        lines.push(`                BitConverter.TryWriteBytes(span, Opcodes.${msg.name});`);
        lines.push('                bw.Advance(4);');
        lines.push('');
        lines.push('                // Encode payload directly to buffer');
        lines.push('                _codec.EncodeTo(bw, message);');
        lines.push('');
        lines.push('                // Send frame');
        lines.push('                session.SendTo(bw.WrittenSpan);');
        lines.push('            }');
        lines.push('');
    }

    lines.push('        }');
}

// ============================================================================
// Type Mapping Utilities
// ============================================================================

function mapToCSharpType(type, optional = false) {
    const baseType = type.endsWith('[]') ? type.slice(0, -2) : type;
    const isArray = type.endsWith('[]');
    
    let csType = mapToCSharpBaseType(baseType);
    
    if (isArray) {
        csType = `List<${csType}>?`;
    } else if (optional && !isValueType(baseType)) {
        csType = `${csType}?`;
    }
    
    return csType;
}

function mapToCSharpBaseType(type) {
    // Handle map<K,V> type
    const mapMatch = type.match(/^map<\s*(\w+)\s*,\s*(\w+)\s*>$/);
    if (mapMatch) {
        const keyType = mapToCSharpBaseType(mapMatch[1]);
        const valueType = mapToCSharpBaseType(mapMatch[2]);
        return `Dictionary<${keyType}, ${valueType}>`;
    }

    // Complex alias mapping (priority)
    const aliasType = mapComplexAlias(type);
    if (aliasType) {
        return aliasType;
    }

    const typeMap = {
        'int32': 'int',
        'int64': 'long',
        'uint32': 'uint',
        'uint64': 'ulong',
        'sint32': 'int',
        'sint64': 'long',
        'float': 'float',
        'double': 'double',
        'bool': 'bool',
        'string': 'string',
        'bytes': 'byte[]',
    };
    return typeMap[type] || type;
}

function isValueType(type) {
    // Complex aliases (CInt, CFloat, CString are all structs)
    if (isComplexAlias(type)) {
        return true;
    }
    return ['int32', 'int64', 'uint32', 'uint64', 'sint32', 'sint64', 'float', 'double', 'bool'].includes(type);
}

function getDefaultValue(type, optional) {
    if (type.endsWith('[]')) return '';
    if (type === 'string') return ' = string.Empty;';
    if (type === 'bytes') return ' = Array.Empty<byte>();';
    return '';
}

function getResetValue(type, optional) {
    if (type.endsWith('[]')) return 'null';
    if (type === 'string') return 'string.Empty';
    if (type === 'bytes') return 'Array.Empty<byte>()';
    if (isValueType(type.replace('[]', ''))) return 'default';
    return 'null!';
}

function getWriteMethod(type) {
    if (type.endsWith('[]')) return null; // Handled separately
    const methodMap = {
        'int32': 'WriteInt32',
        'int64': 'WriteInt64',
        'uint32': 'WriteInt32',
        'uint64': 'WriteInt64',
        'bool': 'WriteBool',
        'string': 'WriteString',
        'bytes': 'WriteBytes',
        'float': 'WriteFloat',
        'double': 'WriteDouble',
    };
    return methodMap[type];
}

function getReadCall(type) {
    if (type.endsWith('[]')) return null; // Handled separately
    const readMap = {
        'int32': 'reader.ReadInt32()',
        'int64': 'reader.ReadInt64()',
        'uint32': 'reader.ReadUInt32()',
        'uint64': 'reader.ReadUInt64()',
        'sint32': 'reader.ReadSInt32()',
        'sint64': 'reader.ReadSInt64()',
        'bool': 'reader.ReadBool()',
        'string': 'reader.ReadString()',
        'bytes': 'reader.ReadBytes()',
        'float': 'reader.ReadFloat()',
        'double': 'reader.ReadDouble()',
    };
    return readMap[type];
}

function getArrayWriteCall(baseType, tag) {
    const writeMap = {
        'int32': `ProtoWriter.WriteInt32(writer, ${tag}, item);`,
        'int64': `ProtoWriter.WriteInt64(writer, ${tag}, item);`,
        'bool': `ProtoWriter.WriteBool(writer, ${tag}, item);`,
        'string': `ProtoWriter.WriteString(writer, ${tag}, item);`,
    };
    return writeMap[baseType] || `// TODO: ${baseType}[]`;
}

function getArrayReadCall(baseType) {
    const readMap = {
        'int32': 'reader.ReadInt32()',
        'int64': 'reader.ReadInt64()',
        'bool': 'reader.ReadBool()',
        'string': 'reader.ReadString()',
    };
    return readMap[baseType] || 'default';
}

function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function lowerFirst(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
}

// ============================================================================
// Pooling API Generator
// ============================================================================

function generatePoolingApi(lines, messages) {
    lines.push('        // ============================================================================');
    lines.push('        // Pooling API - RentDecodePooled / ReturnPooled');
    lines.push('        // SSOT: skills/devian-builder/40-codegen-protocol/SKILL.md');
    lines.push('        // ============================================================================');
    lines.push('');

    // Pool fields (one per message type, max=256)
    for (const msg of messages) {
        lines.push(`        private static readonly PacketPool<${msg.name}> _pool_${msg.name} = new PacketPool<${msg.name}>(256);`);
    }
    lines.push('');

    // RentDecodePooled(int opcode, ReadOnlySpan<byte> data)
    lines.push('        /// <summary>');
    lines.push('        /// Rent a pooled message object and decode from data.');
    lines.push('        /// Call ReturnPooled() when done to return the object to the pool.');
    lines.push('        /// </summary>');
    lines.push('        public static object? RentDecodePooled(int opcode, ReadOnlySpan<byte> data)');
    lines.push('        {');
    lines.push('            switch (opcode)');
    lines.push('            {');
    for (const msg of messages) {
        lines.push(`                case Opcodes.${msg.name}:`);
        lines.push('                {');
        lines.push(`                    var m = _pool_${msg.name}.Rent();`);
        lines.push('                    m._Reset();');
        lines.push(`                    CodecProtobuf.Decode${msg.name}(data, m);`);
        lines.push('                    return m;');
        lines.push('                }');
    }
    lines.push('                default:');
    lines.push('                    return null;');
    lines.push('            }');
    lines.push('        }');
    lines.push('');

    // RentDecodePooled<T>(ReadOnlySpan<byte> data)
    lines.push('        /// <summary>');
    lines.push('        /// Rent a pooled message object of type T and decode from data.');
    lines.push('        /// Call ReturnPooled() when done to return the object to the pool.');
    lines.push('        /// </summary>');
    lines.push('        public static T RentDecodePooled<T>(ReadOnlySpan<byte> data) where T : class, new()');
    lines.push('        {');
    lines.push('            object pooled;');
    // Generate type checks using typeof(T) == typeof(Foo) pattern
    for (let i = 0; i < messages.length; i++) {
        const msg = messages[i];
        const prefix = i === 0 ? 'if' : 'else if';
        lines.push(`            ${prefix} (typeof(T) == typeof(${msg.name}))`);
        lines.push('            {');
        lines.push(`                var m = _pool_${msg.name}.Rent();`);
        lines.push('                m._Reset();');
        lines.push(`                CodecProtobuf.Decode${msg.name}(data, m);`);
        lines.push('                pooled = m;');
        lines.push('            }');
    }
    lines.push('            else');
    lines.push('            {');
    lines.push('                // Fallback: create new instance (not pooled)');
    lines.push('                var codec = new CodecProtobuf();');
    lines.push('                return codec.Decode<T>(data);');
    lines.push('            }');
    lines.push('            return (T)pooled;');
    lines.push('        }');
    lines.push('');

    // ReturnPooled(object message)
    lines.push('        /// <summary>');
    lines.push('        /// Return a pooled message object to the pool.');
    lines.push('        /// The object will be reset before being returned.');
    lines.push('        /// </summary>');
    lines.push('        public static void ReturnPooled(object message)');
    lines.push('        {');
    lines.push('            switch (message)');
    lines.push('            {');
    for (const msg of messages) {
        lines.push(`                case ${msg.name} m:`);
        lines.push('                    m._Reset();');
        lines.push(`                    _pool_${msg.name}.Return(m);`);
        lines.push('                    break;');
    }
    lines.push('                default:');
    lines.push('                    // Unknown type - silently ignore (no crash for user error)');
    lines.push('                    break;');
    lines.push('            }');
    lines.push('        }');
    lines.push('');

    // ReturnPooled<T>(T message)
    lines.push('        /// <summary>');
    lines.push('        /// Return a pooled message object of type T to the pool.');
    lines.push('        /// </summary>');
    lines.push('        public static void ReturnPooled<T>(T message) where T : class');
    lines.push('        {');
    lines.push('            if (message == null) return;');
    lines.push('            ReturnPooled((object)message);');
    lines.push('        }');
}

// ============================================================================
// Handlers Generator
// ============================================================================

/**
 * Generate C# Handlers class from protocol spec
 * @param {Object} spec - Protocol specification
 * @param {string} protocolName - Protocol name (e.g., "C2Game")
 * @param {string} groupName - Protocol group name (e.g., "Game")
 * @returns {string} Generated C# code
 */
export function generateCSharpProtocolHandlers(spec, protocolName, groupName) {
    const lines = [];
    const messages = spec.messages || [];

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push('// Handlers partial class for easy implementation.');
    lines.push('// Developers: create a separate file with partial class and implement On*Impl methods.');
    lines.push('// </auto-generated>');
    lines.push('');
    lines.push('#nullable enable');
    lines.push('');

    // Namespace
    lines.push(`namespace Devian.Protocol.${groupName}`);
    lines.push('{');

    // Class: public sealed partial class {ProtocolName}_Handlers : {ProtocolName}.Stub
    lines.push('    /// <summary>');
    lines.push(`    /// Handlers for ${protocolName} messages.`);
    lines.push('    /// Inherit from Stub and delegate each On* to partial On*Impl methods.');
    lines.push('    /// Developers implement On*Impl in a separate partial file.');
    lines.push('    /// </summary>');
    lines.push(`    public sealed partial class ${protocolName}_Handlers : ${protocolName}.Stub`);
    lines.push('    {');

    // Constructor
    lines.push(`        public ${protocolName}_Handlers(${protocolName}.ICodec? codec = null) : base(codec) { }`);
    lines.push('');

    // Override methods that delegate to partial impl
    for (const msg of messages) {
        lines.push(`        protected override void On${msg.name}(${protocolName}.EnvelopeMeta meta, ${protocolName}.${msg.name} message) => On${msg.name}Impl(meta, message);`);
    }

    if (messages.length > 0) {
        lines.push('');
    }

    // Partial method declarations
    for (const msg of messages) {
        lines.push(`        partial void On${msg.name}Impl(${protocolName}.EnvelopeMeta meta, ${protocolName}.${msg.name} message);`);
    }

    lines.push('    }');
    lines.push('}');

    return lines.join('\n');
}

// ============================================================================
// Group WsClient Generator
// ============================================================================

/**
 * Generate C# WsClient class for a protocol group
 * @param {string} groupName - Protocol group name (e.g., "Game")
 * @param {Array} protocolInfos - Array of { name, direction, spec }
 * @returns {string|null} Generated C# code or null if no protocols
 */
export function generateCSharpProtocolGroupWsClient(groupName, protocolInfos) {
    if (!protocolInfos || protocolInfos.length === 0) return null;

    // Separate inbound (server_to_client, bidirectional) and outbound (client_to_server, bidirectional)
    const inboundProtos = protocolInfos.filter(p =>
        p.direction === 'server_to_client' || p.direction === 'bidirectional'
    );
    const outboundProtos = protocolInfos.filter(p =>
        p.direction === 'client_to_server' || p.direction === 'bidirectional'
    );

    // If no inbound and no outbound, skip generation
    if (inboundProtos.length === 0 && outboundProtos.length === 0) return null;

    const lines = [];

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push(`// ${groupName}WsClient: WebSocket client binding for ${groupName} protocol group.`);
    lines.push('// ');
    lines.push('// Usage:');
    lines.push('//   var client = new GameWsClient();');
    lines.push('//   client.Connect("wss://...");');
    lines.push('//   // Implement handlers via partial class');
    lines.push('//   // Send messages via client.C2GameProxy.SendXxx(...)');
    lines.push('//   // Call client.Tick() each frame');
    lines.push('// </auto-generated>');
    lines.push('');
    lines.push('#nullable enable');
    lines.push('');
    lines.push('using System;');
    lines.push('using Devian;');
    lines.push('');

    // Namespace
    lines.push(`namespace Devian.Protocol.${groupName}`);
    lines.push('{');

    // Class
    lines.push('    /// <summary>');
    lines.push(`    /// WebSocket client for ${groupName} protocol group.`);
    lines.push('    /// Uses INetSession/INetConnector for protocol-agnostic session management.');
    lines.push('    /// Implements INetTickable for unified tick management.');
    lines.push('    /// </summary>');
    lines.push(`    public sealed class ${groupName}WsClient : INetTickable, IDisposable`);
    lines.push('    {');

    // ======== Inbound: Handlers properties ========
    if (inboundProtos.length > 0) {
        lines.push('        // ======== Inbound Handlers ========');
        for (const proto of inboundProtos) {
            lines.push(`        public ${proto.name}_Handlers ${proto.name}Handlers { get; }`);
        }
        lines.push('');
    }

    // ======== Outbound: Proxy properties ========
    if (outboundProtos.length > 0) {
        lines.push('        // ======== Outbound Proxies ========');
        for (const proto of outboundProtos) {
            lines.push(`        public ${proto.name}.Proxy ${proto.name}Proxy { get; }`);
        }
        lines.push('');
    }

    // ======== Session infrastructure ========
    lines.push('        // ======== Session Infrastructure ========');
    lines.push('        private INetSession? _session;');
    lines.push('        private readonly INetConnector _connector;');
    lines.push('        private string _url = string.Empty;');
    lines.push('        private string _lastError = string.Empty;');
    lines.push('');

    // ======== RuntimeMux (private nested class) ========
    lines.push('        // ======== Runtime Multiplexer ========');
    lines.push('        private sealed class RuntimeMux : INetRuntime');
    lines.push('        {');
    if (inboundProtos.length > 0) {
        for (const proto of inboundProtos) {
            lines.push(`            private readonly ${proto.name}.Runtime _${lowerFirst(proto.name)}Runtime;`);
        }
        lines.push('');
        lines.push('            public RuntimeMux(');
        const runtimeParams = inboundProtos.map(p => `${p.name}.Runtime ${lowerFirst(p.name)}Runtime`);
        lines.push(`                ${runtimeParams.join(',\n                ')}`);
        lines.push('            )');
        lines.push('            {');
        for (const proto of inboundProtos) {
            lines.push(`                _${lowerFirst(proto.name)}Runtime = ${lowerFirst(proto.name)}Runtime;`);
        }
        lines.push('            }');
    } else {
        lines.push('            public RuntimeMux() { }');
    }
    lines.push('');
    lines.push('            public bool TryDispatchInbound(int sessionId, int opcode, ReadOnlySpan<byte> payload)');
    lines.push('            {');
    if (inboundProtos.length > 0) {
        for (const proto of inboundProtos) {
            lines.push(`                if (_${lowerFirst(proto.name)}Runtime.TryDispatchInbound(sessionId, opcode, payload)) return true;`);
        }
    }
    lines.push('                return false;');
    lines.push('            }');
    lines.push('        }');
    lines.push('');

    // ======== Constructor ========
    lines.push('        // ======== Constructor ========');
    lines.push(`        public ${groupName}WsClient(INetConnector? connector = null)`);
    lines.push('        {');

    // Create handlers
    if (inboundProtos.length > 0) {
        lines.push('            // Create handlers');
        for (const proto of inboundProtos) {
            lines.push(`            ${proto.name}Handlers = new ${proto.name}_Handlers();`);
        }
        lines.push('');
    }

    // Create proxies
    if (outboundProtos.length > 0) {
        lines.push('            // Create proxies');
        for (const proto of outboundProtos) {
            lines.push(`            ${proto.name}Proxy = new ${proto.name}.Proxy();`);
        }
        lines.push('');
    }

    // Store connector
    lines.push('            // Use provided connector or create default');
    lines.push('            _connector = connector ?? new NetWsConnector();');

    lines.push('        }');
    lines.push('');

    // ======== Public API ========
    lines.push('        // ======== Properties ========');
    lines.push('        public bool IsConnected => _session?.State == NetClientState.Connected;');
    lines.push('        public string Url => _url;');
    lines.push('        public string LastError => _lastError;');
    lines.push('');

    // Connect method
    lines.push('        // ======== Connection Lifecycle ========');
    lines.push('');
    lines.push('        /// <summary>');
    lines.push('        /// Connect to server. Creates session via INetConnector.');
    lines.push('        /// </summary>');
    lines.push('        public void Connect(string url)');
    lines.push('        {');
    lines.push('            if (string.IsNullOrEmpty(url)) throw new ArgumentException("url is empty", nameof(url));');
    lines.push('');
    lines.push('            DisposeSession();');
    lines.push('');
    lines.push('            _url = url;');
    lines.push('            _lastError = string.Empty;');
    lines.push('');
    lines.push('            // Create runtime multiplexer from handlers');
    if (inboundProtos.length > 0) {
        const runtimeArgs = inboundProtos.map(p => `new ${p.name}.Runtime(${p.name}Handlers)`);
        lines.push(`            var runtimeMux = new RuntimeMux(`);
        lines.push(`                ${runtimeArgs.join(',\n                ')}`);
        lines.push('            );');
    } else {
        lines.push('            var runtimeMux = new RuntimeMux();');
    }
    lines.push('');
    lines.push('            // Create session via connector');
    lines.push('            var session = _connector.CreateSession(runtimeMux, url);');
    lines.push('            session.OnOpen += HandleOpen;');
    lines.push('            session.OnClose += HandleClose;');
    lines.push('            session.OnError += HandleError;');
    lines.push('');

    // Attach session to proxies
    if (outboundProtos.length > 0) {
        lines.push('            // Attach session to proxies for sending');
        for (const proto of outboundProtos) {
            lines.push(`            ${proto.name}Proxy.AttachSession(session);`);
        }
        lines.push('');
    }

    lines.push('            _session = session;');
    lines.push('            _ = session.ConnectAsync().ContinueWith(t => { var ex = t.Exception; }, System.Threading.Tasks.TaskContinuationOptions.OnlyOnFaulted | System.Threading.Tasks.TaskContinuationOptions.ExecuteSynchronously);');
    lines.push('        }');
    lines.push('');

    // Tick
    lines.push('        /// <summary>');
    lines.push('        /// Process network events. Call from Update() loop.');
    lines.push('        /// </summary>');
    lines.push('        public void Tick()');
    lines.push('        {');
    lines.push('            _session?.Tick();');
    lines.push('        }');
    lines.push('');

    // Close
    lines.push('        /// <summary>');
    lines.push('        /// Request graceful disconnect.');
    lines.push('        /// </summary>');
    lines.push('        public void Close()');
    lines.push('        {');
    lines.push('            if (_session == null) return;');
    lines.push('            _ = _session.CloseAsync();');
    lines.push('        }');
    lines.push('');

    // Dispose
    lines.push('        /// <summary>');
    lines.push('        /// Dispose connection resources.');
    lines.push('        /// </summary>');
    lines.push('        public void Dispose()');
    lines.push('        {');
    lines.push('            DisposeSession();');
    lines.push('        }');
    lines.push('');

    // DisposeSession helper
    lines.push('        private void DisposeSession()');
    lines.push('        {');
    lines.push('            if (_session != null)');
    lines.push('            {');
    lines.push('                _session.OnOpen -= HandleOpen;');
    lines.push('                _session.OnClose -= HandleClose;');
    lines.push('                _session.OnError -= HandleError;');
    lines.push('                (_session as IDisposable)?.Dispose();');
    lines.push('                _session = null;');
    lines.push('            }');
    lines.push('        }');
    lines.push('');

    // ======== Event handlers ========
    lines.push('        // ======== Internal Event Handlers ========');
    lines.push('');
    lines.push('        private void HandleOpen()');
    lines.push('        {');
    lines.push('            OnOpen?.Invoke();');
    lines.push('        }');
    lines.push('');
    lines.push('        private void HandleClose(ushort code, string reason)');
    lines.push('        {');
    lines.push('            OnClose?.Invoke(code, reason);');
    lines.push('        }');
    lines.push('');
    lines.push('        private void HandleError(Exception ex)');
    lines.push('        {');
    lines.push('            _lastError = ex.Message;');
    lines.push('            OnError?.Invoke(ex);');
    lines.push('        }');
    lines.push('');

    // ======== Events ========
    lines.push('        // ======== Events ========');
    lines.push('        public event Action? OnOpen;');
    lines.push('        public event Action<ushort, string>? OnClose;');
    lines.push('        public event Action<Exception>? OnError;');

    lines.push('    }');
    lines.push('}');

    return lines.join('\n');
}

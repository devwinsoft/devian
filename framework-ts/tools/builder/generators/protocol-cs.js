// <auto-generated>
// Devian Build System v10 - C# Protocol Generator
// SSOT: skills/devian/03-ssot/SKILL.md
// Namespace: Devian.Network.{Group} + static partial class {ProtocolName}
// </auto-generated>

/**
 * Generate C# protocol code from protocol spec
 * @param {Object} spec - Protocol specification
 * @param {string} protocolName - Protocol name (e.g., "C2Game")
 * @param {string} groupName - Protocol group name (e.g., "Game")
 * @returns {string} Generated C# code
 */
export function generateCSharpProtocol(spec, protocolName, groupName) {
    const lines = [];

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push('// </auto-generated>');
    lines.push('');
    lines.push('#nullable enable');
    lines.push('');
    lines.push('using System;');
    lines.push('using System.Buffers;');
    lines.push('using System.Collections.Generic;');
    lines.push('using System.IO;');
    lines.push('using System.Text;');
    // Note: System.Text.Json 미사용 (Unity 호환성)
    lines.push('using Devian.Module.Common;');
    lines.push('');

    // Namespace: Devian.Network.{Group} (block style)
    lines.push(`namespace Devian.Network.${groupName}`);
    lines.push('{');

    // Direction comment
    if (spec.direction && spec.direction !== 'bidirectional') {
        lines.push(`    // Direction: ${spec.direction}`);
        lines.push('');
    }

    // Container: public static partial class {ProtocolName}
    lines.push('    /// <summary>');
    lines.push(`    /// ${protocolName} protocol container.`);
    lines.push('    /// </summary>');
    lines.push(`    public static partial class ${protocolName}`);
    lines.push('    {');

    // Frame helper
    generateFrameHelper(lines);
    lines.push('');

    // EnvelopeMeta
    generateEnvelopeMeta(lines);
    lines.push('');

    // PacketEnvelope (ref struct)
    generatePacketEnvelope(lines);
    lines.push('');

    // PacketPool<T>
    generatePacketPool(lines);
    lines.push('');

    // ProtoReader (ref struct)
    generateProtoReader(lines);
    lines.push('');

    // ProtoWriter helper
    generateProtoWriter(lines);
    lines.push('');

    // Message classes
    for (const message of spec.messages || []) {
        generateMessageClass(lines, message);
        lines.push('');
    }

    // Opcodes class
    generateOpcodesClass(lines, spec.messages || [], protocolName);
    lines.push('');

    // ICodec interface
    generateICodec(lines, protocolName);
    lines.push('');

    // Note: CodecJson 미생성 (Unity 호환성 - System.Text.Json 미지원)

    // CodecProtobuf
    generateCodecProtobuf(lines, spec.messages || [], protocolName);
    lines.push('');

    // ISender interface
    generateISender(lines);
    lines.push('');

    // Stub (abstract class)
    generateStub(lines, spec.messages || [], protocolName);
    lines.push('');

    // Runtime Adapter (INetRuntime implementation)
    generateRuntimeAdapter(lines, spec.messages || [], protocolName);
    lines.push('');

    // Proxy
    generateProxy(lines, spec.messages || [], protocolName);

    lines.push('    }'); // end static class
    lines.push('}'); // end namespace

    return lines.join('\n');
}

// ============================================================================
// Helper Generators
// ============================================================================

function generateFrameHelper(lines) {
    lines.push('        /// <summary>');
    lines.push('        /// Frame helper for protocol framing.');
    lines.push('        /// Frame format: [opcode:int32LE][payload...]');
    lines.push('        /// </summary>');
    lines.push('        internal static class Frame');
    lines.push('        {');
    lines.push('            public static int ReadOpcode(ReadOnlySpan<byte> frame)');
    lines.push('            {');
    lines.push('                if (frame.Length < 4) throw new ArgumentException("Frame too short");');
    lines.push('                return BitConverter.ToInt32(frame.Slice(0, 4));');
    lines.push('            }');
    lines.push('');
    lines.push('            public static ReadOnlySpan<byte> ReadPayload(ReadOnlySpan<byte> frame)');
    lines.push('            {');
    lines.push('                if (frame.Length < 4) return ReadOnlySpan<byte>.Empty;');
    lines.push('                return frame.Slice(4);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static byte[] Pack(int opcode, ReadOnlySpan<byte> payload)');
    lines.push('            {');
    lines.push('                var frame = new byte[4 + payload.Length];');
    lines.push('                BitConverter.TryWriteBytes(frame.AsSpan(0, 4), opcode);');
    lines.push('                payload.CopyTo(frame.AsSpan(4));');
    lines.push('                return frame;');
    lines.push('            }');
    lines.push('        }');
}

function generateEnvelopeMeta(lines) {
    lines.push('        /// <summary>Envelope metadata (sessionId 등)</summary>');
    lines.push('        public readonly struct EnvelopeMeta');
    lines.push('        {');
    lines.push('            public int SessionId { get; }');
    lines.push('');
    lines.push('            public EnvelopeMeta(int sessionId)');
    lines.push('            {');
    lines.push('                SessionId = sessionId;');
    lines.push('            }');
    lines.push('        }');
}

function generatePacketEnvelope(lines) {
    lines.push('        /// <summary>');
    lines.push('        /// Packet envelope (ref struct - 복사/할당 방지)');
    lines.push('        /// </summary>');
    lines.push('        public ref struct PacketEnvelope');
    lines.push('        {');
    lines.push('            public int Opcode { get; }');
    lines.push('            public ReadOnlySpan<byte> Payload { get; }');
    lines.push('            public EnvelopeMeta Meta { get; }');
    lines.push('');
    lines.push('            public PacketEnvelope(int opcode, ReadOnlySpan<byte> payload, EnvelopeMeta meta)');
    lines.push('            {');
    lines.push('                Opcode = opcode;');
    lines.push('                Payload = payload;');
    lines.push('                Meta = meta;');
    lines.push('            }');
    lines.push('        }');
}

function generatePacketPool(lines) {
    lines.push('        /// <summary>');
    lines.push('        /// Generic packet pool for message object reuse.');
    lines.push('        /// </summary>');
    lines.push('        internal sealed class PacketPool<T> where T : class, new()');
    lines.push('        {');
    lines.push('            private readonly Stack<T> _stack;');
    lines.push('            private readonly int _max;');
    lines.push('');
    lines.push('            public PacketPool(int max = 256)');
    lines.push('            {');
    lines.push('                _max = max;');
    lines.push('                _stack = new Stack<T>(Math.Min(max, 32));');
    lines.push('            }');
    lines.push('');
    lines.push('            public T Rent()');
    lines.push('            {');
    lines.push('                lock (_stack)');
    lines.push('                {');
    lines.push('                    return _stack.Count > 0 ? _stack.Pop() : new T();');
    lines.push('                }');
    lines.push('            }');
    lines.push('');
    lines.push('            public void Return(T item)');
    lines.push('            {');
    lines.push('                lock (_stack)');
    lines.push('                {');
    lines.push('                    if (_stack.Count < _max) _stack.Push(item);');
    lines.push('                }');
    lines.push('            }');
    lines.push('        }');
}

function generateProtoReader(lines) {
    lines.push('        /// <summary>');
    lines.push('        /// Span-based protobuf reader (zero-copy)');
    lines.push('        /// </summary>');
    lines.push('        internal ref struct ProtoReader');
    lines.push('        {');
    lines.push('            private ReadOnlySpan<byte> _data;');
    lines.push('            private int _pos;');
    lines.push('');
    lines.push('            public ProtoReader(ReadOnlySpan<byte> data)');
    lines.push('            {');
    lines.push('                _data = data;');
    lines.push('                _pos = 0;');
    lines.push('            }');
    lines.push('');
    lines.push('            public bool HasMore => _pos < _data.Length;');
    lines.push('');
    lines.push('            public (int tag, int wireType) ReadTag()');
    lines.push('            {');
    lines.push('                var varint = ReadVarint();');
    lines.push('                return ((int)(varint >> 3), (int)(varint & 0x7));');
    lines.push('            }');
    lines.push('');
    lines.push('            public long ReadVarint()');
    lines.push('            {');
    lines.push('                long result = 0;');
    lines.push('                int shift = 0;');
    lines.push('                while (_pos < _data.Length)');
    lines.push('                {');
    lines.push('                    byte b = _data[_pos++];');
    lines.push('                    result |= (long)(b & 0x7F) << shift;');
    lines.push('                    if ((b & 0x80) == 0) break;');
    lines.push('                    shift += 7;');
    lines.push('                }');
    lines.push('                return result;');
    lines.push('            }');
    lines.push('');
    lines.push('            public int ReadInt32() => (int)ReadVarint();');
    lines.push('            public long ReadInt64() => ReadVarint();');
    lines.push('            public uint ReadUInt32() => (uint)ReadVarint();');
    lines.push('            public ulong ReadUInt64() => (ulong)ReadVarint();');
    lines.push('            public bool ReadBool() => ReadVarint() != 0;');
    lines.push('');
    lines.push('            public int ReadSInt32()');
    lines.push('            {');
    lines.push('                var n = (uint)ReadVarint();');
    lines.push('                return (int)((n >> 1) ^ -(int)(n & 1));');
    lines.push('            }');
    lines.push('');
    lines.push('            public long ReadSInt64()');
    lines.push('            {');
    lines.push('                var n = (ulong)ReadVarint();');
    lines.push('                return (long)(n >> 1) ^ -(long)(n & 1);');
    lines.push('            }');
    lines.push('');
    lines.push('            public float ReadFloat()');
    lines.push('            {');
    lines.push('                var bytes = _data.Slice(_pos, 4);');
    lines.push('                _pos += 4;');
    lines.push('                return BitConverter.ToSingle(bytes);');
    lines.push('            }');
    lines.push('');
    lines.push('            public double ReadDouble()');
    lines.push('            {');
    lines.push('                var bytes = _data.Slice(_pos, 8);');
    lines.push('                _pos += 8;');
    lines.push('                return BitConverter.ToDouble(bytes);');
    lines.push('            }');
    lines.push('');
    lines.push('            public string ReadString()');
    lines.push('            {');
    lines.push('                var len = (int)ReadVarint();');
    lines.push('                if (len == 0) return string.Empty;');
    lines.push('                var bytes = _data.Slice(_pos, len);');
    lines.push('                _pos += len;');
    lines.push('                return Encoding.UTF8.GetString(bytes);');
    lines.push('            }');
    lines.push('');
    lines.push('            public byte[] ReadBytes()');
    lines.push('            {');
    lines.push('                var len = (int)ReadVarint();');
    lines.push('                if (len == 0) return Array.Empty<byte>();');
    lines.push('                var bytes = _data.Slice(_pos, len).ToArray();');
    lines.push('                _pos += len;');
    lines.push('                return bytes;');
    lines.push('            }');
    lines.push('');
    lines.push('            public void Skip(int wireType)');
    lines.push('            {');
    lines.push('                switch (wireType)');
    lines.push('                {');
    lines.push('                    case 0: ReadVarint(); break;');
    lines.push('                    case 1: _pos += 8; break;');
    lines.push('                    case 2: _pos += (int)ReadVarint(); break;');
    lines.push('                    case 5: _pos += 4; break;');
    lines.push('                }');
    lines.push('            }');
    lines.push('        }');
}

function generateProtoWriter(lines) {
    lines.push('        /// <summary>');
    lines.push('        /// Protobuf wire format writer helper');
    lines.push('        /// </summary>');
    lines.push('        private static class ProtoWriter');
    lines.push('        {');
    lines.push('            public static void WriteVarint(MemoryStream ms, long value)');
    lines.push('            {');
    lines.push('                var uval = (ulong)value;');
    lines.push('                while (uval >= 0x80)');
    lines.push('                {');
    lines.push('                    ms.WriteByte((byte)(uval | 0x80));');
    lines.push('                    uval >>= 7;');
    lines.push('                }');
    lines.push('                ms.WriteByte((byte)uval);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteTag(MemoryStream ms, int tag, int wireType)');
    lines.push('            {');
    lines.push('                WriteVarint(ms, (tag << 3) | wireType);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteString(MemoryStream ms, int tag, string? value)');
    lines.push('            {');
    lines.push('                if (string.IsNullOrEmpty(value)) return;');
    lines.push('                WriteTag(ms, tag, 2);');
    lines.push('                var bytes = Encoding.UTF8.GetBytes(value);');
    lines.push('                WriteVarint(ms, bytes.Length);');
    lines.push('                ms.Write(bytes, 0, bytes.Length);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteInt32(MemoryStream ms, int tag, int value)');
    lines.push('            {');
    lines.push('                if (value == 0) return;');
    lines.push('                WriteTag(ms, tag, 0);');
    lines.push('                WriteVarint(ms, value);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteInt64(MemoryStream ms, int tag, long value)');
    lines.push('            {');
    lines.push('                if (value == 0) return;');
    lines.push('                WriteTag(ms, tag, 0);');
    lines.push('                WriteVarint(ms, value);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteBool(MemoryStream ms, int tag, bool value)');
    lines.push('            {');
    lines.push('                if (!value) return;');
    lines.push('                WriteTag(ms, tag, 0);');
    lines.push('                ms.WriteByte(1);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteBytes(MemoryStream ms, int tag, byte[]? value)');
    lines.push('            {');
    lines.push('                if (value == null || value.Length == 0) return;');
    lines.push('                WriteTag(ms, tag, 2);');
    lines.push('                WriteVarint(ms, value.Length);');
    lines.push('                ms.Write(value, 0, value.Length);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteFloat(MemoryStream ms, int tag, float value)');
    lines.push('            {');
    lines.push('                if (value == 0) return;');
    lines.push('                WriteTag(ms, tag, 5);');
    lines.push('                var bytes = BitConverter.GetBytes(value);');
    lines.push('                ms.Write(bytes, 0, 4);');
    lines.push('            }');
    lines.push('');
    lines.push('            public static void WriteDouble(MemoryStream ms, int tag, double value)');
    lines.push('            {');
    lines.push('                if (value == 0) return;');
    lines.push('                WriteTag(ms, tag, 1);');
    lines.push('                var bytes = BitConverter.GetBytes(value);');
    lines.push('                ms.Write(bytes, 0, 8);');
    lines.push('            }');
    lines.push('        }');
}

function generateMessageClass(lines, message) {
    const className = message.name;
    lines.push(`        /// <summary>${className} message</summary>`);
    lines.push(`        public sealed class ${className}`);
    lines.push('        {');

    // Properties
    for (const field of message.fields || []) {
        const csType = mapToCSharpType(field.type, field.optional);
        const propName = capitalize(field.name);
        lines.push(`            public ${csType} ${propName} { get; set; }${getDefaultValue(field.type, field.optional)}`);
    }

    // _Reset method for pooling
    lines.push('');
    lines.push('            internal void _Reset()');
    lines.push('            {');
    for (const field of message.fields || []) {
        const propName = capitalize(field.name);
        const resetValue = getResetValue(field.type, field.optional);
        lines.push(`                ${propName} = ${resetValue};`);
    }
    lines.push('            }');

    lines.push('        }');
}

function generateOpcodesClass(lines, messages, protocolName) {
    lines.push('        /// <summary>Opcode constants</summary>');
    lines.push('        public static class Opcodes');
    lines.push('        {');
    for (const msg of messages) {
        lines.push(`            public const int ${msg.name} = ${msg.opcode};`);
    }
    lines.push('');
    lines.push('            public static string? GetName(int opcode) => opcode switch');
    lines.push('            {');
    for (const msg of messages) {
        lines.push(`                ${msg.opcode} => nameof(${msg.name}),`);
    }
    lines.push('                _ => null');
    lines.push('            };');
    lines.push('        }');
}

function generateICodec(lines, protocolName) {
    lines.push('        /// <summary>Codec interface</summary>');
    lines.push('        public interface ICodec');
    lines.push('        {');
    lines.push('            byte[] Encode<T>(T message) where T : class;');
    lines.push('            T Decode<T>(ReadOnlySpan<byte> data) where T : class, new();');
    lines.push('            object? Decode(int opcode, ReadOnlySpan<byte> data);');
    lines.push('        }');
}

function generateCodecJson(lines, messages, protocolName) {
    lines.push('        /// <summary>JSON Codec implementation</summary>');
    lines.push('        public sealed class CodecJson : ICodec');
    lines.push('        {');
    lines.push('            private static readonly JsonSerializerOptions _options = new()');
    lines.push('            {');
    lines.push('                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,');
    lines.push('                WriteIndented = false');
    lines.push('            };');
    lines.push('');
    lines.push('            public byte[] Encode<T>(T message) where T : class');
    lines.push('            {');
    lines.push('                return JsonSerializer.SerializeToUtf8Bytes(message, _options);');
    lines.push('            }');
    lines.push('');
    lines.push('            public T Decode<T>(ReadOnlySpan<byte> data) where T : class, new()');
    lines.push('            {');
    lines.push('                return JsonSerializer.Deserialize<T>(data, _options) ?? new T();');
    lines.push('            }');
    lines.push('');
    lines.push('            public object? Decode(int opcode, ReadOnlySpan<byte> data)');
    lines.push('            {');
    lines.push('                return opcode switch');
    lines.push('                {');
    for (const msg of messages) {
        lines.push(`                    Opcodes.${msg.name} => Decode<${msg.name}>(data),`);
    }
    lines.push('                    _ => null');
    lines.push('                };');
    lines.push('            }');
    lines.push('        }');
}

function generateCodecProtobuf(lines, messages, protocolName) {
    lines.push('        /// <summary>Protobuf Codec implementation</summary>');
    lines.push('        public sealed class CodecProtobuf : ICodec');
    lines.push('        {');

    // Encode
    lines.push('            public byte[] Encode<T>(T message) where T : class');
    lines.push('            {');
    lines.push('                using var ms = new MemoryStream();');
    lines.push('                switch (message)');
    lines.push('                {');
    for (const msg of messages) {
        lines.push(`                    case ${msg.name} m: Encode${msg.name}(ms, m); break;`);
    }
    lines.push('                    default: throw new ArgumentException($"Unknown message type: {typeof(T).Name}");');
    lines.push('                }');
    lines.push('                return ms.ToArray();');
    lines.push('            }');
    lines.push('');

    // Decode<T>
    lines.push('            public T Decode<T>(ReadOnlySpan<byte> data) where T : class, new()');
    lines.push('            {');
    lines.push('                var result = new T();');
    lines.push('                switch (result)');
    lines.push('                {');
    for (const msg of messages) {
        lines.push(`                    case ${msg.name} m: Decode${msg.name}(data, m); break;`);
    }
    lines.push('                }');
    lines.push('                return result;');
    lines.push('            }');
    lines.push('');

    // Decode by opcode
    lines.push('            public object? Decode(int opcode, ReadOnlySpan<byte> data)');
    lines.push('            {');
    lines.push('                return opcode switch');
    lines.push('                {');
    for (const msg of messages) {
        lines.push(`                    Opcodes.${msg.name} => Decode<${msg.name}>(data),`);
    }
    lines.push('                    _ => null');
    lines.push('                };');
    lines.push('            }');
    lines.push('');

    // Per-message encode methods
    for (const msg of messages) {
        generateEncodeMethod(lines, msg);
        lines.push('');
    }

    // Per-message decode methods
    for (const msg of messages) {
        generateDecodeMethod(lines, msg);
        lines.push('');
    }

    lines.push('        }');
}

function generateEncodeMethod(lines, message) {
    lines.push(`            private static void Encode${message.name}(MemoryStream ms, ${message.name} m)`);
    lines.push('            {');
    for (const field of message.fields || []) {
        const tag = field.tag;
        const propName = capitalize(field.name);
        const writeMethod = getWriteMethod(field.type);
        
        if (field.type.endsWith('[]')) {
            // Array handling
            const baseType = field.type.slice(0, -2);
            lines.push(`                if (m.${propName} != null)`);
            lines.push('                {');
            lines.push(`                    foreach (var item in m.${propName})`);
            lines.push('                    {');
            lines.push(`                        ${getArrayWriteCall(baseType, tag)}`);
            lines.push('                    }');
            lines.push('                }');
        } else if (writeMethod) {
            lines.push(`                ProtoWriter.${writeMethod}(ms, ${tag}, m.${propName});`);
        }
    }
    lines.push('            }');
}

function generateDecodeMethod(lines, message) {
    lines.push(`            private static void Decode${message.name}(ReadOnlySpan<byte> data, ${message.name} m)`);
    lines.push('            {');
    lines.push('                var reader = new ProtoReader(data);');
    lines.push('                while (reader.HasMore)');
    lines.push('                {');
    lines.push('                    var (tag, wireType) = reader.ReadTag();');
    lines.push('                    switch (tag)');
    lines.push('                    {');
    
    for (const field of message.fields || []) {
        const tag = field.tag;
        const propName = capitalize(field.name);
        const readCall = getReadCall(field.type);
        
        if (field.type.endsWith('[]')) {
            const baseType = field.type.slice(0, -2);
            lines.push(`                        case ${tag}:`);
            lines.push(`                            m.${propName} ??= new List<${mapToCSharpBaseType(baseType)}>();`);
            lines.push(`                            m.${propName}.Add(${getArrayReadCall(baseType)});`);
            lines.push('                            break;');
        } else if (readCall) {
            lines.push(`                        case ${tag}: m.${propName} = ${readCall}; break;`);
        }
    }
    
    lines.push('                        default: reader.Skip(wireType); break;');
    lines.push('                    }');
    lines.push('                }');
    lines.push('            }');
}

function generateISender(lines) {
    lines.push('        /// <summary>Sender interface for Proxy</summary>');
    lines.push('        public interface ISender');
    lines.push('        {');
    lines.push('            void SendTo(int sessionId, ReadOnlySpan<byte> frame);');
    lines.push('        }');
}

function generateStub(lines, messages, protocolName) {
    lines.push('        /// <summary>');
    lines.push(`        /// Abstract stub for ${protocolName} handlers.`);
    lines.push('        /// Inherit and implement all On* methods.');
    lines.push('        /// </summary>');
    lines.push('        public abstract class Stub');
    lines.push('        {');
    lines.push('            protected ICodec Codec { get; }');
    lines.push('');
    lines.push('            protected Stub(ICodec? codec = null)');
    lines.push('            {');
    lines.push('                Codec = codec ?? new CodecProtobuf();');
    lines.push('            }');
    lines.push('');

    // Dispatch method
    lines.push('            public void Dispatch(PacketEnvelope envelope)');
    lines.push('            {');
    lines.push('                switch (envelope.Opcode)');
    lines.push('                {');
    for (const msg of messages) {
        lines.push(`                    case Opcodes.${msg.name}:`);
        lines.push(`                        var ${lowerFirst(msg.name)} = Codec.Decode<${msg.name}>(envelope.Payload);`);
        lines.push(`                        On${msg.name}(envelope.Meta, ${lowerFirst(msg.name)});`);
        lines.push('                        break;');
    }
    lines.push('                }');
    lines.push('            }');
    lines.push('');

    // Abstract handler methods
    for (const msg of messages) {
        lines.push(`            protected abstract void On${msg.name}(EnvelopeMeta meta, ${msg.name} message);`);
    }

    lines.push('        }');
}

function generateRuntimeAdapter(lines, messages, protocolName) {
    lines.push('        /// <summary>');
    lines.push(`        /// Runtime adapter implementing INetRuntime for ${protocolName}.`);
    lines.push('        /// Bridges NetworkClient and generated Stub.');
    lines.push('        /// </summary>');
    lines.push('        public sealed class Runtime : Devian.Network.INetRuntime');
    lines.push('        {');
    lines.push('            private readonly Stub _stub;');
    lines.push('');
    lines.push('            public Runtime(Stub stub)');
    lines.push('            {');
    lines.push('                _stub = stub ?? throw new ArgumentNullException(nameof(stub));');
    lines.push('            }');
    lines.push('');
    lines.push('            /// <summary>');
    lines.push('            /// Try to dispatch inbound packet. Returns true if opcode belongs to this protocol.');
    lines.push('            /// </summary>');
    lines.push('            public bool TryDispatchInbound(int sessionId, int opcode, ReadOnlySpan<byte> payload)');
    lines.push('            {');

    if (messages.length === 0) {
        // No messages - always return false
        lines.push('                return false;');
    } else {
        lines.push('                switch (opcode)');
        lines.push('                {');
        // Generate case labels for all opcodes
        for (const msg of messages) {
            lines.push(`                    case Opcodes.${msg.name}:`);
        }
        // Shared block for all cases
        lines.push('                    {');
        lines.push('                        var meta = new EnvelopeMeta(sessionId);');
        lines.push('                        var envelope = new PacketEnvelope(opcode, payload, meta);');
        lines.push('                        _stub.Dispatch(envelope);');
        lines.push('                        return true;');
        lines.push('                    }');
        lines.push('                    default:');
        lines.push('                        return false;');
        lines.push('                }');
    }

    lines.push('            }');
    lines.push('        }');
}

function generateProxy(lines, messages, protocolName) {
    lines.push('        /// <summary>');
    lines.push(`        /// Proxy for sending ${protocolName} messages.`);
    lines.push('        /// </summary>');
    lines.push('        public sealed class Proxy');
    lines.push('        {');
    lines.push('            private readonly ISender _sender;');
    lines.push('            private readonly ICodec _codec;');
    lines.push('');
    lines.push('            public Proxy(ISender sender, ICodec? codec = null)');
    lines.push('            {');
    lines.push('                _sender = sender;');
    lines.push('                _codec = codec ?? new CodecProtobuf();');
    lines.push('            }');
    lines.push('');

    for (const msg of messages) {
        lines.push(`            public void Send${msg.name}(int sessionId, ${msg.name} message)`);
        lines.push('            {');
        lines.push(`                var payload = _codec.Encode(message);`);
        lines.push(`                var frame = Frame.Pack(Opcodes.${msg.name}, payload);`);
        lines.push('                _sender.SendTo(sessionId, frame);');
        lines.push('            }');
        lines.push('');
    }

    lines.push('        }');
}

// ============================================================================
// Type Mapping Utilities
// ============================================================================

function mapToCSharpType(type, optional = false) {
    const baseType = type.endsWith('[]') ? type.slice(0, -2) : type;
    const isArray = type.endsWith('[]');
    
    let csType = mapToCSharpBaseType(baseType);
    
    if (isArray) {
        csType = `List<${csType}>?`;
    } else if (optional && !isValueType(baseType)) {
        csType = `${csType}?`;
    }
    
    return csType;
}

function mapToCSharpBaseType(type) {
    // Handle map<K,V> type
    const mapMatch = type.match(/^map<\s*(\w+)\s*,\s*(\w+)\s*>$/);
    if (mapMatch) {
        const keyType = mapToCSharpBaseType(mapMatch[1]);
        const valueType = mapToCSharpBaseType(mapMatch[2]);
        return `Dictionary<${keyType}, ${valueType}>`;
    }

    const typeMap = {
        'int32': 'int',
        'int64': 'long',
        'uint32': 'uint',
        'uint64': 'ulong',
        'sint32': 'int',
        'sint64': 'long',
        'float': 'float',
        'double': 'double',
        'bool': 'bool',
        'string': 'string',
        'bytes': 'byte[]',
    };
    return typeMap[type] || type;
}

function isValueType(type) {
    return ['int32', 'int64', 'uint32', 'uint64', 'sint32', 'sint64', 'float', 'double', 'bool'].includes(type);
}

function getDefaultValue(type, optional) {
    if (type.endsWith('[]')) return '';
    if (type === 'string') return ' = string.Empty;';
    if (type === 'bytes') return ' = Array.Empty<byte>();';
    return '';
}

function getResetValue(type, optional) {
    if (type.endsWith('[]')) return 'null';
    if (type === 'string') return 'string.Empty';
    if (type === 'bytes') return 'Array.Empty<byte>()';
    if (isValueType(type.replace('[]', ''))) return 'default';
    return 'null!';
}

function getWriteMethod(type) {
    if (type.endsWith('[]')) return null; // Handled separately
    const methodMap = {
        'int32': 'WriteInt32',
        'int64': 'WriteInt64',
        'uint32': 'WriteInt32',
        'uint64': 'WriteInt64',
        'bool': 'WriteBool',
        'string': 'WriteString',
        'bytes': 'WriteBytes',
        'float': 'WriteFloat',
        'double': 'WriteDouble',
    };
    return methodMap[type];
}

function getReadCall(type) {
    if (type.endsWith('[]')) return null; // Handled separately
    const readMap = {
        'int32': 'reader.ReadInt32()',
        'int64': 'reader.ReadInt64()',
        'uint32': 'reader.ReadUInt32()',
        'uint64': 'reader.ReadUInt64()',
        'sint32': 'reader.ReadSInt32()',
        'sint64': 'reader.ReadSInt64()',
        'bool': 'reader.ReadBool()',
        'string': 'reader.ReadString()',
        'bytes': 'reader.ReadBytes()',
        'float': 'reader.ReadFloat()',
        'double': 'reader.ReadDouble()',
    };
    return readMap[type];
}

function getArrayWriteCall(baseType, tag) {
    const writeMap = {
        'int32': `ProtoWriter.WriteInt32(ms, ${tag}, item);`,
        'int64': `ProtoWriter.WriteInt64(ms, ${tag}, item);`,
        'bool': `ProtoWriter.WriteBool(ms, ${tag}, item);`,
        'string': `ProtoWriter.WriteString(ms, ${tag}, item);`,
    };
    return writeMap[baseType] || `// TODO: ${baseType}[]`;
}

function getArrayReadCall(baseType) {
    const readMap = {
        'int32': 'reader.ReadInt32()',
        'int64': 'reader.ReadInt64()',
        'bool': 'reader.ReadBool()',
        'string': 'reader.ReadString()',
    };
    return readMap[baseType] || 'default';
}

function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

function lowerFirst(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
}

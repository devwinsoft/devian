// <auto-generated>
// Devian Build System v10 - TypeScript Protocol Generator
// SSOT: skills/devian-core/03-ssot/SKILL.md
// Namespace: export namespace {ProtocolName} + Devian.Network.{group} alias
// </auto-generated>

import { mapTsType } from './protocol-type-mapper.js';

/**
 * Generate TypeScript protocol code from protocol spec
 * @param {Object} spec - Protocol specification
 * @param {string} protocolName - Protocol name (e.g., "C2Game")
 * @param {string} groupName - Protocol group name (e.g., "Game")
 * @returns {string} Generated TypeScript code
 */
export function generateTypeScriptProtocol(spec, protocolName, groupName) {
    const lines = [];

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push(`// Protocol: ${protocolName} (Group: ${groupName})`);
    lines.push('// </auto-generated>');
    lines.push('');

    // Direction comment
    if (spec.direction && spec.direction !== 'bidirectional') {
        lines.push(`// Direction: ${spec.direction}`);
        lines.push('');
    }

    // Main namespace (flat for easy import)
    lines.push(`export namespace ${protocolName} {`);
    lines.push('');

    // Message interfaces
    for (const message of spec.messages || []) {
        generateMessageInterface(lines, message);
        lines.push('');
    }

    // Opcodes
    generateOpcodesObject(lines, spec.messages || []);
    lines.push('');

    // ICodec interface
    generateICodecInterface(lines);
    lines.push('');

    // CodecJson
    generateCodecJson(lines, spec.messages || []);
    lines.push('');

    // CodecProtobuf
    generateCodecProtobuf(lines, spec.messages || []);
    lines.push('');

    // Stub class
    generateStub(lines, spec.messages || [], protocolName);
    lines.push('');

    // Proxy class
    generateProxy(lines, spec.messages || [], protocolName);

    lines.push('}'); // end namespace ProtocolName
    lines.push('');

    return lines.join('\n');
}

// ============================================================================
// Generator Functions
// ============================================================================

function generateMessageInterface(lines, message) {
    lines.push(`    /** ${message.name} message */`);
    lines.push(`    export interface ${message.name} {`);

    for (const field of message.fields || []) {
        const tsType = mapToTypeScriptType(field.type);
        const optional = field.optional ? '?' : '';
        lines.push(`        ${field.name}${optional}: ${tsType};`);
    }

    lines.push('    }');
}

function generateOpcodesObject(lines, messages) {
    lines.push('    /** Opcode constants */');
    lines.push('    export const Opcodes = {');
    for (const msg of messages) {
        lines.push(`        ${msg.name}: ${msg.opcode},`);
    }
    lines.push('    } as const;');
    lines.push('');
    lines.push('    export type OpcodeType = typeof Opcodes[keyof typeof Opcodes];');
    lines.push('');
    lines.push('    export function getOpcodeName(opcode: number): string | undefined {');
    lines.push('        const entries = Object.entries(Opcodes);');
    lines.push('        const found = entries.find(([_, v]) => v === opcode);');
    lines.push('        return found?.[0];');
    lines.push('    }');
}

function generateICodecInterface(lines) {
    lines.push('    /** Codec interface */');
    lines.push('    export interface ICodec {');
    lines.push('        encode<T>(message: T): Uint8Array;');
    lines.push('        encodeByOpcode<T>(opcode: number, message: T): Uint8Array;');
    lines.push('        decode<T>(data: Uint8Array): T;');
    lines.push('        decodeByOpcode(opcode: number, data: Uint8Array): unknown;');
    lines.push('    }');
}

function generateCodecJson(lines, messages) {
    lines.push('    /** JSON Codec implementation */');
    lines.push('    export class CodecJson implements ICodec {');
    lines.push('        private encoder = new TextEncoder();');
    lines.push('        private decoder = new TextDecoder();');
    lines.push('');
    lines.push('        encode<T>(message: T): Uint8Array {');
    lines.push('            const json = JSON.stringify(message);');
    lines.push('            return this.encoder.encode(json);');
    lines.push('        }');
    lines.push('');
    lines.push('        encodeByOpcode<T>(_opcode: number, message: T): Uint8Array {');
    lines.push('            return this.encode(message);');
    lines.push('        }');
    lines.push('');
    lines.push('        decode<T>(data: Uint8Array): T {');
    lines.push('            const json = this.decoder.decode(data);');
    lines.push('            return JSON.parse(json) as T;');
    lines.push('        }');
    lines.push('');
    lines.push('        decodeByOpcode(opcode: number, data: Uint8Array): unknown {');
    lines.push('            return this.decode(data);');
    lines.push('        }');
    lines.push('    }');
}

function generateCodecProtobuf(lines, messages) {
    // Proto helpers
    lines.push('    /** Protobuf wire format helpers */');
    lines.push('    const Proto = {');
    lines.push('        readVarint(data: Uint8Array, pos: { v: number }): bigint {');
    lines.push('            let result = 0n;');
    lines.push('            let shift = 0n;');
    lines.push('            while (pos.v < data.length) {');
    lines.push('                const b = data[pos.v++];');
    lines.push('                result |= BigInt(b & 0x7f) << shift;');
    lines.push('                if ((b & 0x80) === 0) break;');
    lines.push('                shift += 7n;');
    lines.push('            }');
    lines.push('            return result;');
    lines.push('        },');
    lines.push('');
    lines.push('        readTag(data: Uint8Array, pos: { v: number }): { tag: number; wireType: number } {');
    lines.push('            const varint = Number(this.readVarint(data, pos));');
    lines.push('            return { tag: varint >> 3, wireType: varint & 0x7 };');
    lines.push('        },');
    lines.push('');
    lines.push('        readInt32(data: Uint8Array, pos: { v: number }): number {');
    lines.push('            return Number(this.readVarint(data, pos));');
    lines.push('        },');
    lines.push('');
    lines.push('        readInt64(data: Uint8Array, pos: { v: number }): bigint {');
    lines.push('            return this.readVarint(data, pos);');
    lines.push('        },');
    lines.push('');
    lines.push('        readBool(data: Uint8Array, pos: { v: number }): boolean {');
    lines.push('            return this.readVarint(data, pos) !== 0n;');
    lines.push('        },');
    lines.push('');
    lines.push('        readString(data: Uint8Array, pos: { v: number }): string {');
    lines.push('            const len = Number(this.readVarint(data, pos));');
    lines.push('            if (len === 0) return "";');
    lines.push('            const bytes = data.slice(pos.v, pos.v + len);');
    lines.push('            pos.v += len;');
    lines.push('            return new TextDecoder().decode(bytes);');
    lines.push('        },');
    lines.push('');
    lines.push('        readBytes(data: Uint8Array, pos: { v: number }): Uint8Array {');
    lines.push('            const len = Number(this.readVarint(data, pos));');
    lines.push('            if (len === 0) return new Uint8Array(0);');
    lines.push('            const bytes = data.slice(pos.v, pos.v + len);');
    lines.push('            pos.v += len;');
    lines.push('            return bytes;');
    lines.push('        },');
    lines.push('');
    lines.push('        readFloat(data: Uint8Array, pos: { v: number }): number {');
    lines.push('            const view = new DataView(data.buffer, data.byteOffset + pos.v, 4);');
    lines.push('            pos.v += 4;');
    lines.push('            return view.getFloat32(0, true);');
    lines.push('        },');
    lines.push('');
    lines.push('        readDouble(data: Uint8Array, pos: { v: number }): number {');
    lines.push('            const view = new DataView(data.buffer, data.byteOffset + pos.v, 8);');
    lines.push('            pos.v += 8;');
    lines.push('            return view.getFloat64(0, true);');
    lines.push('        },');
    lines.push('');
    lines.push('        skip(data: Uint8Array, pos: { v: number }, wireType: number): void {');
    lines.push('            switch (wireType) {');
    lines.push('                case 0: this.readVarint(data, pos); break;');
    lines.push('                case 1: pos.v += 8; break;');
    lines.push('                case 2: pos.v += Number(this.readVarint(data, pos)); break;');
    lines.push('                case 5: pos.v += 4; break;');
    lines.push('            }');
    lines.push('        },');
    lines.push('');
    lines.push('        writeVarint(arr: number[], value: bigint): void {');
    lines.push('            let v = BigInt.asUintN(64, value);');
    lines.push('            while (v >= 0x80n) {');
    lines.push('                arr.push(Number(v & 0x7fn) | 0x80);');
    lines.push('                v >>= 7n;');
    lines.push('            }');
    lines.push('            arr.push(Number(v));');
    lines.push('        },');
    lines.push('');
    lines.push('        writeTag(arr: number[], tag: number, wireType: number): void {');
    lines.push('            this.writeVarint(arr, BigInt((tag << 3) | wireType));');
    lines.push('        },');
    lines.push('');
    lines.push('        writeInt32(arr: number[], tag: number, value: number): void {');
    lines.push('            if (value === 0) return;');
    lines.push('            this.writeTag(arr, tag, 0);');
    lines.push('            this.writeVarint(arr, BigInt(value));');
    lines.push('        },');
    lines.push('');
    lines.push('        writeInt64(arr: number[], tag: number, value: bigint): void {');
    lines.push('            if (value === 0n) return;');
    lines.push('            this.writeTag(arr, tag, 0);');
    lines.push('            this.writeVarint(arr, value);');
    lines.push('        },');
    lines.push('');
    lines.push('        writeBool(arr: number[], tag: number, value: boolean): void {');
    lines.push('            if (!value) return;');
    lines.push('            this.writeTag(arr, tag, 0);');
    lines.push('            arr.push(1);');
    lines.push('        },');
    lines.push('');
    lines.push('        writeString(arr: number[], tag: number, value: string | undefined): void {');
    lines.push('            if (!value) return;');
    lines.push('            const bytes = new TextEncoder().encode(value);');
    lines.push('            this.writeTag(arr, tag, 2);');
    lines.push('            this.writeVarint(arr, BigInt(bytes.length));');
    lines.push('            for (const b of bytes) arr.push(b);');
    lines.push('        },');
    lines.push('');
    lines.push('        writeBytes(arr: number[], tag: number, value: Uint8Array | undefined): void {');
    lines.push('            if (!value || value.length === 0) return;');
    lines.push('            this.writeTag(arr, tag, 2);');
    lines.push('            this.writeVarint(arr, BigInt(value.length));');
    lines.push('            for (const b of value) arr.push(b);');
    lines.push('        },');
    lines.push('');
    lines.push('        writeFloat(arr: number[], tag: number, value: number): void {');
    lines.push('            if (value === 0) return;');
    lines.push('            this.writeTag(arr, tag, 5);');
    lines.push('            const buf = new ArrayBuffer(4);');
    lines.push('            new DataView(buf).setFloat32(0, value, true);');
    lines.push('            for (const b of new Uint8Array(buf)) arr.push(b);');
    lines.push('        },');
    lines.push('');
    lines.push('        writeDouble(arr: number[], tag: number, value: number): void {');
    lines.push('            if (value === 0) return;');
    lines.push('            this.writeTag(arr, tag, 1);');
    lines.push('            const buf = new ArrayBuffer(8);');
    lines.push('            new DataView(buf).setFloat64(0, value, true);');
    lines.push('            for (const b of new Uint8Array(buf)) arr.push(b);');
    lines.push('        },');
    lines.push('    };');
    lines.push('');

    // CodecProtobuf class with actual encode/decode
    lines.push('    /**');
    lines.push('     * Protobuf Codec implementation.');
    lines.push('     */');
    lines.push('    export class CodecProtobuf implements ICodec {');
    lines.push('');
    
    // Generate encode methods per message
    for (const msg of messages) {
        const msgName = msg.name;
        lines.push(`        private encode${msgName}(m: ${msgName}): Uint8Array {`);
        lines.push('            const arr: number[] = [];');
        
        let tagNum = 1;
        for (const field of msg.fields || []) {
            const fieldName = field.name;
            const tsType = mapToTypeScriptType(field.type);
            
            if (tsType === 'bigint') {
                lines.push(`            Proto.writeInt64(arr, ${tagNum}, m.${fieldName} ?? 0n);`);
            } else if (tsType === 'number' && (field.type === 'float' || field.type === 'double')) {
                if (field.type === 'float') {
                    lines.push(`            Proto.writeFloat(arr, ${tagNum}, m.${fieldName} ?? 0);`);
                } else {
                    lines.push(`            Proto.writeDouble(arr, ${tagNum}, m.${fieldName} ?? 0);`);
                }
            } else if (tsType === 'number') {
                lines.push(`            Proto.writeInt32(arr, ${tagNum}, m.${fieldName} ?? 0);`);
            } else if (tsType === 'boolean') {
                lines.push(`            Proto.writeBool(arr, ${tagNum}, m.${fieldName} ?? false);`);
            } else if (tsType === 'string') {
                lines.push(`            Proto.writeString(arr, ${tagNum}, m.${fieldName});`);
            } else if (tsType === 'Uint8Array') {
                lines.push(`            Proto.writeBytes(arr, ${tagNum}, m.${fieldName});`);
            }
            tagNum++;
        }
        
        lines.push('            return new Uint8Array(arr);');
        lines.push('        }');
        lines.push('');
    }
    
    // Generate decode methods per message
    for (const msg of messages) {
        const msgName = msg.name;
        lines.push(`        private decode${msgName}(data: Uint8Array): ${msgName} {`);
        lines.push(`            const m: ${msgName} = {} as ${msgName};`);
        lines.push('            const pos = { v: 0 };');
        lines.push('            while (pos.v < data.length) {');
        lines.push('                const { tag, wireType } = Proto.readTag(data, pos);');
        lines.push('                switch (tag) {');
        
        let tagNum = 1;
        for (const field of msg.fields || []) {
            const fieldName = field.name;
            const tsType = mapToTypeScriptType(field.type);
            
            lines.push(`                    case ${tagNum}:`);
            if (tsType === 'bigint') {
                lines.push(`                        m.${fieldName} = Proto.readInt64(data, pos);`);
            } else if (tsType === 'number' && (field.type === 'float' || field.type === 'double')) {
                if (field.type === 'float') {
                    lines.push(`                        m.${fieldName} = Proto.readFloat(data, pos);`);
                } else {
                    lines.push(`                        m.${fieldName} = Proto.readDouble(data, pos);`);
                }
            } else if (tsType === 'number') {
                lines.push(`                        m.${fieldName} = Proto.readInt32(data, pos);`);
            } else if (tsType === 'boolean') {
                lines.push(`                        m.${fieldName} = Proto.readBool(data, pos);`);
            } else if (tsType === 'string') {
                lines.push(`                        m.${fieldName} = Proto.readString(data, pos);`);
            } else if (tsType === 'Uint8Array') {
                lines.push(`                        m.${fieldName} = Proto.readBytes(data, pos);`);
            }
            lines.push('                        break;');
            tagNum++;
        }
        
        lines.push('                    default:');
        lines.push('                        Proto.skip(data, pos, wireType);');
        lines.push('                        break;');
        lines.push('                }');
        lines.push('            }');
        lines.push('            return m;');
        lines.push('        }');
        lines.push('');
    }
    
    // ICodec interface methods
    lines.push('        encode<T>(message: T): Uint8Array {');
    lines.push('            // Type dispatch - caller should use encodeByOpcode when possible');
    for (const msg of messages) {
        lines.push(`            if ((message as unknown as ${msg.name}).${(msg.fields?.[0]?.name) || 'toString'} !== undefined) {`);
        lines.push(`                // Heuristic check - may need refinement`);
        lines.push('            }');
    }
    lines.push('            throw new Error("Unknown message type for encode");');
    lines.push('        }');
    lines.push('');
    
    lines.push('        encodeByOpcode<T>(opcode: number, message: T): Uint8Array {');
    lines.push('            switch (opcode) {');
    for (const msg of messages) {
        lines.push(`                case Opcodes.${msg.name}: return this.encode${msg.name}(message as unknown as ${msg.name});`);
    }
    lines.push('                default: throw new Error(`Unknown opcode: ${opcode}`);');
    lines.push('            }');
    lines.push('        }');
    lines.push('');
    
    lines.push('        decode<T>(data: Uint8Array): T {');
    lines.push('            throw new Error("Use decodeByOpcode instead");');
    lines.push('        }');
    lines.push('');
    
    lines.push('        decodeByOpcode(opcode: number, data: Uint8Array): unknown {');
    lines.push('            switch (opcode) {');
    for (const msg of messages) {
        lines.push(`                case Opcodes.${msg.name}: return this.decode${msg.name}(data);`);
    }
    lines.push('                default: throw new Error(`Unknown opcode: ${opcode}`);');
    lines.push('            }');
    lines.push('        }');
    
    lines.push('    }');
}

function generateStub(lines, messages, protocolName) {
    lines.push('    /** Message handler type */');
    lines.push('    export type MessageHandler<T> = (sessionId: number, message: T) => void | Promise<void>;');
    lines.push('');
    lines.push('    /**');
    lines.push(`     * Stub for ${protocolName} handlers.`);
    lines.push('     * Register handlers with on{MessageName}() methods.');
    lines.push('     */');
    lines.push('    export class Stub {');
    lines.push('        private codec: ICodec;');
    lines.push('        private handlers = new Map<number, Set<MessageHandler<unknown>>>();');
    lines.push('');
    lines.push('        constructor(codec?: ICodec) {');
    lines.push('            this.codec = codec ?? new CodecProtobuf();');
    lines.push('        }');
    lines.push('');

    // Dispatch method
    lines.push('        async dispatch(sessionId: number, opcode: number, payload: Uint8Array): Promise<void> {');
    lines.push('            const handlerSet = this.handlers.get(opcode);');
    lines.push('            if (!handlerSet || handlerSet.size === 0) return;');
    lines.push('');
    lines.push('            const message = this.codec.decodeByOpcode(opcode, payload);');
    lines.push('            for (const handler of handlerSet) {');
    lines.push('                await handler(sessionId, message);');
    lines.push('            }');
    lines.push('        }');
    lines.push('');

    // Register/unregister per message
    for (const msg of messages) {
        lines.push(`        on${msg.name}(handler: MessageHandler<${msg.name}>): () => void {`);
        lines.push(`            return this.register(Opcodes.${msg.name}, handler as MessageHandler<unknown>);`);
        lines.push('        }');
        lines.push('');
    }

    // Private register method
    lines.push('        private register(opcode: number, handler: MessageHandler<unknown>): () => void {');
    lines.push('            if (!this.handlers.has(opcode)) {');
    lines.push('                this.handlers.set(opcode, new Set());');
    lines.push('            }');
    lines.push('            this.handlers.get(opcode)!.add(handler);');
    lines.push('');
    lines.push('            // Return unsubscribe function');
    lines.push('            return () => {');
    lines.push('                this.handlers.get(opcode)?.delete(handler);');
    lines.push('            };');
    lines.push('        }');
    lines.push('    }');
}

function generateProxy(lines, messages, protocolName) {
    lines.push('    /** Send function type */');
    lines.push('    export type SendFn = (sessionId: number, frame: Uint8Array) => void | Promise<void>;');
    lines.push('');
    lines.push('    /**');
    lines.push(`     * Proxy for sending ${protocolName} messages.`);
    lines.push('     */');
    lines.push('    export class Proxy {');
    lines.push('        private sendFn: SendFn;');
    lines.push('        private codec: ICodec;');
    lines.push('');
    lines.push('        constructor(sendFn: SendFn, codec?: ICodec) {');
    lines.push('            this.sendFn = sendFn;');
    lines.push('            this.codec = codec ?? new CodecProtobuf();');
    lines.push('        }');
    lines.push('');

    // Frame helper
    lines.push('        private packFrame(opcode: number, payload: Uint8Array): Uint8Array {');
    lines.push('            const frame = new Uint8Array(4 + payload.length);');
    lines.push('            const view = new DataView(frame.buffer);');
    lines.push('            view.setInt32(0, opcode, true); // little-endian');
    lines.push('            frame.set(payload, 4);');
    lines.push('            return frame;');
    lines.push('        }');
    lines.push('');

    // Send methods per message
    for (const msg of messages) {
        lines.push(`        async send${msg.name}(sessionId: number, message: ${msg.name}): Promise<void> {`);
        lines.push(`            const payload = this.codec.encodeByOpcode(Opcodes.${msg.name}, message);`);
        lines.push(`            const frame = this.packFrame(Opcodes.${msg.name}, payload);`);
        lines.push('            await this.sendFn(sessionId, frame);');
        lines.push('        }');
        lines.push('');
    }

    lines.push('    }');
}

// ============================================================================
// Type Mapping
// ============================================================================

function mapToTypeScriptType(type) {
    const isArray = type.endsWith('[]');
    const baseType = isArray ? type.slice(0, -2) : type;

    // Handle map<K,V> type
    const mapMatch = baseType.match(/^map<\s*(\w+)\s*,\s*(\w+)\s*>$/);
    if (mapMatch) {
        const keyType = mapToTypeScriptType(mapMatch[1]);
        const valueType = mapToTypeScriptType(mapMatch[2]);
        const recordType = `Record<${keyType}, ${valueType}>`;
        return isArray ? `${recordType}[]` : recordType;
    }

    // Complex alias mapping (priority)
    const aliasType = mapTsType(baseType);
    if (aliasType) {
        return isArray ? `(${aliasType})[]` : aliasType;
    }

    const typeMap = {
        'int32': 'number',
        'int64': 'bigint',
        'uint32': 'number',
        'uint64': 'bigint',
        'sint32': 'number',
        'sint64': 'bigint',
        'float': 'number',
        'double': 'number',
        'bool': 'boolean',
        'string': 'string',
        'bytes': 'Uint8Array',
    };

    const tsBase = typeMap[baseType] || baseType;
    return isArray ? `${tsBase}[]` : tsBase;
}

// ============================================================================
// Server Runtime Generator
// ============================================================================

/**
 * Generate ServerRuntime.g.ts for a protocol group
 * @param {string} groupName - Protocol group name (e.g., "Client")
 * @param {Array<{name: string, direction: string}>} protocols - Protocol info array
 * @returns {string|null} Generated TypeScript code, or null if no ServerRuntime needed
 * @throws {Error} If protocol configuration is ambiguous (not exactly 1 inbound + 1 outbound)
 */
export function generateServerRuntime(groupName, protocols) {
    // Separate by direction
    const inbound = protocols.filter(p => p.direction === 'client_to_server');
    const outbound = protocols.filter(p => p.direction === 'server_to_client');
    const bidirectional = protocols.filter(p => p.direction === 'bidirectional' || !p.direction);

    // Case 1: Only bidirectional protocols → no ServerRuntime needed
    if (inbound.length === 0 && outbound.length === 0) {
        return null;
    }

    // Case 2: Ambiguous configuration → error
    if (inbound.length === 0 || outbound.length === 0) {
        throw new Error(
            `[ServerRuntime] Protocol group '${groupName}' has ambiguous direction config: ` +
            `${inbound.length} inbound, ${outbound.length} outbound. ` +
            `ServerRuntime requires exactly 1 inbound + 1 outbound.`
        );
    }

    if (inbound.length !== 1 || outbound.length !== 1) {
        throw new Error(
            `[ServerRuntime] Protocol group '${groupName}' has multiple protocols per direction: ` +
            `${inbound.length} inbound (${inbound.map(p => p.name).join(', ')}), ` +
            `${outbound.length} outbound (${outbound.map(p => p.name).join(', ')}). ` +
            `ServerRuntime requires exactly 1 inbound + 1 outbound.`
        );
    }

    // Case 3: Exactly 1 inbound + 1 outbound → generate ServerRuntime
    const inboundName = inbound[0].name;  // e.g., "C2Game"
    const outboundName = outbound[0].name; // e.g., "Game2C"

    const lines = [];

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push(`// This file provides server-side runtime for protocol group: ${groupName}`);
    lines.push('// </auto-generated>');
    lines.push('');

    // Imports (no .js extension)
    lines.push(`import type { INetworkRuntime, SendFn, ICodec, UnknownOpcodeEvent } from '@devian/core';`);
    lines.push(`import { ${inboundName} } from './${inboundName}.g';`);
    lines.push(`import { ${outboundName} } from './${outboundName}.g';`);
    lines.push('');

    // Unknown handler type
    lines.push('/** Unknown opcode handler type */');
    lines.push('export type UnknownOpcodeHandler = (event: UnknownOpcodeEvent) => void | Promise<void>;');
    lines.push('');

    // Class
    lines.push('/**');
    lines.push(` * Server Runtime for ${groupName} protocol group`);
    lines.push(' * ');
    lines.push(` * - Inbound: ${inboundName} (client → server)`);
    lines.push(` * - Outbound: ${outboundName} (server → client)`);
    lines.push(' */');
    lines.push(`export class NetworkServerRuntime implements INetworkRuntime {`);
    lines.push(`    private readonly stub: ${inboundName}.Stub;`);
    lines.push('    private readonly codec: ICodec | null;');
    lines.push('    private unknownHandler: UnknownOpcodeHandler | null = null;');
    lines.push('');
    lines.push('    constructor(codec?: ICodec) {');
    lines.push('        this.codec = codec ?? null;');
    lines.push(`        this.stub = this.codec ? new ${inboundName}.Stub(this.codec) : new ${inboundName}.Stub();`);
    lines.push('    }');
    lines.push('');

    // getStub
    lines.push('    /**');
    lines.push('     * Get inbound stub for handler registration');
    lines.push('     */');
    lines.push(`    getStub(): ${inboundName}.Stub {`);
    lines.push('        return this.stub;');
    lines.push('    }');
    lines.push('');

    // getInboundOpcodeName
    lines.push('    getInboundOpcodeName(opcode: number): string | null {');
    lines.push(`        return ${inboundName}.getOpcodeName(opcode) ?? null;`);
    lines.push('    }');
    lines.push('');

    // dispatchInbound
    lines.push('    async dispatchInbound(sessionId: number, opcode: number, payload: Uint8Array): Promise<void> {');
    lines.push('        await this.stub.dispatch(sessionId, opcode, payload);');
    lines.push('    }');
    lines.push('');

    // createOutboundProxy
    lines.push(`    createOutboundProxy(sendFn: SendFn): ${outboundName}.Proxy {`);
    lines.push(`        return this.codec ? new ${outboundName}.Proxy(sendFn, this.codec) : new ${outboundName}.Proxy(sendFn);`);
    lines.push('    }');
    lines.push('');

    // setUnknownInboundOpcode
    lines.push('    /**');
    lines.push('     * Set handler for unknown inbound opcodes.');
    lines.push('     * @param handler Handler function (async supported)');
    lines.push('     */');
    lines.push('    setUnknownInboundOpcode(handler: UnknownOpcodeHandler): void {');
    lines.push('        this.unknownHandler = handler;');
    lines.push('    }');
    lines.push('');

    // handleUnknownInboundOpcode
    lines.push('    /**');
    lines.push('     * Handle unknown inbound opcode.');
    lines.push('     * Called by NetworkServer when opcode is not recognized.');
    lines.push('     * Exceptions are caught and logged, never propagated.');
    lines.push('     */');
    lines.push('    async handleUnknownInboundOpcode(event: UnknownOpcodeEvent): Promise<void> {');
    lines.push('        try {');
    lines.push('            if (this.unknownHandler) {');
    lines.push('                await this.unknownHandler(event);');
    lines.push('            } else {');
    lines.push('                console.warn(');
    lines.push(`                    \`[NetworkServerRuntime] Unknown opcode \${event.opcode} from session \${event.sessionId} (\${event.payload.length} bytes)\``);
    lines.push('                );');
    lines.push('            }');
    lines.push('        } catch (err) {');
    lines.push(`            console.error(\`[NetworkServerRuntime] unknown handler failed\`, err);`);
    lines.push('        }');
    lines.push('    }');
    lines.push('}');
    lines.push('');

    // Factory function
    lines.push('/**');
    lines.push(` * Create server runtime for ${groupName} protocol group`);
    lines.push(' * @param codec Optional codec (default: protobuf codec from Stub/Proxy)');
    lines.push(' */');
    lines.push(`export function createServerRuntime(codec?: ICodec): NetworkServerRuntime {`);
    lines.push(`    return new NetworkServerRuntime(codec);`);
    lines.push('}');
    lines.push('');

    // Re-exports
    lines.push('/** Re-export types for convenience */');
    lines.push(`export { ${inboundName}, ${outboundName} };`);

    return lines.join('\n');
}

// ============================================================================
// Client Runtime Generator
// ============================================================================

/**
 * Generate ClientRuntime.g.ts for a protocol group
 * @param {string} groupName - Protocol group name (e.g., "Client")
 * @param {Array<{name: string, direction: string}>} protocols - Protocol info array
 * @returns {string|null} Generated TypeScript code, or null if no ClientRuntime needed
 * @throws {Error} If protocol configuration is ambiguous
 */
export function generateClientRuntime(groupName, protocols) {
    // For client runtime, directions are reversed:
    // - inbound: server_to_client (e.g., Game2C)
    // - outbound: client_to_server (e.g., C2Game)
    const inbound = protocols.filter(p => p.direction === 'server_to_client');
    const outbound = protocols.filter(p => p.direction === 'client_to_server');
    const bidirectional = protocols.filter(p => p.direction === 'bidirectional' || !p.direction);

    // Case 1: Only bidirectional protocols → no ClientRuntime needed
    if (inbound.length === 0 && outbound.length === 0) {
        return null;
    }

    // Case 2: Ambiguous configuration → error
    if (inbound.length === 0 || outbound.length === 0) {
        throw new Error(
            `[ClientRuntime] Protocol group '${groupName}' has ambiguous direction config: ` +
            `${inbound.length} inbound (server→client), ${outbound.length} outbound (client→server). ` +
            `ClientRuntime requires exactly 1 inbound + 1 outbound.`
        );
    }

    if (inbound.length !== 1 || outbound.length !== 1) {
        throw new Error(
            `[ClientRuntime] Protocol group '${groupName}' has multiple protocols per direction: ` +
            `${inbound.length} inbound (${inbound.map(p => p.name).join(', ')}), ` +
            `${outbound.length} outbound (${outbound.map(p => p.name).join(', ')}). ` +
            `ClientRuntime requires exactly 1 inbound + 1 outbound.`
        );
    }

    // Case 3: Exactly 1 inbound + 1 outbound → generate ClientRuntime
    const inboundName = inbound[0].name;   // e.g., "Game2C" (server → client)
    const outboundName = outbound[0].name; // e.g., "C2Game" (client → server)

    const lines = [];

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push(`// This file provides client-side runtime for protocol group: ${groupName}`);
    lines.push('// </auto-generated>');
    lines.push('');

    // Imports (no .js extension)
    lines.push(`import type { INetworkRuntime, SendFn, ICodec, UnknownOpcodeEvent } from '@devian/core';`);
    lines.push(`import { ${inboundName} } from './${inboundName}.g';`);
    lines.push(`import { ${outboundName} } from './${outboundName}.g';`);
    lines.push('');

    // Unknown handler type
    lines.push('/** Unknown opcode handler type */');
    lines.push('export type UnknownOpcodeHandler = (event: UnknownOpcodeEvent) => void | Promise<void>;');
    lines.push('');

    // Class
    lines.push('/**');
    lines.push(` * Client Runtime for ${groupName} protocol group`);
    lines.push(' * ');
    lines.push(` * - Inbound: ${inboundName} (server → client)`);
    lines.push(` * - Outbound: ${outboundName} (client → server)`);
    lines.push(' */');
    lines.push(`export class NetworkClientRuntime implements INetworkRuntime {`);
    lines.push(`    private readonly stub: ${inboundName}.Stub;`);
    lines.push('    private readonly codec: ICodec | null;');
    lines.push('    private unknownHandler: UnknownOpcodeHandler | null = null;');
    lines.push('');
    lines.push('    constructor(codec?: ICodec) {');
    lines.push('        this.codec = codec ?? null;');
    lines.push(`        this.stub = this.codec ? new ${inboundName}.Stub(this.codec) : new ${inboundName}.Stub();`);
    lines.push('    }');
    lines.push('');

    // getStub
    lines.push('    /**');
    lines.push('     * Get inbound stub for handler registration');
    lines.push('     */');
    lines.push(`    getStub(): ${inboundName}.Stub {`);
    lines.push('        return this.stub;');
    lines.push('    }');
    lines.push('');

    // getInboundOpcodeName
    lines.push('    getInboundOpcodeName(opcode: number): string | null {');
    lines.push(`        return ${inboundName}.getOpcodeName(opcode) ?? null;`);
    lines.push('    }');
    lines.push('');

    // dispatchInbound
    lines.push('    async dispatchInbound(sessionId: number, opcode: number, payload: Uint8Array): Promise<void> {');
    lines.push('        await this.stub.dispatch(sessionId, opcode, payload);');
    lines.push('    }');
    lines.push('');

    // createOutboundProxy
    lines.push(`    createOutboundProxy(sendFn: SendFn): ${outboundName}.Proxy {`);
    lines.push(`        return this.codec ? new ${outboundName}.Proxy(sendFn, this.codec) : new ${outboundName}.Proxy(sendFn);`);
    lines.push('    }');
    lines.push('');

    // setUnknownInboundOpcode
    lines.push('    /**');
    lines.push('     * Set handler for unknown inbound opcodes.');
    lines.push('     * @param handler Handler function (async supported)');
    lines.push('     */');
    lines.push('    setUnknownInboundOpcode(handler: UnknownOpcodeHandler): void {');
    lines.push('        this.unknownHandler = handler;');
    lines.push('    }');
    lines.push('');

    // handleUnknownInboundOpcode
    lines.push('    /**');
    lines.push('     * Handle unknown inbound opcode.');
    lines.push('     * Called by NetworkClient when opcode is not recognized.');
    lines.push('     * Exceptions are caught and logged, never propagated.');
    lines.push('     */');
    lines.push('    async handleUnknownInboundOpcode(event: UnknownOpcodeEvent): Promise<void> {');
    lines.push('        try {');
    lines.push('            if (this.unknownHandler) {');
    lines.push('                await this.unknownHandler(event);');
    lines.push('            } else {');
    lines.push('                console.warn(');
    lines.push(`                    \`[NetworkClientRuntime] Unknown opcode \${event.opcode} (\${event.payload.length} bytes)\``);
    lines.push('                );');
    lines.push('            }');
    lines.push('        } catch (err) {');
    lines.push(`            console.error(\`[NetworkClientRuntime] unknown handler failed\`, err);`);
    lines.push('        }');
    lines.push('    }');
    lines.push('}');
    lines.push('');

    // Factory function
    lines.push('/**');
    lines.push(` * Create client runtime for ${groupName} protocol group`);
    lines.push(' * @param codec Optional codec (default: protobuf codec from Stub/Proxy)');
    lines.push(' * @returns Runtime instance with stub access and proxy factory');
    lines.push(' */');
    lines.push(`export function createClientRuntime(codec?: ICodec): {`);
    lines.push(`    runtime: NetworkClientRuntime;`);
    lines.push(`    ${inboundName.charAt(0).toLowerCase() + inboundName.slice(1)}Stub: ${inboundName}.Stub;`);
    lines.push(`    ${outboundName.charAt(0).toLowerCase() + outboundName.slice(1)}ProxyFactory: (sendFn: SendFn) => ${outboundName}.Proxy;`);
    lines.push('} {');
    lines.push(`    const runtime = new NetworkClientRuntime(codec);`);
    lines.push('    return {');
    lines.push('        runtime,');
    lines.push(`        ${inboundName.charAt(0).toLowerCase() + inboundName.slice(1)}Stub: runtime.getStub(),`);
    lines.push(`        ${outboundName.charAt(0).toLowerCase() + outboundName.slice(1)}ProxyFactory: (sendFn) => runtime.createOutboundProxy(sendFn),`);
    lines.push('    };');
    lines.push('}');
    lines.push('');

    // Re-exports
    lines.push('/** Re-export types for convenience */');
    lines.push(`export { ${inboundName}, ${outboundName} };`);

    return lines.join('\n');
}

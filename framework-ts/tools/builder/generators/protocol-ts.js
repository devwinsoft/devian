// <auto-generated>
// Devian Build System v10 - TypeScript Protocol Generator
// SSOT: skills/devian/03-ssot/SKILL.md
// Namespace: export namespace {ProtocolName} + Devian.Network.{group} alias
// </auto-generated>

import { mapTsType } from './protocol-type-mapper.js';

/**
 * Generate TypeScript protocol code from protocol spec
 * @param {Object} spec - Protocol specification
 * @param {string} protocolName - Protocol name (e.g., "C2Game")
 * @param {string} groupName - Protocol group name (e.g., "Game")
 * @returns {string} Generated TypeScript code
 */
export function generateTypeScriptProtocol(spec, protocolName, groupName) {
    const lines = [];

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push(`// Protocol: ${protocolName} (Group: ${groupName})`);
    lines.push('// </auto-generated>');
    lines.push('');

    // Direction comment
    if (spec.direction && spec.direction !== 'bidirectional') {
        lines.push(`// Direction: ${spec.direction}`);
        lines.push('');
    }

    // Main namespace (flat for easy import)
    lines.push(`export namespace ${protocolName} {`);
    lines.push('');

    // Message interfaces
    for (const message of spec.messages || []) {
        generateMessageInterface(lines, message);
        lines.push('');
    }

    // Opcodes
    generateOpcodesObject(lines, spec.messages || []);
    lines.push('');

    // ICodec interface
    generateICodecInterface(lines);
    lines.push('');

    // CodecJson
    generateCodecJson(lines, spec.messages || []);
    lines.push('');

    // CodecProtobuf
    generateCodecProtobuf(lines, spec.messages || []);
    lines.push('');

    // Stub class
    generateStub(lines, spec.messages || [], protocolName);
    lines.push('');

    // Proxy class
    generateProxy(lines, spec.messages || [], protocolName);

    lines.push('}'); // end namespace ProtocolName
    lines.push('');

    return lines.join('\n');
}

// ============================================================================
// Generator Functions
// ============================================================================

function generateMessageInterface(lines, message) {
    lines.push(`    /** ${message.name} message */`);
    lines.push(`    export interface ${message.name} {`);

    for (const field of message.fields || []) {
        const tsType = mapToTypeScriptType(field.type);
        const optional = field.optional ? '?' : '';
        lines.push(`        ${field.name}${optional}: ${tsType};`);
    }

    lines.push('    }');
}

function generateOpcodesObject(lines, messages) {
    lines.push('    /** Opcode constants */');
    lines.push('    export const Opcodes = {');
    for (const msg of messages) {
        lines.push(`        ${msg.name}: ${msg.opcode},`);
    }
    lines.push('    } as const;');
    lines.push('');
    lines.push('    export type OpcodeType = typeof Opcodes[keyof typeof Opcodes];');
    lines.push('');
    lines.push('    export function getOpcodeName(opcode: number): string | undefined {');
    lines.push('        const entries = Object.entries(Opcodes);');
    lines.push('        const found = entries.find(([_, v]) => v === opcode);');
    lines.push('        return found?.[0];');
    lines.push('    }');
}

function generateICodecInterface(lines) {
    lines.push('    /** Codec interface */');
    lines.push('    export interface ICodec {');
    lines.push('        encode<T>(message: T): Uint8Array;');
    lines.push('        decode<T>(data: Uint8Array): T;');
    lines.push('        decodeByOpcode(opcode: number, data: Uint8Array): unknown;');
    lines.push('    }');
}

function generateCodecJson(lines, messages) {
    lines.push('    /** JSON Codec implementation */');
    lines.push('    export class CodecJson implements ICodec {');
    lines.push('        private encoder = new TextEncoder();');
    lines.push('        private decoder = new TextDecoder();');
    lines.push('');
    lines.push('        encode<T>(message: T): Uint8Array {');
    lines.push('            const json = JSON.stringify(message);');
    lines.push('            return this.encoder.encode(json);');
    lines.push('        }');
    lines.push('');
    lines.push('        decode<T>(data: Uint8Array): T {');
    lines.push('            const json = this.decoder.decode(data);');
    lines.push('            return JSON.parse(json) as T;');
    lines.push('        }');
    lines.push('');
    lines.push('        decodeByOpcode(opcode: number, data: Uint8Array): unknown {');
    lines.push('            return this.decode(data);');
    lines.push('        }');
    lines.push('    }');
}

function generateCodecProtobuf(lines, messages) {
    lines.push('    /**');
    lines.push('     * Protobuf Codec implementation.');
    lines.push('     * Requires message encoders/decoders to be registered.');
    lines.push('     */');
    lines.push('    export class CodecProtobuf implements ICodec {');
    lines.push('        private encoders = new Map<number, (message: unknown) => Uint8Array>();');
    lines.push('        private decoders = new Map<number, (data: Uint8Array) => unknown>();');
    lines.push('        private fallbackCodec = new CodecJson();');
    lines.push('');
    lines.push('        /**');
    lines.push('         * Register encoder for a specific opcode.');
    lines.push('         */');
    lines.push('        registerEncoder(opcode: number, encoder: (message: unknown) => Uint8Array): void {');
    lines.push('            this.encoders.set(opcode, encoder);');
    lines.push('        }');
    lines.push('');
    lines.push('        /**');
    lines.push('         * Register decoder for a specific opcode.');
    lines.push('         */');
    lines.push('        registerDecoder(opcode: number, decoder: (data: Uint8Array) => unknown): void {');
    lines.push('            this.decoders.set(opcode, decoder);');
    lines.push('        }');
    lines.push('');
    lines.push('        encode<T>(message: T): Uint8Array {');
    lines.push('            // Generic encode falls back to JSON');
    lines.push('            return this.fallbackCodec.encode(message);');
    lines.push('        }');
    lines.push('');
    lines.push('        /**');
    lines.push('         * Encode message by opcode using registered encoder.');
    lines.push('         */');
    lines.push('        encodeByOpcode<T>(opcode: number, message: T): Uint8Array {');
    lines.push('            const encoder = this.encoders.get(opcode);');
    lines.push('            if (encoder) {');
    lines.push('                return encoder(message);');
    lines.push('            }');
    lines.push('            return this.fallbackCodec.encode(message);');
    lines.push('        }');
    lines.push('');
    lines.push('        decode<T>(data: Uint8Array): T {');
    lines.push('            // Generic decode falls back to JSON');
    lines.push('            return this.fallbackCodec.decode(data);');
    lines.push('        }');
    lines.push('');
    lines.push('        decodeByOpcode(opcode: number, data: Uint8Array): unknown {');
    lines.push('            const decoder = this.decoders.get(opcode);');
    lines.push('            if (decoder) {');
    lines.push('                return decoder(data);');
    lines.push('            }');
    lines.push('            return this.fallbackCodec.decode(data);');
    lines.push('        }');
    lines.push('    }');
}

function generateStub(lines, messages, protocolName) {
    lines.push('    /** Message handler type */');
    lines.push('    export type MessageHandler<T> = (sessionId: number, message: T) => void | Promise<void>;');
    lines.push('');
    lines.push('    /**');
    lines.push(`     * Stub for ${protocolName} handlers.`);
    lines.push('     * Register handlers with on{MessageName}() methods.');
    lines.push('     */');
    lines.push('    export class Stub {');
    lines.push('        private codec: ICodec;');
    lines.push('        private handlers = new Map<number, Set<MessageHandler<unknown>>>();');
    lines.push('');
    lines.push('        constructor(codec?: ICodec) {');
    lines.push('            this.codec = codec ?? new CodecJson();');
    lines.push('        }');
    lines.push('');

    // Dispatch method
    lines.push('        async dispatch(sessionId: number, opcode: number, payload: Uint8Array): Promise<void> {');
    lines.push('            const handlerSet = this.handlers.get(opcode);');
    lines.push('            if (!handlerSet || handlerSet.size === 0) return;');
    lines.push('');
    lines.push('            const message = this.codec.decodeByOpcode(opcode, payload);');
    lines.push('            for (const handler of handlerSet) {');
    lines.push('                await handler(sessionId, message);');
    lines.push('            }');
    lines.push('        }');
    lines.push('');

    // Register/unregister per message
    for (const msg of messages) {
        lines.push(`        on${msg.name}(handler: MessageHandler<${msg.name}>): () => void {`);
        lines.push(`            return this.register(Opcodes.${msg.name}, handler as MessageHandler<unknown>);`);
        lines.push('        }');
        lines.push('');
    }

    // Private register method
    lines.push('        private register(opcode: number, handler: MessageHandler<unknown>): () => void {');
    lines.push('            if (!this.handlers.has(opcode)) {');
    lines.push('                this.handlers.set(opcode, new Set());');
    lines.push('            }');
    lines.push('            this.handlers.get(opcode)!.add(handler);');
    lines.push('');
    lines.push('            // Return unsubscribe function');
    lines.push('            return () => {');
    lines.push('                this.handlers.get(opcode)?.delete(handler);');
    lines.push('            };');
    lines.push('        }');
    lines.push('    }');
}

function generateProxy(lines, messages, protocolName) {
    lines.push('    /** Send function type */');
    lines.push('    export type SendFn = (sessionId: number, frame: Uint8Array) => void | Promise<void>;');
    lines.push('');
    lines.push('    /**');
    lines.push(`     * Proxy for sending ${protocolName} messages.`);
    lines.push('     */');
    lines.push('    export class Proxy {');
    lines.push('        private sendFn: SendFn;');
    lines.push('        private codec: ICodec;');
    lines.push('');
    lines.push('        constructor(sendFn: SendFn, codec?: ICodec) {');
    lines.push('            this.sendFn = sendFn;');
    lines.push('            this.codec = codec ?? new CodecJson();');
    lines.push('        }');
    lines.push('');

    // Frame helper
    lines.push('        private packFrame(opcode: number, payload: Uint8Array): Uint8Array {');
    lines.push('            const frame = new Uint8Array(4 + payload.length);');
    lines.push('            const view = new DataView(frame.buffer);');
    lines.push('            view.setInt32(0, opcode, true); // little-endian');
    lines.push('            frame.set(payload, 4);');
    lines.push('            return frame;');
    lines.push('        }');
    lines.push('');

    // Send methods per message
    for (const msg of messages) {
        lines.push(`        async send${msg.name}(sessionId: number, message: ${msg.name}): Promise<void> {`);
        lines.push('            const payload = this.codec.encode(message);');
        lines.push(`            const frame = this.packFrame(Opcodes.${msg.name}, payload);`);
        lines.push('            await this.sendFn(sessionId, frame);');
        lines.push('        }');
        lines.push('');
    }

    lines.push('    }');
}

// ============================================================================
// Type Mapping
// ============================================================================

function mapToTypeScriptType(type) {
    const isArray = type.endsWith('[]');
    const baseType = isArray ? type.slice(0, -2) : type;

    // Handle map<K,V> type
    const mapMatch = baseType.match(/^map<\s*(\w+)\s*,\s*(\w+)\s*>$/);
    if (mapMatch) {
        const keyType = mapToTypeScriptType(mapMatch[1]);
        const valueType = mapToTypeScriptType(mapMatch[2]);
        const recordType = `Record<${keyType}, ${valueType}>`;
        return isArray ? `${recordType}[]` : recordType;
    }

    // Complex alias mapping (priority)
    const aliasType = mapTsType(baseType);
    if (aliasType) {
        return isArray ? `(${aliasType})[]` : aliasType;
    }

    const typeMap = {
        'int32': 'number',
        'int64': 'bigint',
        'uint32': 'number',
        'uint64': 'bigint',
        'sint32': 'number',
        'sint64': 'bigint',
        'float': 'number',
        'double': 'number',
        'bool': 'boolean',
        'string': 'string',
        'bytes': 'Uint8Array',
    };

    const tsBase = typeMap[baseType] || baseType;
    return isArray ? `${tsBase}[]` : tsBase;
}

// ============================================================================
// Server Runtime Generator
// ============================================================================

/**
 * Generate ServerRuntime.g.ts for a protocol group
 * @param {string} groupName - Protocol group name (e.g., "Client")
 * @param {Array<{name: string, direction: string}>} protocols - Protocol info array
 * @returns {string|null} Generated TypeScript code, or null if no ServerRuntime needed
 * @throws {Error} If protocol configuration is ambiguous (not exactly 1 inbound + 1 outbound)
 */
export function generateServerRuntime(groupName, protocols) {
    // Separate by direction
    const inbound = protocols.filter(p => p.direction === 'client_to_server');
    const outbound = protocols.filter(p => p.direction === 'server_to_client');
    const bidirectional = protocols.filter(p => p.direction === 'bidirectional' || !p.direction);

    // Case 1: Only bidirectional protocols → no ServerRuntime needed
    if (inbound.length === 0 && outbound.length === 0) {
        return null;
    }

    // Case 2: Ambiguous configuration → error
    if (inbound.length === 0 || outbound.length === 0) {
        throw new Error(
            `[ServerRuntime] Protocol group '${groupName}' has ambiguous direction config: ` +
            `${inbound.length} inbound, ${outbound.length} outbound. ` +
            `ServerRuntime requires exactly 1 inbound + 1 outbound.`
        );
    }

    if (inbound.length !== 1 || outbound.length !== 1) {
        throw new Error(
            `[ServerRuntime] Protocol group '${groupName}' has multiple protocols per direction: ` +
            `${inbound.length} inbound (${inbound.map(p => p.name).join(', ')}), ` +
            `${outbound.length} outbound (${outbound.map(p => p.name).join(', ')}). ` +
            `ServerRuntime requires exactly 1 inbound + 1 outbound.`
        );
    }

    // Case 3: Exactly 1 inbound + 1 outbound → generate ServerRuntime
    const inboundName = inbound[0].name;  // e.g., "C2Game"
    const outboundName = outbound[0].name; // e.g., "Game2C"

    const lines = [];

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push(`// This file provides server-side runtime for protocol group: ${groupName}`);
    lines.push('// </auto-generated>');
    lines.push('');

    // Imports (no .js extension)
    lines.push(`import type { INetworkRuntime, SendFn, ICodec, UnknownOpcodeEvent } from '@devian/network';`);
    lines.push(`import { ${inboundName} } from '../${inboundName}.g';`);
    lines.push(`import { ${outboundName} } from '../${outboundName}.g';`);
    lines.push('');

    // Unknown handler type
    lines.push('/** Unknown opcode handler type */');
    lines.push('export type UnknownOpcodeHandler = (event: UnknownOpcodeEvent) => void | Promise<void>;');
    lines.push('');

    // Class
    lines.push('/**');
    lines.push(` * Server Runtime for ${groupName} protocol group`);
    lines.push(' * ');
    lines.push(` * - Inbound: ${inboundName} (client → server)`);
    lines.push(` * - Outbound: ${outboundName} (server → client)`);
    lines.push(' */');
    lines.push(`export class NetworkServerRuntime implements INetworkRuntime {`);
    lines.push(`    private readonly stub: ${inboundName}.Stub;`);
    lines.push('    private readonly codec: ICodec;');
    lines.push('    private unknownHandler: UnknownOpcodeHandler | null = null;');
    lines.push('');
    lines.push('    constructor(codec: ICodec) {');
    lines.push('        this.codec = codec;');
    lines.push(`        this.stub = new ${inboundName}.Stub(codec);`);
    lines.push('    }');
    lines.push('');

    // getStub
    lines.push('    /**');
    lines.push('     * Get inbound stub for handler registration');
    lines.push('     */');
    lines.push(`    getStub(): ${inboundName}.Stub {`);
    lines.push('        return this.stub;');
    lines.push('    }');
    lines.push('');

    // getInboundOpcodeName
    lines.push('    getInboundOpcodeName(opcode: number): string | null {');
    lines.push(`        return ${inboundName}.getOpcodeName(opcode) ?? null;`);
    lines.push('    }');
    lines.push('');

    // dispatchInbound
    lines.push('    async dispatchInbound(sessionId: number, opcode: number, payload: Uint8Array): Promise<void> {');
    lines.push('        await this.stub.dispatch(sessionId, opcode, payload);');
    lines.push('    }');
    lines.push('');

    // createOutboundProxy
    lines.push(`    createOutboundProxy(sendFn: SendFn): ${outboundName}.Proxy {`);
    lines.push(`        return new ${outboundName}.Proxy(sendFn, this.codec);`);
    lines.push('    }');
    lines.push('');

    // setUnknownInboundOpcode
    lines.push('    /**');
    lines.push('     * Set handler for unknown inbound opcodes.');
    lines.push('     * @param handler Handler function (async supported)');
    lines.push('     */');
    lines.push('    setUnknownInboundOpcode(handler: UnknownOpcodeHandler): void {');
    lines.push('        this.unknownHandler = handler;');
    lines.push('    }');
    lines.push('');

    // handleUnknownInboundOpcode
    lines.push('    /**');
    lines.push('     * Handle unknown inbound opcode.');
    lines.push('     * Called by NetworkServer when opcode is not recognized.');
    lines.push('     * Exceptions are caught and logged, never propagated.');
    lines.push('     */');
    lines.push('    async handleUnknownInboundOpcode(event: UnknownOpcodeEvent): Promise<void> {');
    lines.push('        try {');
    lines.push('            if (this.unknownHandler) {');
    lines.push('                await this.unknownHandler(event);');
    lines.push('            } else {');
    lines.push('                console.warn(');
    lines.push(`                    \`[NetworkServerRuntime] Unknown opcode \${event.opcode} from session \${event.sessionId} (\${event.payload.length} bytes)\``);
    lines.push('                );');
    lines.push('            }');
    lines.push('        } catch (err) {');
    lines.push(`            console.error(\`[NetworkServerRuntime] unknown handler failed\`, err);`);
    lines.push('        }');
    lines.push('    }');
    lines.push('}');
    lines.push('');

    // Factory function
    lines.push('/**');
    lines.push(` * Create server runtime for ${groupName} protocol group`);
    lines.push(' */');
    lines.push(`export function createServerRuntime(codec: ICodec): NetworkServerRuntime {`);
    lines.push(`    return new NetworkServerRuntime(codec);`);
    lines.push('}');
    lines.push('');

    // Re-exports
    lines.push('/** Re-export types for convenience */');
    lines.push(`export { ${inboundName}, ${outboundName} };`);

    return lines.join('\n');
}

// ============================================================================
// Client Runtime Generator
// ============================================================================

/**
 * Generate ClientRuntime.g.ts for a protocol group
 * @param {string} groupName - Protocol group name (e.g., "Client")
 * @param {Array<{name: string, direction: string}>} protocols - Protocol info array
 * @returns {string|null} Generated TypeScript code, or null if no ClientRuntime needed
 * @throws {Error} If protocol configuration is ambiguous
 */
export function generateClientRuntime(groupName, protocols) {
    // For client runtime, directions are reversed:
    // - inbound: server_to_client (e.g., Game2C)
    // - outbound: client_to_server (e.g., C2Game)
    const inbound = protocols.filter(p => p.direction === 'server_to_client');
    const outbound = protocols.filter(p => p.direction === 'client_to_server');
    const bidirectional = protocols.filter(p => p.direction === 'bidirectional' || !p.direction);

    // Case 1: Only bidirectional protocols → no ClientRuntime needed
    if (inbound.length === 0 && outbound.length === 0) {
        return null;
    }

    // Case 2: Ambiguous configuration → error
    if (inbound.length === 0 || outbound.length === 0) {
        throw new Error(
            `[ClientRuntime] Protocol group '${groupName}' has ambiguous direction config: ` +
            `${inbound.length} inbound (server→client), ${outbound.length} outbound (client→server). ` +
            `ClientRuntime requires exactly 1 inbound + 1 outbound.`
        );
    }

    if (inbound.length !== 1 || outbound.length !== 1) {
        throw new Error(
            `[ClientRuntime] Protocol group '${groupName}' has multiple protocols per direction: ` +
            `${inbound.length} inbound (${inbound.map(p => p.name).join(', ')}), ` +
            `${outbound.length} outbound (${outbound.map(p => p.name).join(', ')}). ` +
            `ClientRuntime requires exactly 1 inbound + 1 outbound.`
        );
    }

    // Case 3: Exactly 1 inbound + 1 outbound → generate ClientRuntime
    const inboundName = inbound[0].name;   // e.g., "Game2C" (server → client)
    const outboundName = outbound[0].name; // e.g., "C2Game" (client → server)

    const lines = [];

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push(`// This file provides client-side runtime for protocol group: ${groupName}`);
    lines.push('// </auto-generated>');
    lines.push('');

    // Imports (no .js extension)
    lines.push(`import type { INetworkRuntime, SendFn, ICodec, UnknownOpcodeEvent } from '@devian/network';`);
    lines.push(`import { ${inboundName} } from '../${inboundName}.g';`);
    lines.push(`import { ${outboundName} } from '../${outboundName}.g';`);
    lines.push('');

    // Unknown handler type
    lines.push('/** Unknown opcode handler type */');
    lines.push('export type UnknownOpcodeHandler = (event: UnknownOpcodeEvent) => void | Promise<void>;');
    lines.push('');

    // Class
    lines.push('/**');
    lines.push(` * Client Runtime for ${groupName} protocol group`);
    lines.push(' * ');
    lines.push(` * - Inbound: ${inboundName} (server → client)`);
    lines.push(` * - Outbound: ${outboundName} (client → server)`);
    lines.push(' */');
    lines.push(`export class NetworkClientRuntime implements INetworkRuntime {`);
    lines.push(`    private readonly stub: ${inboundName}.Stub;`);
    lines.push('    private readonly codec: ICodec;');
    lines.push('    private unknownHandler: UnknownOpcodeHandler | null = null;');
    lines.push('');
    lines.push('    constructor(codec: ICodec) {');
    lines.push('        this.codec = codec;');
    lines.push(`        this.stub = new ${inboundName}.Stub(codec);`);
    lines.push('    }');
    lines.push('');

    // getStub
    lines.push('    /**');
    lines.push('     * Get inbound stub for handler registration');
    lines.push('     */');
    lines.push(`    getStub(): ${inboundName}.Stub {`);
    lines.push('        return this.stub;');
    lines.push('    }');
    lines.push('');

    // getInboundOpcodeName
    lines.push('    getInboundOpcodeName(opcode: number): string | null {');
    lines.push(`        return ${inboundName}.getOpcodeName(opcode) ?? null;`);
    lines.push('    }');
    lines.push('');

    // dispatchInbound
    lines.push('    async dispatchInbound(sessionId: number, opcode: number, payload: Uint8Array): Promise<void> {');
    lines.push('        await this.stub.dispatch(sessionId, opcode, payload);');
    lines.push('    }');
    lines.push('');

    // createOutboundProxy
    lines.push(`    createOutboundProxy(sendFn: SendFn): ${outboundName}.Proxy {`);
    lines.push(`        return new ${outboundName}.Proxy(sendFn, this.codec);`);
    lines.push('    }');
    lines.push('');

    // setUnknownInboundOpcode
    lines.push('    /**');
    lines.push('     * Set handler for unknown inbound opcodes.');
    lines.push('     * @param handler Handler function (async supported)');
    lines.push('     */');
    lines.push('    setUnknownInboundOpcode(handler: UnknownOpcodeHandler): void {');
    lines.push('        this.unknownHandler = handler;');
    lines.push('    }');
    lines.push('');

    // handleUnknownInboundOpcode
    lines.push('    /**');
    lines.push('     * Handle unknown inbound opcode.');
    lines.push('     * Called by NetworkClient when opcode is not recognized.');
    lines.push('     * Exceptions are caught and logged, never propagated.');
    lines.push('     */');
    lines.push('    async handleUnknownInboundOpcode(event: UnknownOpcodeEvent): Promise<void> {');
    lines.push('        try {');
    lines.push('            if (this.unknownHandler) {');
    lines.push('                await this.unknownHandler(event);');
    lines.push('            } else {');
    lines.push('                console.warn(');
    lines.push(`                    \`[NetworkClientRuntime] Unknown opcode \${event.opcode} (\${event.payload.length} bytes)\``);
    lines.push('                );');
    lines.push('            }');
    lines.push('        } catch (err) {');
    lines.push(`            console.error(\`[NetworkClientRuntime] unknown handler failed\`, err);`);
    lines.push('        }');
    lines.push('    }');
    lines.push('}');
    lines.push('');

    // Factory function
    lines.push('/**');
    lines.push(` * Create client runtime for ${groupName} protocol group`);
    lines.push(' * @returns Runtime instance with stub access and proxy factory');
    lines.push(' */');
    lines.push(`export function createClientRuntime(codec: ICodec): {`);
    lines.push(`    runtime: NetworkClientRuntime;`);
    lines.push(`    ${inboundName.charAt(0).toLowerCase() + inboundName.slice(1)}Stub: ${inboundName}.Stub;`);
    lines.push(`    ${outboundName.charAt(0).toLowerCase() + outboundName.slice(1)}ProxyFactory: (sendFn: SendFn) => ${outboundName}.Proxy;`);
    lines.push('} {');
    lines.push(`    const runtime = new NetworkClientRuntime(codec);`);
    lines.push('    return {');
    lines.push('        runtime,');
    lines.push(`        ${inboundName.charAt(0).toLowerCase() + inboundName.slice(1)}Stub: runtime.getStub(),`);
    lines.push(`        ${outboundName.charAt(0).toLowerCase() + outboundName.slice(1)}ProxyFactory: (sendFn) => runtime.createOutboundProxy(sendFn),`);
    lines.push('    };');
    lines.push('}');
    lines.push('');

    // Re-exports
    lines.push('/** Re-export types for convenience */');
    lines.push(`export { ${inboundName}, ${outboundName} };`);

    return lines.join('\n');
}

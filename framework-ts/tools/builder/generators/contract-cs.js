// <auto-generated>
// Devian Build System v10 - C# Contract Generator
// SSOT: skills/devian/03-ssot/SKILL.md
// Namespace: Devian.Module.{Domain}
// </auto-generated>

/**
 * Generate C# contract code from contract spec
 * @param {Object} spec - Contract specification (enums, classes)
 * @param {string} domainName - Domain name (e.g., "Common")
 * @returns {string} Generated C# code
 */
export function generateCSharpContract(spec, domainName) {
    const lines = [];

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push('// </auto-generated>');
    lines.push('');
    lines.push('#nullable enable');
    lines.push('');

    // Namespace: Devian.Module.{Domain} (block style - SSOT 규칙)
    lines.push(`namespace Devian.Module.${domainName}`);
    lines.push('{');

    // Generate enums
    for (const enumDef of spec.enums || []) {
        generateEnum(lines, enumDef);
        lines.push('');
    }

    // Generate classes
    for (const classDef of spec.classes || []) {
        generateClass(lines, classDef, domainName);
        lines.push('');
    }

    lines.push('}'); // end namespace

    return lines.join('\n').trimEnd();
}

/**
 * Generate C# contract body only (no header, no namespace wrapper)
 * @param {Object} spec - Contract specification (enums, classes)
 * @param {string} domainName - Domain name (e.g., "Common")
 * @returns {string} Generated C# body code
 */
export function generateCSharpContractBody(spec, domainName) {
    const lines = [];

    // Generate enums
    for (const enumDef of spec.enums || []) {
        generateEnum(lines, enumDef);
        lines.push('');
    }

    // Generate classes
    for (const classDef of spec.classes || []) {
        generateClass(lines, classDef, domainName);
        lines.push('');
    }

    return lines.join('\n').trimEnd();
}

// ============================================================================
// Generator Functions
// ============================================================================

function generateEnum(lines, enumDef) {
    lines.push(`    /// <summary>${enumDef.name} enum</summary>`);
    lines.push(`    public enum ${enumDef.name}`);
    lines.push('    {');

    for (const value of enumDef.values || []) {
        lines.push(`        ${value.name} = ${value.value},`);
    }

    lines.push('    }');
}

function generateClass(lines, classDef, domainName) {
    lines.push(`    /// <summary>${classDef.name} class</summary>`);
    lines.push(`    public sealed class ${classDef.name} : IEntity`);
    lines.push('    {');

    for (const field of classDef.fields || []) {
        const csType = mapToCSharpType(field.type, field.optional, domainName);
        const propName = capitalize(field.name);
        const defaultValue = getDefaultValue(field.type, field.optional);
        lines.push(`        public ${csType} ${propName} { get; set; }${defaultValue}`);
    }

    lines.push('    }');
}

// ============================================================================
// Type Mapping
// ============================================================================

function mapToCSharpType(type, optional, domainName) {
    const isArray = type.endsWith('[]');
    const baseType = isArray ? type.slice(0, -2) : type;

    let csType = mapBaseType(baseType, domainName);

    if (isArray) {
        csType = `List<${csType}>?`;
    } else if (optional && !isValueType(baseType)) {
        csType = `${csType}?`;
    }

    return csType;
}

function mapBaseType(type, domainName) {
    // Scalar types
    const scalarMap = {
        'byte': 'sbyte',
        'ubyte': 'byte',
        'short': 'short',
        'ushort': 'ushort',
        'int': 'int',
        'uint': 'uint',
        'long': 'long',
        'ulong': 'ulong',
        'float': 'float',
        'double': 'double',
        'string': 'string',
        'bool': 'bool',
    };

    if (scalarMap[type]) {
        return scalarMap[type];
    }

    // enum:Name or enum:Common.Name
    if (type.startsWith('enum:')) {
        const enumName = type.slice(5);
        if (enumName.includes('.')) {
            const [ns, name] = enumName.split('.');
            return `Devian.${ns}.${name}`;
        }
        return enumName;
    }

    // class:Name or class:Common.Name
    if (type.startsWith('class:')) {
        const className = type.slice(6);
        if (className.includes('.')) {
            const [ns, name] = className.split('.');
            return `Devian.${ns}.${name}`;
        }
        return className;
    }

    return type;
}

function isValueType(type) {
    return ['byte', 'ubyte', 'short', 'ushort', 'int', 'uint', 'long', 'ulong', 'float', 'double', 'bool'].includes(type);
}

function getDefaultValue(type, optional) {
    if (type.endsWith('[]')) return '';
    if (type === 'string') return ' = string.Empty;';
    return '';
}

function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

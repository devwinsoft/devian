// <auto-generated>
// Devian Build System v10 - TypeScript Contract Generator
// SSOT: skills/devian/03-ssot/SKILL.md
// </auto-generated>

/**
 * Generate TypeScript contract code from contract spec
 * @param {Object} spec - Contract specification (enums, classes)
 * @param {string} domainName - Domain name (e.g., "Common")
 * @returns {string} Generated TypeScript code
 */
export function generateTypeScriptContract(spec, domainName) {
    const lines = [];

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push('// </auto-generated>');
    lines.push('');

    // Generate enums
    for (const enumDef of spec.enums || []) {
        generateEnum(lines, enumDef);
        lines.push('');
    }

    // Generate interfaces (classes become interfaces in TS)
    for (const classDef of spec.classes || []) {
        generateInterface(lines, classDef);
        lines.push('');
    }

    return lines.join('\n').trimEnd();
}

/**
 * Generate TypeScript contract body only (no header)
 * @param {Object} spec - Contract specification (enums, classes)
 * @returns {string} Generated TypeScript body code
 */
export function generateTypeScriptContractBody(spec) {
    const lines = [];

    // Generate enums
    for (const enumDef of spec.enums || []) {
        generateEnum(lines, enumDef);
        lines.push('');
    }

    // Generate interfaces (classes become interfaces in TS)
    for (const classDef of spec.classes || []) {
        generateInterface(lines, classDef);
        lines.push('');
    }

    return lines.join('\n').trimEnd();
}

// ============================================================================
// Generator Functions
// ============================================================================

function generateEnum(lines, enumDef) {
    lines.push(`/** ${enumDef.name} enum */`);
    lines.push(`export enum ${enumDef.name} {`);

    for (const value of enumDef.values || []) {
        lines.push(`    ${value.name} = ${value.value},`);
    }

    lines.push('}');
}

function generateInterface(lines, classDef) {
    lines.push(`/** ${classDef.name} interface */`);
    lines.push(`export interface ${classDef.name} extends IEntity {`);

    for (const field of classDef.fields || []) {
        const tsType = mapToTypeScriptType(field.type);
        const optional = field.optional ? '?' : '';
        lines.push(`    ${field.name}${optional}: ${tsType};`);
    }

    lines.push('}');
}

// ============================================================================
// Type Mapping
// ============================================================================

function mapToTypeScriptType(type) {
    const isArray = type.endsWith('[]');
    const baseType = isArray ? type.slice(0, -2) : type;

    let tsType = mapBaseType(baseType);

    return isArray ? `${tsType}[]` : tsType;
}

function mapBaseType(type) {
    // Scalar types
    const scalarMap = {
        'byte': 'number',
        'ubyte': 'number',
        'short': 'number',
        'ushort': 'number',
        'int': 'number',
        'uint': 'number',
        'long': 'bigint',
        'ulong': 'bigint',
        'float': 'number',
        'double': 'number',
        'string': 'string',
        'bool': 'boolean',
    };

    if (scalarMap[type]) {
        return scalarMap[type];
    }

    // enum:Name or enum:Common.Name
    if (type.startsWith('enum:')) {
        const enumName = type.slice(5);
        if (enumName.includes('.')) {
            return enumName.split('.').pop();
        }
        return enumName;
    }

    // class:Name or class:Common.Name
    if (type.startsWith('class:')) {
        const className = type.slice(6);
        if (className.includes('.')) {
            return className.split('.').pop();
        }
        return className;
    }

    return type;
}

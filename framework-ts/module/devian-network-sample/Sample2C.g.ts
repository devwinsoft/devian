// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System v10
// Protocol: Sample2C (Group: Sample)
// </auto-generated>

// Direction: server_to_client

export namespace Sample2C {

    /** Pong message */
    export interface Pong {
        timestamp: bigint;
        serverTime: bigint;
    }

    /** EchoReply message */
    export interface EchoReply {
        message: string;
        echoedAt: bigint;
    }

    /** Opcode constants */
    export const Opcodes = {
        Pong: 1001,
        EchoReply: 1000,
    } as const;

    export type OpcodeType = typeof Opcodes[keyof typeof Opcodes];

    export function getOpcodeName(opcode: number): string | undefined {
        const entries = Object.entries(Opcodes);
        const found = entries.find(([_, v]) => v === opcode);
        return found?.[0];
    }

    /** Codec interface */
    export interface ICodec {
        encode<T>(message: T): Uint8Array;
        encodeByOpcode<T>(opcode: number, message: T): Uint8Array;
        decode<T>(data: Uint8Array): T;
        decodeByOpcode(opcode: number, data: Uint8Array): unknown;
    }

    /** JSON Codec implementation */
    export class CodecJson implements ICodec {
        private encoder = new TextEncoder();
        private decoder = new TextDecoder();

        encode<T>(message: T): Uint8Array {
            const json = JSON.stringify(message);
            return this.encoder.encode(json);
        }

        encodeByOpcode<T>(_opcode: number, message: T): Uint8Array {
            return this.encode(message);
        }

        decode<T>(data: Uint8Array): T {
            const json = this.decoder.decode(data);
            return JSON.parse(json) as T;
        }

        decodeByOpcode(opcode: number, data: Uint8Array): unknown {
            return this.decode(data);
        }
    }

    /** Protobuf wire format helpers */
    const Proto = {
        readVarint(data: Uint8Array, pos: { v: number }): bigint {
            let result = 0n;
            let shift = 0n;
            while (pos.v < data.length) {
                const b = data[pos.v++];
                result |= BigInt(b & 0x7f) << shift;
                if ((b & 0x80) === 0) break;
                shift += 7n;
            }
            return result;
        },

        readTag(data: Uint8Array, pos: { v: number }): { tag: number; wireType: number } {
            const varint = Number(this.readVarint(data, pos));
            return { tag: varint >> 3, wireType: varint & 0x7 };
        },

        readInt32(data: Uint8Array, pos: { v: number }): number {
            return Number(this.readVarint(data, pos));
        },

        readInt64(data: Uint8Array, pos: { v: number }): bigint {
            return this.readVarint(data, pos);
        },

        readBool(data: Uint8Array, pos: { v: number }): boolean {
            return this.readVarint(data, pos) !== 0n;
        },

        readString(data: Uint8Array, pos: { v: number }): string {
            const len = Number(this.readVarint(data, pos));
            if (len === 0) return "";
            const bytes = data.slice(pos.v, pos.v + len);
            pos.v += len;
            return new TextDecoder().decode(bytes);
        },

        readBytes(data: Uint8Array, pos: { v: number }): Uint8Array {
            const len = Number(this.readVarint(data, pos));
            if (len === 0) return new Uint8Array(0);
            const bytes = data.slice(pos.v, pos.v + len);
            pos.v += len;
            return bytes;
        },

        readFloat(data: Uint8Array, pos: { v: number }): number {
            const view = new DataView(data.buffer, data.byteOffset + pos.v, 4);
            pos.v += 4;
            return view.getFloat32(0, true);
        },

        readDouble(data: Uint8Array, pos: { v: number }): number {
            const view = new DataView(data.buffer, data.byteOffset + pos.v, 8);
            pos.v += 8;
            return view.getFloat64(0, true);
        },

        skip(data: Uint8Array, pos: { v: number }, wireType: number): void {
            switch (wireType) {
                case 0: this.readVarint(data, pos); break;
                case 1: pos.v += 8; break;
                case 2: pos.v += Number(this.readVarint(data, pos)); break;
                case 5: pos.v += 4; break;
            }
        },

        writeVarint(arr: number[], value: bigint): void {
            let v = BigInt.asUintN(64, value);
            while (v >= 0x80n) {
                arr.push(Number(v & 0x7fn) | 0x80);
                v >>= 7n;
            }
            arr.push(Number(v));
        },

        writeTag(arr: number[], tag: number, wireType: number): void {
            this.writeVarint(arr, BigInt((tag << 3) | wireType));
        },

        writeInt32(arr: number[], tag: number, value: number): void {
            if (value === 0) return;
            this.writeTag(arr, tag, 0);
            this.writeVarint(arr, BigInt(value));
        },

        writeInt64(arr: number[], tag: number, value: bigint): void {
            if (value === 0n) return;
            this.writeTag(arr, tag, 0);
            this.writeVarint(arr, value);
        },

        writeBool(arr: number[], tag: number, value: boolean): void {
            if (!value) return;
            this.writeTag(arr, tag, 0);
            arr.push(1);
        },

        writeString(arr: number[], tag: number, value: string | undefined): void {
            if (!value) return;
            const bytes = new TextEncoder().encode(value);
            this.writeTag(arr, tag, 2);
            this.writeVarint(arr, BigInt(bytes.length));
            for (const b of bytes) arr.push(b);
        },

        writeBytes(arr: number[], tag: number, value: Uint8Array | undefined): void {
            if (!value || value.length === 0) return;
            this.writeTag(arr, tag, 2);
            this.writeVarint(arr, BigInt(value.length));
            for (const b of value) arr.push(b);
        },

        writeFloat(arr: number[], tag: number, value: number): void {
            if (value === 0) return;
            this.writeTag(arr, tag, 5);
            const buf = new ArrayBuffer(4);
            new DataView(buf).setFloat32(0, value, true);
            for (const b of new Uint8Array(buf)) arr.push(b);
        },

        writeDouble(arr: number[], tag: number, value: number): void {
            if (value === 0) return;
            this.writeTag(arr, tag, 1);
            const buf = new ArrayBuffer(8);
            new DataView(buf).setFloat64(0, value, true);
            for (const b of new Uint8Array(buf)) arr.push(b);
        },
    };

    /**
     * Protobuf Codec implementation.
     */
    export class CodecProtobuf implements ICodec {

        private encodePong(m: Pong): Uint8Array {
            const arr: number[] = [];
            Proto.writeInt64(arr, 1, m.timestamp ?? 0n);
            Proto.writeInt64(arr, 2, m.serverTime ?? 0n);
            return new Uint8Array(arr);
        }

        private encodeEchoReply(m: EchoReply): Uint8Array {
            const arr: number[] = [];
            Proto.writeString(arr, 1, m.message);
            Proto.writeInt64(arr, 2, m.echoedAt ?? 0n);
            return new Uint8Array(arr);
        }

        private decodePong(data: Uint8Array): Pong {
            const m: Pong = {} as Pong;
            const pos = { v: 0 };
            while (pos.v < data.length) {
                const { tag, wireType } = Proto.readTag(data, pos);
                switch (tag) {
                    case 1:
                        m.timestamp = Proto.readInt64(data, pos);
                        break;
                    case 2:
                        m.serverTime = Proto.readInt64(data, pos);
                        break;
                    default:
                        Proto.skip(data, pos, wireType);
                        break;
                }
            }
            return m;
        }

        private decodeEchoReply(data: Uint8Array): EchoReply {
            const m: EchoReply = {} as EchoReply;
            const pos = { v: 0 };
            while (pos.v < data.length) {
                const { tag, wireType } = Proto.readTag(data, pos);
                switch (tag) {
                    case 1:
                        m.message = Proto.readString(data, pos);
                        break;
                    case 2:
                        m.echoedAt = Proto.readInt64(data, pos);
                        break;
                    default:
                        Proto.skip(data, pos, wireType);
                        break;
                }
            }
            return m;
        }

        encode<T>(message: T): Uint8Array {
            // Type dispatch - caller should use encodeByOpcode when possible
            if ((message as unknown as Pong).timestamp !== undefined) {
                // Heuristic check - may need refinement
            }
            if ((message as unknown as EchoReply).message !== undefined) {
                // Heuristic check - may need refinement
            }
            throw new Error("Unknown message type for encode");
        }

        encodeByOpcode<T>(opcode: number, message: T): Uint8Array {
            switch (opcode) {
                case Opcodes.Pong: return this.encodePong(message as unknown as Pong);
                case Opcodes.EchoReply: return this.encodeEchoReply(message as unknown as EchoReply);
                default: throw new Error(`Unknown opcode: ${opcode}`);
            }
        }

        decode<T>(data: Uint8Array): T {
            throw new Error("Use decodeByOpcode instead");
        }

        decodeByOpcode(opcode: number, data: Uint8Array): unknown {
            switch (opcode) {
                case Opcodes.Pong: return this.decodePong(data);
                case Opcodes.EchoReply: return this.decodeEchoReply(data);
                default: throw new Error(`Unknown opcode: ${opcode}`);
            }
        }
    }

    /** Message handler type */
    export type MessageHandler<T> = (sessionId: number, message: T) => void | Promise<void>;

    /**
     * Stub for Sample2C handlers.
     * Register handlers with on{MessageName}() methods.
     */
    export class Stub {
        private codec: ICodec;
        private handlers = new Map<number, Set<MessageHandler<unknown>>>();

        constructor(codec?: ICodec) {
            this.codec = codec ?? new CodecProtobuf();
        }

        async dispatch(sessionId: number, opcode: number, payload: Uint8Array): Promise<void> {
            const handlerSet = this.handlers.get(opcode);
            if (!handlerSet || handlerSet.size === 0) return;

            const message = this.codec.decodeByOpcode(opcode, payload);
            for (const handler of handlerSet) {
                await handler(sessionId, message);
            }
        }

        onPong(handler: MessageHandler<Pong>): () => void {
            return this.register(Opcodes.Pong, handler as MessageHandler<unknown>);
        }

        onEchoReply(handler: MessageHandler<EchoReply>): () => void {
            return this.register(Opcodes.EchoReply, handler as MessageHandler<unknown>);
        }

        private register(opcode: number, handler: MessageHandler<unknown>): () => void {
            if (!this.handlers.has(opcode)) {
                this.handlers.set(opcode, new Set());
            }
            this.handlers.get(opcode)!.add(handler);

            // Return unsubscribe function
            return () => {
                this.handlers.get(opcode)?.delete(handler);
            };
        }
    }

    /** Send function type */
    export type SendFn = (sessionId: number, frame: Uint8Array) => void | Promise<void>;

    /**
     * Proxy for sending Sample2C messages.
     */
    export class Proxy {
        private sendFn: SendFn;
        private codec: ICodec;

        constructor(sendFn: SendFn, codec?: ICodec) {
            this.sendFn = sendFn;
            this.codec = codec ?? new CodecProtobuf();
        }

        private packFrame(opcode: number, payload: Uint8Array): Uint8Array {
            const frame = new Uint8Array(4 + payload.length);
            const view = new DataView(frame.buffer);
            view.setInt32(0, opcode, true); // little-endian
            frame.set(payload, 4);
            return frame;
        }

        async sendPong(sessionId: number, message: Pong): Promise<void> {
            const payload = this.codec.encodeByOpcode(Opcodes.Pong, message);
            const frame = this.packFrame(Opcodes.Pong, payload);
            await this.sendFn(sessionId, frame);
        }

        async sendEchoReply(sessionId: number, message: EchoReply): Promise<void> {
            const payload = this.codec.encodeByOpcode(Opcodes.EchoReply, message);
            const frame = this.packFrame(Opcodes.EchoReply, payload);
            await this.sendFn(sessionId, frame);
        }

    }
}

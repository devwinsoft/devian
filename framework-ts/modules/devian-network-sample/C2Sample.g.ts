// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System v10
// Protocol: C2Sample (Group: Sample)
// </auto-generated>

// Direction: client_to_server

export namespace C2Sample {

    /** Ping message */
    export interface Ping {
        timestamp: bigint;
        payload?: string;
    }

    /** Echo message */
    export interface Echo {
        message: string;
    }

    /** Opcode constants */
    export const Opcodes = {
        Ping: 1001,
        Echo: 1000,
    } as const;

    export type OpcodeType = typeof Opcodes[keyof typeof Opcodes];

    export function getOpcodeName(opcode: number): string | undefined {
        const entries = Object.entries(Opcodes);
        const found = entries.find(([_, v]) => v === opcode);
        return found?.[0];
    }

    /** Codec interface */
    export interface ICodec {
        encode<T>(message: T): Uint8Array;
        decode<T>(data: Uint8Array): T;
        decodeByOpcode(opcode: number, data: Uint8Array): unknown;
    }

    /** JSON Codec implementation */
    export class CodecJson implements ICodec {
        private encoder = new TextEncoder();
        private decoder = new TextDecoder();

        encode<T>(message: T): Uint8Array {
            const json = JSON.stringify(message);
            return this.encoder.encode(json);
        }

        decode<T>(data: Uint8Array): T {
            const json = this.decoder.decode(data);
            return JSON.parse(json) as T;
        }

        decodeByOpcode(opcode: number, data: Uint8Array): unknown {
            return this.decode(data);
        }
    }

    /**
     * Protobuf Codec implementation.
     * Requires message encoders/decoders to be registered.
     */
    export class CodecProtobuf implements ICodec {
        private encoders = new Map<number, (message: unknown) => Uint8Array>();
        private decoders = new Map<number, (data: Uint8Array) => unknown>();
        private fallbackCodec = new CodecJson();

        /**
         * Register encoder for a specific opcode.
         */
        registerEncoder(opcode: number, encoder: (message: unknown) => Uint8Array): void {
            this.encoders.set(opcode, encoder);
        }

        /**
         * Register decoder for a specific opcode.
         */
        registerDecoder(opcode: number, decoder: (data: Uint8Array) => unknown): void {
            this.decoders.set(opcode, decoder);
        }

        encode<T>(message: T): Uint8Array {
            // Generic encode falls back to JSON
            return this.fallbackCodec.encode(message);
        }

        /**
         * Encode message by opcode using registered encoder.
         */
        encodeByOpcode<T>(opcode: number, message: T): Uint8Array {
            const encoder = this.encoders.get(opcode);
            if (encoder) {
                return encoder(message);
            }
            return this.fallbackCodec.encode(message);
        }

        decode<T>(data: Uint8Array): T {
            // Generic decode falls back to JSON
            return this.fallbackCodec.decode(data);
        }

        decodeByOpcode(opcode: number, data: Uint8Array): unknown {
            const decoder = this.decoders.get(opcode);
            if (decoder) {
                return decoder(data);
            }
            return this.fallbackCodec.decode(data);
        }
    }

    /** Message handler type */
    export type MessageHandler<T> = (sessionId: number, message: T) => void | Promise<void>;

    /**
     * Stub for C2Sample handlers.
     * Register handlers with on{MessageName}() methods.
     */
    export class Stub {
        private codec: ICodec;
        private handlers = new Map<number, Set<MessageHandler<unknown>>>();

        constructor(codec?: ICodec) {
            this.codec = codec ?? new CodecJson();
        }

        async dispatch(sessionId: number, opcode: number, payload: Uint8Array): Promise<void> {
            const handlerSet = this.handlers.get(opcode);
            if (!handlerSet || handlerSet.size === 0) return;

            const message = this.codec.decodeByOpcode(opcode, payload);
            for (const handler of handlerSet) {
                await handler(sessionId, message);
            }
        }

        onPing(handler: MessageHandler<Ping>): () => void {
            return this.register(Opcodes.Ping, handler as MessageHandler<unknown>);
        }

        onEcho(handler: MessageHandler<Echo>): () => void {
            return this.register(Opcodes.Echo, handler as MessageHandler<unknown>);
        }

        private register(opcode: number, handler: MessageHandler<unknown>): () => void {
            if (!this.handlers.has(opcode)) {
                this.handlers.set(opcode, new Set());
            }
            this.handlers.get(opcode)!.add(handler);

            // Return unsubscribe function
            return () => {
                this.handlers.get(opcode)?.delete(handler);
            };
        }
    }

    /** Send function type */
    export type SendFn = (sessionId: number, frame: Uint8Array) => void | Promise<void>;

    /**
     * Proxy for sending C2Sample messages.
     */
    export class Proxy {
        private sendFn: SendFn;
        private codec: ICodec;

        constructor(sendFn: SendFn, codec?: ICodec) {
            this.sendFn = sendFn;
            this.codec = codec ?? new CodecJson();
        }

        private packFrame(opcode: number, payload: Uint8Array): Uint8Array {
            const frame = new Uint8Array(4 + payload.length);
            const view = new DataView(frame.buffer);
            view.setInt32(0, opcode, true); // little-endian
            frame.set(payload, 4);
            return frame;
        }

        async sendPing(sessionId: number, message: Ping): Promise<void> {
            const payload = this.codec.encode(message);
            const frame = this.packFrame(Opcodes.Ping, payload);
            await this.sendFn(sessionId, frame);
        }

        async sendEcho(sessionId: number, message: Echo): Promise<void> {
            const payload = this.codec.encode(message);
            const frame = this.packFrame(Opcodes.Echo, payload);
            await this.sendFn(sessionId, frame);
        }

    }
}

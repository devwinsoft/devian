// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System
// </auto-generated>

using ClosedXML.Excel;
using Devian.Tools.Models;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace Devian.Tools.Generators
{

    /// <summary>
    /// Excel 테이블 스키마 파서 (4행 헤더 기반, Strict Mode)
    /// 
    /// Row 1: FieldName (빈 셀 만나면 헤더 스캔 중단)
    /// Row 2: Type (enum:{Name}, class:{Name}, scalar, [])
    /// Row 3: Options (key:true, optional:true, parser:dff 등)
    /// Row 4: Comment (Devian은 해석하지 않음)
    /// Row 5+: Data (Key 컬럼 빈 값 만나면 로딩 중단)
    /// 
    /// Strict Mode 규칙:
    /// - ref:{Name} 금지 → enum:{Name} / class:{Name} 사용
    /// - parser 기본값 = dff (대소문자 무시)
    /// - parser가 dff 이외면 에러
    /// - key=true → optional 기본값 false
    /// - key=false 또는 미지정 → optional 기본값 true
    /// - key=true && optional=true → 에러
    /// </summary>
    public static class TableSchemaParser
    {
        /// <summary>
        /// tables.json 파싱
        /// </summary>
        public static List<TableSpec> ParseTablesJson(string jsonContent, string domain)
        {
            var doc = JsonDocument.Parse(jsonContent);
            var tables = new List<TableSpec>();

            foreach (var table in doc.RootElement.GetProperty("tables").EnumerateArray())
            {
                var spec = parseTableElement(table, domain);
                tables.Add(spec);
            }

            return tables;
        }

        /// <summary>
        /// 단일 테이블 요소 파싱
        /// </summary>
        private static TableSpec parseTableElement(JsonElement element, string domain)
        {
            var spec = new TableSpec
            {
                Domain = domain,
                ExcelFileName = element.GetProperty("excelFileName").GetString() ?? "",
                SheetName = element.GetProperty("sheetName").GetString() ?? "",
                TableName = element.GetProperty("tableName").GetString() ?? "",
            };

            spec.SheetKey = NormalizeSheetKey(spec.SheetName);
            spec.RowTypeName = $"{spec.TableName}Row";

            // Columns - 빈 이름 만나면 중단
            var columns = element.GetProperty("columns");
            foreach (var col in columns.EnumerateArray())
            {
                var colSpec = parseColumn(col, spec.TableName);
            
                // Header stop rule: 빈 이름 만나면 즉시 중단
                if (string.IsNullOrWhiteSpace(colSpec.Name))
                {
                    break;
                }
            
                spec.Columns.Add(colSpec);
            }

            // Primary Key 찾기 + optional 기본값 적용
            for (int i = 0; i < spec.Columns.Count; i++)
            {
                var col = spec.Columns[i];
                var isKey = col.Options.TryGetValue("key", out var keyVal) && 
                            keyVal.Equals("true", StringComparison.OrdinalIgnoreCase);
            
                if (isKey)
                {
                    spec.PrimaryKeyColumnIndex = i;
                    spec.PrimaryKeyFieldName = col.Name;
                    spec.PrimaryKeyTypeKey = TypeMapper.StripArray(col.Type);
                }
            
                // optional 기본값 규칙 적용
                ApplyOptionalDefault(col, isKey, spec.TableName);
            }

            // key 없으면 첫 번째 컬럼이 PK
            if (string.IsNullOrEmpty(spec.PrimaryKeyFieldName) && spec.Columns.Count > 0)
            {
                spec.PrimaryKeyColumnIndex = 0;
                spec.PrimaryKeyFieldName = spec.Columns[0].Name;
                spec.PrimaryKeyTypeKey = TypeMapper.StripArray(spec.Columns[0].Type);
            }

            return spec;
        }

        /// <summary>
        /// 컬럼 파싱
        /// </summary>
        private static ColumnSpec parseColumn(JsonElement element, string tableName)
        {
            var col = new ColumnSpec
            {
                Name = element.GetProperty("name").GetString() ?? "",
                Type = element.GetProperty("type").GetString() ?? "",
                Comment = element.TryGetProperty("comment", out var c) ? c.GetString() ?? "" : "",
            };

            // Options 파싱 (case-insensitive)
            if (element.TryGetProperty("options", out var opts))
            {
                foreach (var opt in opts.EnumerateObject())
                {
                    // 키는 소문자로 정규화
                    col.Options[opt.Name.ToLowerInvariant()] = opt.Value.ToString();
                }
            }

            // parser 검증 (Strict Mode)
            ValidateParser(col, tableName);

            // 배열/ref 분석 - enum:/class: 사용
            col.IsArray = TypeMapper.IsArray(col.Type);
            var (kind, isCommon, typeName) = TypeMapper.ParseRefType(col.Type);
            col.IsRef = kind != TypeMapper.RefKind.None;
            col.IsCommonRef = isCommon;
            col.RefTypeName = typeName;
            col.RefKind = kind;

            return col;
        }

        /// <summary>
        /// parser 옵션 검증 (Strict Mode)
        /// </summary>
        private static void ValidateParser(ColumnSpec col, string tableName)
        {
            // parser 키는 case-insensitive
            string? parserValue = null;
            foreach (var key in col.Options.Keys.ToList())
            {
                if (key.Equals("parser", StringComparison.OrdinalIgnoreCase))
                {
                    parserValue = col.Options[key];
                    // 키 정규화
                    if (key != "parser")
                    {
                        col.Options.Remove(key);
                        col.Options["parser"] = parserValue;
                    }
                    break;
                }
            }

            // parser 값 검증 (case-insensitive)
            if (!string.IsNullOrEmpty(parserValue))
            {
                if (!parserValue.Equals("dff", StringComparison.OrdinalIgnoreCase))
                {
                    throw new InvalidOperationException(
                        $"[table='{tableName}', column='{col.Name}'] parser='{parserValue}' is not allowed in Strict mode. Only 'dff' is permitted.");
                }
            }
        
            // 기본값 적용
            if (!col.Options.ContainsKey("parser"))
            {
                col.Options["parser"] = "dff";
            }
        }

        /// <summary>
        /// optional 기본값 적용 규칙
        /// - key=true → optional 기본값 false
        /// - key=false 또는 미지정 → optional 기본값 true
        /// - key=true && optional=true → 에러
        /// </summary>
        private static void ApplyOptionalDefault(ColumnSpec col, bool isKey, string tableName)
        {
            // optional 키 찾기 (case-insensitive)
            string? optionalValue = null;
            foreach (var key in col.Options.Keys.ToList())
            {
                if (key.Equals("optional", StringComparison.OrdinalIgnoreCase))
                {
                    optionalValue = col.Options[key];
                    // 키 정규화
                    if (key != "optional")
                    {
                        col.Options.Remove(key);
                        col.Options["optional"] = optionalValue;
                    }
                    break;
                }
            }

            if (string.IsNullOrEmpty(optionalValue))
            {
                // 기본값 적용
                col.Options["optional"] = isKey ? "false" : "true";
            }
            else
            {
                // key=true && optional=true 에러 검사
                if (isKey && optionalValue.Equals("true", StringComparison.OrdinalIgnoreCase))
                {
                    throw new InvalidOperationException(
                        $"[table='{tableName}', column='{col.Name}'] key=true with optional=true is invalid. Key columns cannot be optional.");
                }
            }
        }

        /// <summary>
        /// SheetKey 정규화
        /// </summary>
        public static string NormalizeSheetKey(string sheetName)
        {
            var result = sheetName.Trim().ToLowerInvariant();
            result = Regex.Replace(result, @"[^a-z0-9]", "_");
            result = Regex.Replace(result, @"_+", "_");
            result = result.Trim('_');
            return result;
        }

        /// <summary>
        /// TableName 정규화 (C# 식별자 규칙)
        /// - 특수문자/공백 → _
        /// - _ 정리
        /// - PascalCase로 변환
        /// - 첫 글자가 숫자면 T prefix
        /// - 결과가 비면 "Table"로
        /// </summary>
        public static string NormalizeTableName(string name)
        {
            if (string.IsNullOrWhiteSpace(name))
                return "Table";

            // 특수문자/공백 → _
            var result = Regex.Replace(name.Trim(), @"[^a-zA-Z0-9_]", "_");
            
            // 연속 _ 정리
            result = Regex.Replace(result, @"_+", "_");
            result = result.Trim('_');

            if (string.IsNullOrEmpty(result))
                return "Table";

            // PascalCase 변환: _ 구분자로 각 단어 첫 글자 대문자
            var parts = result.Split('_', StringSplitOptions.RemoveEmptyEntries);
            result = string.Join("", parts.Select(p => 
                char.ToUpperInvariant(p[0]) + (p.Length > 1 ? p.Substring(1) : "")));

            // 첫 글자가 숫자면 T prefix
            if (char.IsDigit(result[0]))
                result = "T" + result;

            return result;
        }

        /// <summary>
        /// xlsx 파일에서 테이블 스펙 파싱 (4행 헤더 기반)
        /// - 각 worksheet = 테이블 1개
        /// - Row 1: FieldName
        /// - Row 2: Type
        /// - Row 3: Options (key:true, optional:true, parser:dff)
        /// - Row 4: Comment
        /// </summary>
        public static List<TableSpec> ParseTablesXlsx(string xlsxPath, string domain)
        {
            var tables = new List<TableSpec>();
            var usedNames = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

            using var workbook = new XLWorkbook(xlsxPath);
            
            foreach (var worksheet in workbook.Worksheets)
            {
                // 빈 시트 스킵
                if (worksheet.LastRowUsed() == null || worksheet.LastColumnUsed() == null)
                    continue;

                var spec = parseWorksheet(worksheet, domain, xlsxPath);
                if (spec == null || spec.Columns.Count == 0)
                    continue;

                // TableName 중복 처리
                var baseName = spec.TableName;
                if (usedNames.TryGetValue(baseName, out var count))
                {
                    usedNames[baseName] = count + 1;
                    spec.TableName = $"{baseName}_{count + 1}";
                    spec.RowTypeName = $"{spec.TableName}Row";
                    Console.Error.WriteLine($"Warning: Duplicate table name '{baseName}' in '{xlsxPath}', renamed to '{spec.TableName}'");
                }
                else
                {
                    usedNames[baseName] = 1;
                }

                tables.Add(spec);
            }

            return tables;
        }

        /// <summary>
        /// 단일 워크시트에서 TableSpec 파싱
        /// </summary>
        private static TableSpec? parseWorksheet(IXLWorksheet worksheet, string domain, string xlsxPath)
        {
            var spec = new TableSpec
            {
                Domain = domain,
                ExcelFileName = Path.GetFileName(xlsxPath),
                SheetName = worksheet.Name,
                TableName = NormalizeTableName(worksheet.Name),
            };

            spec.SheetKey = NormalizeSheetKey(spec.SheetName);
            spec.RowTypeName = $"{spec.TableName}Row";

            // 컬럼 스캔 (A열부터, 빈 이름 만나면 중단)
            var lastCol = worksheet.LastColumnUsed()?.ColumnNumber() ?? 0;
            
            for (int colNum = 1; colNum <= lastCol; colNum++)
            {
                // Row 1: FieldName
                var nameCell = worksheet.Cell(1, colNum);
                var name = nameCell.GetString()?.Trim() ?? "";
                
                // 빈 이름이면 컬럼 스캔 중단
                if (string.IsNullOrWhiteSpace(name))
                    break;

                // Row 2: Type
                var typeCell = worksheet.Cell(2, colNum);
                var type = typeCell.GetString()?.Trim() ?? "string";

                // Row 3: Options
                var optionsCell = worksheet.Cell(3, colNum);
                var optionsStr = optionsCell.GetString()?.Trim() ?? "";

                // Row 4: Comment
                var commentCell = worksheet.Cell(4, colNum);
                var comment = commentCell.GetString()?.Trim() ?? "";

                var col = new ColumnSpec
                {
                    Name = name,
                    Type = type,
                    Comment = comment,
                };

                // Options 파싱: "key:true, optional:false, parser:dff"
                parseOptionsString(col, optionsStr);

                // parser 검증 (Strict Mode)
                ValidateParser(col, spec.TableName);

                // 배열/ref 분석
                col.IsArray = TypeMapper.IsArray(col.Type);
                var (kind, isCommon, typeName) = TypeMapper.ParseRefType(col.Type);
                col.IsRef = kind != TypeMapper.RefKind.None;
                col.IsCommonRef = isCommon;
                col.RefTypeName = typeName;
                col.RefKind = kind;

                spec.Columns.Add(col);
            }

            // Primary Key 찾기 + optional 기본값 적용
            for (int i = 0; i < spec.Columns.Count; i++)
            {
                var col = spec.Columns[i];
                var isKey = col.Options.TryGetValue("key", out var keyVal) && 
                            keyVal.Equals("true", StringComparison.OrdinalIgnoreCase);

                if (isKey)
                {
                    spec.PrimaryKeyColumnIndex = i;
                    spec.PrimaryKeyFieldName = col.Name;
                    spec.PrimaryKeyTypeKey = TypeMapper.StripArray(col.Type);
                }

                // optional 기본값 규칙 적용
                ApplyOptionalDefault(col, isKey, spec.TableName);
            }

            // key 없으면 첫 번째 컬럼이 PK
            if (string.IsNullOrEmpty(spec.PrimaryKeyFieldName) && spec.Columns.Count > 0)
            {
                spec.PrimaryKeyColumnIndex = 0;
                spec.PrimaryKeyFieldName = spec.Columns[0].Name;
                spec.PrimaryKeyTypeKey = TypeMapper.StripArray(spec.Columns[0].Type);
            }

            return spec;
        }

        /// <summary>
        /// Options 문자열 파싱: "key:true, optional:false, parser:dff"
        /// </summary>
        private static void parseOptionsString(ColumnSpec col, string optionsStr)
        {
            if (string.IsNullOrWhiteSpace(optionsStr))
                return;

            var tokens = optionsStr.Split(',', StringSplitOptions.RemoveEmptyEntries);
            foreach (var token in tokens)
            {
                var parts = token.Split(':', 2);
                if (parts.Length == 2)
                {
                    var key = parts[0].Trim().ToLowerInvariant();
                    var value = parts[1].Trim();
                    col.Options[key] = value;
                }
                else if (parts.Length == 1)
                {
                    // "key" 형태면 "key:true"로 처리
                    var key = parts[0].Trim().ToLowerInvariant();
                    if (!string.IsNullOrEmpty(key))
                        col.Options[key] = "true";
                }
            }
        }

        /// <summary>
        /// 타입 검증 (Row2 검증, Strict Mode)
        /// </summary>
        public static List<string> ValidateTableSpec(TableSpec spec)
        {
            var errors = new List<string>();

            for (int i = 0; i < spec.Columns.Count; i++)
            {
                var col = spec.Columns[i];
                var (valid, error) = TypeMapper.ValidateType(col.Type, spec.TableName, i, col.Name);
                if (!valid)
                {
                    errors.Add(error!);
                }
            }

            return errors;
        }
    }
}

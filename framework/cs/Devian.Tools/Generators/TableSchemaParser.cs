// <auto-generated>
// Devian Build System - Table Schema Parser
// </auto-generated>

using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml.Linq;
using Devian.Tools.Models;

namespace Devian.Tools.Generators
{
    /// <summary>
    /// XLSX 테이블 파서 (61-tablegen-implementation)
    /// 4행 헤더 구조 파싱
    /// </summary>
    public static class TableSchemaParser
    {
        /// <summary>
        /// xlsx 파일을 파싱하여 TableSpec 목록 반환
        /// </summary>
        public static List<TableSpec> ParseXlsx(string xlsxPath, string domain)
        {
            var tables = new List<TableSpec>();

            using var archive = ZipFile.OpenRead(xlsxPath);

            // SharedStrings 로드
            var sharedStrings = LoadSharedStrings(archive);

            // 워크북에서 시트 정보 로드
            var sheets = LoadWorkbookSheets(archive);

            foreach (var (sheetName, sheetId) in sheets)
            {
                var sheetPath = $"xl/worksheets/sheet{sheetId}.xml";
                var sheetEntry = archive.GetEntry(sheetPath);
                if (sheetEntry == null) continue;

                var table = ParseSheet(sheetEntry, sheetName, domain, sharedStrings);
                if (table != null)
                {
                    tables.Add(table);
                }
            }

            return tables;
        }

        private static List<string> LoadSharedStrings(ZipArchive archive)
        {
            var strings = new List<string>();
            var entry = archive.GetEntry("xl/sharedStrings.xml");
            if (entry == null) return strings;

            using var stream = entry.Open();
            var doc = XDocument.Load(stream);
            var ns = doc.Root?.GetDefaultNamespace() ?? XNamespace.None;

            foreach (var si in doc.Descendants(ns + "si"))
            {
                var text = string.Concat(si.Descendants(ns + "t").Select(t => t.Value));
                strings.Add(text);
            }

            return strings;
        }

        private static List<(string Name, int Id)> LoadWorkbookSheets(ZipArchive archive)
        {
            var sheets = new List<(string, int)>();
            var entry = archive.GetEntry("xl/workbook.xml");
            if (entry == null) return sheets;

            using var stream = entry.Open();
            var doc = XDocument.Load(stream);
            var ns = doc.Root?.GetDefaultNamespace() ?? XNamespace.None;
            var rNs = XNamespace.Get("http://schemas.openxmlformats.org/officeDocument/2006/relationships");

            int index = 1;
            foreach (var sheet in doc.Descendants(ns + "sheet"))
            {
                var name = sheet.Attribute("name")?.Value ?? $"Sheet{index}";
                sheets.Add((name, index));
                index++;
            }

            return sheets;
        }

        private static TableSpec? ParseSheet(ZipArchiveEntry entry, string sheetName, string domain, List<string> sharedStrings)
        {
            using var stream = entry.Open();
            var doc = XDocument.Load(stream);
            var ns = doc.Root?.GetDefaultNamespace() ?? XNamespace.None;

            var rows = doc.Descendants(ns + "row")
                .OrderBy(r => int.Parse(r.Attribute("r")?.Value ?? "0"))
                .ToList();

            if (rows.Count < 4) return null; // 헤더 4줄 필수

            // Row 1: Field Names
            var row1 = ParseRow(rows[0], ns, sharedStrings);
            // Row 2: Types
            var row2 = ParseRow(rows[1], ns, sharedStrings);
            // Row 3: Options
            var row3 = ParseRow(rows[2], ns, sharedStrings);
            // Row 4: Comments (해석하지 않음)
            var row4 = ParseRow(rows[3], ns, sharedStrings);

            // 컬럼 파싱 (빈 셀에서 중단)
            var columns = new List<ColumnSpec>();
            int primaryKeyIndex = -1;

            for (int i = 0; i < row1.Count; i++)
            {
                var name = row1[i]?.Trim();
                if (string.IsNullOrEmpty(name)) break; // Header Stop Rule

                var type = i < row2.Count ? row2[i]?.Trim() ?? "string" : "string";
                var options = i < row3.Count ? row3[i]?.Trim() ?? "" : "";
                var comment = i < row4.Count ? row4[i]?.Trim() : null;

                var (isKey, isOptional) = ParseOptions(options);

                if (isKey)
                {
                    if (primaryKeyIndex >= 0)
                        throw new Exception($"Multiple primary keys in table '{sheetName}'");
                    primaryKeyIndex = columns.Count;
                }

                columns.Add(new ColumnSpec
                {
                    Name = name,
                    Type = type,
                    IsKey = isKey,
                    IsOptional = isOptional,
                    Comment = comment
                });
            }

            if (columns.Count == 0) return null;

            // Row 5+: Data
            var dataRows = new List<Dictionary<string, object?>>();
            for (int r = 4; r < rows.Count; r++)
            {
                var rowData = ParseRow(rows[r], ns, sharedStrings);
                var record = new Dictionary<string, object?>();
                bool isEmpty = true;

                for (int c = 0; c < columns.Count; c++)
                {
                    var value = c < rowData.Count ? rowData[c] : null;
                    var col = columns[c];

                    // Key 컬럼이 비면 중단 (Data Stop Rule)
                    if (col.IsKey && string.IsNullOrEmpty(value))
                    {
                        goto endData;
                    }

                    if (!string.IsNullOrEmpty(value)) isEmpty = false;
                    record[col.Name] = ParseValue(value, col.Type);
                }

                if (!isEmpty)
                {
                    dataRows.Add(record);
                }
            }
            endData:

            return new TableSpec
            {
                Domain = domain,
                TableName = NormalizeTableName(sheetName),
                Columns = columns,
                Rows = dataRows,
                PrimaryKeyIndex = primaryKeyIndex
            };
        }

        private static List<string?> ParseRow(XElement row, XNamespace ns, List<string> sharedStrings)
        {
            var cells = new List<string?>();
            var cellElements = row.Elements(ns + "c").ToList();

            foreach (var cell in cellElements)
            {
                var cellRef = cell.Attribute("r")?.Value ?? "";
                var colIndex = GetColumnIndex(cellRef);

                // 컬럼 인덱스까지 null 채우기
                while (cells.Count < colIndex)
                {
                    cells.Add(null);
                }

                var type = cell.Attribute("t")?.Value;
                var valueElement = cell.Element(ns + "v");
                var value = valueElement?.Value;

                if (type == "s" && value != null && int.TryParse(value, out int idx))
                {
                    // Shared string
                    value = idx < sharedStrings.Count ? sharedStrings[idx] : "";
                }

                cells.Add(value);
            }

            return cells;
        }

        private static int GetColumnIndex(string cellRef)
        {
            int col = 0;
            foreach (char c in cellRef)
            {
                if (char.IsLetter(c))
                {
                    col = col * 26 + (char.ToUpper(c) - 'A' + 1);
                }
                else break;
            }
            return col - 1;
        }

        private static (bool IsKey, bool IsOptional) ParseOptions(string options)
        {
            bool isKey = false;
            bool isOptional = false;

            if (string.IsNullOrWhiteSpace(options)) return (isKey, isOptional);

            var parts = options.Split(',', StringSplitOptions.RemoveEmptyEntries);
            foreach (var part in parts)
            {
                var kv = part.Split(':', 2);
                if (kv.Length != 2) continue;

                var key = kv[0].Trim().ToLowerInvariant();
                var value = kv[1].Trim().ToLowerInvariant();

                if (key == "key" && value == "true") isKey = true;
                if (key == "optional" && value == "true") isOptional = true;
            }

            return (isKey, isOptional);
        }

        private static object? ParseValue(string? value, string type)
        {
            if (string.IsNullOrEmpty(value)) return null;

            // 배열 타입
            if (type.EndsWith("[]"))
            {
                var elementType = type[..^2];
                var items = value.Split(',', StringSplitOptions.RemoveEmptyEntries)
                    .Select(v => ParseScalar(v.Trim(), elementType))
                    .ToList();
                return items;
            }

            // enum/class 참조는 문자열로 저장
            if (type.StartsWith("enum:") || type.StartsWith("class:"))
            {
                return value;
            }

            return ParseScalar(value, type);
        }

        private static object? ParseScalar(string value, string type)
        {
            return type switch
            {
                "int" => int.TryParse(value, out var i) ? i : 0,
                "uint" => uint.TryParse(value, out var u) ? u : 0u,
                "long" => long.TryParse(value, out var l) ? l : 0L,
                "ulong" => ulong.TryParse(value, out var ul) ? ul : 0ul,
                "float" => float.TryParse(value, out var f) ? f : 0f,
                "byte" => sbyte.TryParse(value, out var b) ? b : (sbyte)0,
                "ubyte" => byte.TryParse(value, out var ub) ? ub : (byte)0,
                "short" => short.TryParse(value, out var s) ? s : (short)0,
                "ushort" => ushort.TryParse(value, out var us) ? us : (ushort)0,
                "string" => value,
                _ => value
            };
        }

        /// <summary>
        /// 테이블 이름 정규화 (61-tablegen)
        /// </summary>
        private static string NormalizeTableName(string sheetName)
        {
            // 특수문자/공백 → _
            var result = Regex.Replace(sheetName, @"[^\w]", "_");
            // 연속 _ 정리
            result = Regex.Replace(result, @"_+", "_").Trim('_');
            // PascalCase
            if (!string.IsNullOrEmpty(result))
            {
                result = char.ToUpper(result[0]) + result[1..];
            }
            // 첫 글자가 숫자면 T prefix
            if (result.Length > 0 && char.IsDigit(result[0]))
            {
                result = "T" + result;
            }
            // 빈 결과면 "Table"
            if (string.IsNullOrEmpty(result))
            {
                result = "Table";
            }
            return result;
        }
    }
}

// <auto-generated>
// Devian Build System - C# Protocol Generator (v10 Unity)
// Generates: namespace Devian.Protocol + static class {ProtocolName}
// Features: Sync API, abstract Stub, PacketPool<T> pooling, ProtoReader (Span-based)
// </auto-generated>

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Devian.Tools.Models;

namespace Devian.Tools.Generators
{
    /// <summary>
    /// Protocol Spec → C# 코드 생성 (v10 Unity)
    /// Namespace: Devian.Protocol
    /// Container: public static partial class {ProtocolName}
    /// 
    /// v10 변경사항:
    /// - 동기 API (async/Task/ValueTask 제거)
    /// - abstract Stub (핸들러 구현 강제)
    /// - PacketPool&lt;T&gt; 기반 풀링
    /// - ProtoReader (Span 기반) - MemoryStream/ToArray 제거
    /// - Dispatcher/IHandler 제거
    /// </summary>
    public static class CSharpProtocolGenerator
    {
        /// <summary>
        /// 프로토콜 전체 생성 (Messages + Codec + Stub + Proxy)
        /// </summary>
        public static string Generate(ProtocolSpec spec, string protocolName)
        {
            // 검증 (할당은 BuildProtocol에서 이미 완료됨)
            ValidateOpcodes(spec);
            ValidateTags(spec);

            var sb = new StringBuilder();

            // Header
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// DO NOT EDIT - Generated by Devian Build System v10 (Unity)");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
            sb.AppendLine("#nullable enable");
            sb.AppendLine();
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Buffers;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.IO;");
            sb.AppendLine("using System.Text;");
            sb.AppendLine("using System.Text.Json;");
            sb.AppendLine();

            // Namespace: Devian.Protocol
            sb.AppendLine("namespace Devian.Protocol");
            sb.AppendLine("{");

            // Direction comment
            if (!string.IsNullOrEmpty(spec.Direction) && spec.Direction != "bidirectional")
            {
                sb.AppendLine($"    // Direction: {spec.Direction}");
                sb.AppendLine();
            }

            // Container: public static partial class {ProtocolName}
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// {protocolName} protocol container.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public static partial class {protocolName}");
            sb.AppendLine("    {");

            // Frame helper (프레임 규약: [opcode:int32LE][payload...])
            GenerateFrameHelper(sb, "        ");
            sb.AppendLine();

            // EnvelopeMeta
            GenerateEnvelopeMeta(sb, "        ");
            sb.AppendLine();

            // PacketEnvelope (ref struct)
            GeneratePacketEnvelope(sb, "        ");
            sb.AppendLine();

            // PacketPool<T>
            GeneratePacketPool(sb, "        ");
            sb.AppendLine();

            // ProtoReader (ref struct, Span-based)
            GenerateProtoReader(sb, "        ");
            sb.AppendLine();

            // Message classes (nested) with _Reset
            foreach (var message in spec.Messages)
            {
                GenerateMessageClass(sb, message, "        ");
                sb.AppendLine();
            }

            // Opcodes static class
            GenerateOpcodesClass(sb, spec, "        ");
            sb.AppendLine();

            // ProtobufWire helper (private) - Encode 전용
            GenerateProtobufWireHelper(sb, "        ");
            sb.AppendLine();

            // ICodec interface
            GenerateICodec(sb, protocolName, "        ");
            sb.AppendLine();

            // CodecJson implementation
            GenerateCodecJson(sb, spec, protocolName, "        ");
            sb.AppendLine();

            // CodecProtobuf implementation (ProtoReader 기반)
            GenerateCodecProtobuf(sb, spec, protocolName, "        ");
            sb.AppendLine();

            // ISender interface
            GenerateISender(sb, "        ");
            sb.AppendLine();

            // abstract Stub
            GenerateStub(sb, spec, protocolName, "        ");
            sb.AppendLine();

            // Proxy (동기 + sessionId 기반)
            GenerateProxy(sb, spec, protocolName, "        ");

            sb.AppendLine("    }"); // end static class {ProtocolName}
            sb.AppendLine("}"); // end namespace

            return sb.ToString().TrimEnd();
        }

        #region Validation (Registry에서 이미 할당됨 - 검증만)

        private static void ValidateOpcodes(ProtocolSpec spec)
        {
            var used = new HashSet<int>();

            foreach (var m in spec.Messages)
            {
                if (!m.Opcode.HasValue)
                    throw new System.Exception($"Opcode not assigned for {m.Name} (Registry 로직 오류)");
                if (m.Opcode.Value < 0)
                    throw new System.Exception($"Negative opcode not allowed: {m.Name}");
                if (used.Contains(m.Opcode.Value))
                    throw new System.Exception($"Duplicate opcode: {m.Opcode.Value}");
                used.Add(m.Opcode.Value);
            }
        }

        private static void ValidateTags(ProtocolSpec spec)
        {
            foreach (var message in spec.Messages)
            {
                var used = new HashSet<int>();

                foreach (var field in message.Fields)
                {
                    if (!field.Tag.HasValue)
                        throw new System.Exception($"Tag not assigned for {message.Name}.{field.Name} (Registry 로직 오류)");
                    var tag = field.Tag.Value;
                    if (tag < 1 || tag > 536870911)
                        throw new System.Exception($"Tag {tag} out of range for {message.Name}.{field.Name}");
                    if (tag >= 19000 && tag <= 19999)
                        throw new System.Exception($"Tag {tag} in reserved range for {message.Name}.{field.Name}");
                    if (used.Contains(tag))
                        throw new System.Exception($"Duplicate tag {tag} in {message.Name}");
                    used.Add(tag);
                }
            }
        }

        #endregion

        #region Frame Helper Generation

        private static void GenerateFrameHelper(StringBuilder sb, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// Frame helper for protocol framing.");
            sb.AppendLine($"{indent}/// Frame format: [opcode:int32LE][payload...]");
            sb.AppendLine($"{indent}/// </summary>");
            sb.AppendLine($"{indent}internal static class Frame");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    public static int ReadOpcode(ReadOnlySpan<byte> frame)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        if (frame.Length < 4) throw new ArgumentException(\"Frame too short\");");
            sb.AppendLine($"{indent}        return BitConverter.ToInt32(frame.Slice(0, 4));");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public static ReadOnlySpan<byte> ReadPayload(ReadOnlySpan<byte> frame)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        if (frame.Length < 4) return ReadOnlySpan<byte>.Empty;");
            sb.AppendLine($"{indent}        return frame.Slice(4);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public static byte[] Pack(int opcode, ReadOnlySpan<byte> payload)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        var frame = new byte[4 + payload.Length];");
            sb.AppendLine($"{indent}        BitConverter.TryWriteBytes(frame.AsSpan(0, 4), opcode);");
            sb.AppendLine($"{indent}        payload.CopyTo(frame.AsSpan(4));");
            sb.AppendLine($"{indent}        return frame;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region EnvelopeMeta Generation

        private static void GenerateEnvelopeMeta(StringBuilder sb, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>Envelope metadata (sessionId 등)</summary>");
            sb.AppendLine($"{indent}public readonly struct EnvelopeMeta");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    public int SessionId {{ get; }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public EnvelopeMeta(int sessionId)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        SessionId = sessionId;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region PacketEnvelope Generation

        private static void GeneratePacketEnvelope(StringBuilder sb, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// Packet envelope (ref struct - 복사/할당 방지)");
            sb.AppendLine($"{indent}/// payload는 ToArray() 금지, ReadOnlySpan으로 유지");
            sb.AppendLine($"{indent}/// </summary>");
            sb.AppendLine($"{indent}public ref struct PacketEnvelope");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    public int Opcode {{ get; }}");
            sb.AppendLine($"{indent}    public ReadOnlySpan<byte> Payload {{ get; }}");
            sb.AppendLine($"{indent}    public EnvelopeMeta Meta {{ get; }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public PacketEnvelope(int opcode, ReadOnlySpan<byte> payload, EnvelopeMeta meta)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        Opcode = opcode;");
            sb.AppendLine($"{indent}        Payload = payload;");
            sb.AppendLine($"{indent}        Meta = meta;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region PacketPool Generation

        private static void GeneratePacketPool(StringBuilder sb, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// Generic packet pool for message object reuse.");
            sb.AppendLine($"{indent}/// Reduces GC pressure in high-frequency scenarios.");
            sb.AppendLine($"{indent}/// </summary>");
            sb.AppendLine($"{indent}internal sealed class PacketPool<T> where T : class, new()");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    private readonly Stack<T> _stack;");
            sb.AppendLine($"{indent}    private readonly int _max;");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public PacketPool(int max = 256)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        _max = max;");
            sb.AppendLine($"{indent}        _stack = new Stack<T>(Math.Min(max, 32));");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public T Rent()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        lock (_stack)");
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            return _stack.Count > 0 ? _stack.Pop() : new T();");
            sb.AppendLine($"{indent}        }}");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public void Return(T obj)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        if (obj == null) return;");
            sb.AppendLine($"{indent}        lock (_stack)");
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            if (_stack.Count < _max)");
            sb.AppendLine($"{indent}                _stack.Push(obj);");
            sb.AppendLine($"{indent}        }}");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region ProtoReader Generation (Span-based)

        private static void GenerateProtoReader(StringBuilder sb, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// Span-based Protobuf reader (ref struct - zero allocation).");
            sb.AppendLine($"{indent}/// Replaces MemoryStream for decode path.");
            sb.AppendLine($"{indent}/// </summary>");
            sb.AppendLine($"{indent}internal ref struct ProtoReader");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    private readonly ReadOnlySpan<byte> _span;");
            sb.AppendLine($"{indent}    private int _pos;");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public ProtoReader(ReadOnlySpan<byte> span)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        _span = span;");
            sb.AppendLine($"{indent}        _pos = 0;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public int Position => _pos;");
            sb.AppendLine($"{indent}    public int Length => _span.Length;");
            sb.AppendLine($"{indent}    public bool IsEnd => _pos >= _span.Length;");
            sb.AppendLine();

            // TryReadTag
            sb.AppendLine($"{indent}    public bool TryReadTag(out int fieldNumber, out int wireType)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        if (_pos >= _span.Length)");
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            fieldNumber = 0;");
            sb.AppendLine($"{indent}            wireType = 0;");
            sb.AppendLine($"{indent}            return false;");
            sb.AppendLine($"{indent}        }}");
            sb.AppendLine($"{indent}        var tag = ReadVarint32();");
            sb.AppendLine($"{indent}        if (tag == 0)");
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            fieldNumber = 0;");
            sb.AppendLine($"{indent}            wireType = 0;");
            sb.AppendLine($"{indent}            return false;");
            sb.AppendLine($"{indent}        }}");
            sb.AppendLine($"{indent}        fieldNumber = (int)(tag >> 3);");
            sb.AppendLine($"{indent}        wireType = (int)(tag & 0x7);");
            sb.AppendLine($"{indent}        return true;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // ReadVarint32
            sb.AppendLine($"{indent}    public uint ReadVarint32()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        uint result = 0;");
            sb.AppendLine($"{indent}        int shift = 0;");
            sb.AppendLine($"{indent}        while (shift < 35)");
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            if (_pos >= _span.Length) throw new EndOfStreamException(\"Unexpected end of stream reading varint\");");
            sb.AppendLine($"{indent}            byte b = _span[_pos++];");
            sb.AppendLine($"{indent}            result |= (uint)(b & 0x7F) << shift;");
            sb.AppendLine($"{indent}            if ((b & 0x80) == 0) return result;");
            sb.AppendLine($"{indent}            shift += 7;");
            sb.AppendLine($"{indent}        }}");
            sb.AppendLine($"{indent}        throw new InvalidDataException(\"Varint32 overflow\");");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // ReadVarint64
            sb.AppendLine($"{indent}    public ulong ReadVarint64()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        ulong result = 0;");
            sb.AppendLine($"{indent}        int shift = 0;");
            sb.AppendLine($"{indent}        while (shift < 70)");
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            if (_pos >= _span.Length) throw new EndOfStreamException(\"Unexpected end of stream reading varint\");");
            sb.AppendLine($"{indent}            byte b = _span[_pos++];");
            sb.AppendLine($"{indent}            result |= (ulong)(b & 0x7F) << shift;");
            sb.AppendLine($"{indent}            if ((b & 0x80) == 0) return result;");
            sb.AppendLine($"{indent}            shift += 7;");
            sb.AppendLine($"{indent}        }}");
            sb.AppendLine($"{indent}        throw new InvalidDataException(\"Varint64 overflow\");");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // ReadLength
            sb.AppendLine($"{indent}    public int ReadLength()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        return (int)ReadVarint32();");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // ReadFixed32
            sb.AppendLine($"{indent}    public uint ReadFixed32()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        if (_pos + 4 > _span.Length) throw new EndOfStreamException(\"Unexpected end of stream reading fixed32\");");
            sb.AppendLine($"{indent}        uint result = BitConverter.ToUInt32(_span.Slice(_pos, 4));");
            sb.AppendLine($"{indent}        _pos += 4;");
            sb.AppendLine($"{indent}        return result;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // ReadFixed64
            sb.AppendLine($"{indent}    public ulong ReadFixed64()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        if (_pos + 8 > _span.Length) throw new EndOfStreamException(\"Unexpected end of stream reading fixed64\");");
            sb.AppendLine($"{indent}        ulong result = BitConverter.ToUInt64(_span.Slice(_pos, 8));");
            sb.AppendLine($"{indent}        _pos += 8;");
            sb.AppendLine($"{indent}        return result;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // ReadFloat
            sb.AppendLine($"{indent}    public float ReadFloat()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        return BitConverter.UInt32BitsToSingle(ReadFixed32());");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // ReadDouble
            sb.AppendLine($"{indent}    public double ReadDouble()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        return BitConverter.UInt64BitsToDouble(ReadFixed64());");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // ReadBytesSpan
            sb.AppendLine($"{indent}    public ReadOnlySpan<byte> ReadBytesSpan(int len)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        if (_pos + len > _span.Length) throw new EndOfStreamException(\"Unexpected end of stream reading bytes\");");
            sb.AppendLine($"{indent}        var result = _span.Slice(_pos, len);");
            sb.AppendLine($"{indent}        _pos += len;");
            sb.AppendLine($"{indent}        return result;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // ReadString
            sb.AppendLine($"{indent}    public string ReadString()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        int len = ReadLength();");
            sb.AppendLine($"{indent}        if (len == 0) return \"\";");
            sb.AppendLine($"{indent}        var span = ReadBytesSpan(len);");
            sb.AppendLine($"{indent}        return Encoding.UTF8.GetString(span);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // ReadBytes (byte[] 반환 - DTO가 byte[]인 경우)
            sb.AppendLine($"{indent}    public byte[] ReadBytes()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        int len = ReadLength();");
            sb.AppendLine($"{indent}        if (len == 0) return Array.Empty<byte>();");
            sb.AppendLine($"{indent}        var span = ReadBytesSpan(len);");
            sb.AppendLine($"{indent}        return span.ToArray();");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // SkipField
            sb.AppendLine($"{indent}    public void SkipField(int wireType)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        switch (wireType)");
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            case 0: // Varint");
            sb.AppendLine($"{indent}                ReadVarint64();");
            sb.AppendLine($"{indent}                break;");
            sb.AppendLine($"{indent}            case 1: // 64-bit");
            sb.AppendLine($"{indent}                if (_pos + 8 > _span.Length) throw new EndOfStreamException();");
            sb.AppendLine($"{indent}                _pos += 8;");
            sb.AppendLine($"{indent}                break;");
            sb.AppendLine($"{indent}            case 2: // Length-delimited");
            sb.AppendLine($"{indent}                int len = ReadLength();");
            sb.AppendLine($"{indent}                if (_pos + len > _span.Length) throw new EndOfStreamException();");
            sb.AppendLine($"{indent}                _pos += len;");
            sb.AppendLine($"{indent}                break;");
            sb.AppendLine($"{indent}            case 5: // 32-bit");
            sb.AppendLine($"{indent}                if (_pos + 4 > _span.Length) throw new EndOfStreamException();");
            sb.AppendLine($"{indent}                _pos += 4;");
            sb.AppendLine($"{indent}                break;");
            sb.AppendLine($"{indent}            default:");
            sb.AppendLine($"{indent}                throw new InvalidDataException($\"Unknown wire type: {{wireType}}\");");
            sb.AppendLine($"{indent}        }}");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // CreateSubReader (for nested messages / map entries)
            sb.AppendLine($"{indent}    public ProtoReader CreateSubReader(int len)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        var sub = new ProtoReader(ReadBytesSpan(len));");
            sb.AppendLine($"{indent}        return sub;");
            sb.AppendLine($"{indent}    }}");

            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region Message Class Generation

        private static void GenerateMessageClass(StringBuilder sb, MessageSpec message, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// {message.Name} message (opcode: {message.Opcode})");
            sb.AppendLine($"{indent}/// </summary>");
            sb.AppendLine($"{indent}public sealed class {message.Name}");
            sb.AppendLine($"{indent}{{");

            sb.AppendLine($"{indent}    public const int Opcode = {message.Opcode};");
            sb.AppendLine();

            // Properties
            foreach (var field in message.Fields)
            {
                var csType = ProtocolTypeMapper.ToCSharp(field.Type);
                var propName = ToPascalCase(field.Name);
                var tag = field.Tag ?? 0;

                sb.AppendLine($"{indent}    /// <summary>Tag: {tag}</summary>");

                if (field.Optional)
                {
                    sb.AppendLine($"{indent}    public {csType}? {propName} {{ get; set; }}");
                }
                else
                {
                    var defaultValue = GetDefaultValue(csType);
                    if (!string.IsNullOrEmpty(defaultValue))
                        sb.AppendLine($"{indent}    public {csType} {propName} {{ get; set; }} = {defaultValue};");
                    else
                        sb.AppendLine($"{indent}    public {csType} {propName} {{ get; set; }}");
                }
            }

            sb.AppendLine();

            // _Reset method for pool return safety
            sb.AppendLine($"{indent}    /// <summary>Reset all fields for pool return</summary>");
            sb.AppendLine($"{indent}    internal void _Reset()");
            sb.AppendLine($"{indent}    {{");
            foreach (var field in message.Fields)
            {
                var csType = ProtocolTypeMapper.ToCSharp(field.Type);
                var propName = ToPascalCase(field.Name);
                var resetValue = GetResetValue(csType, field.Optional);
                sb.AppendLine($"{indent}        {propName} = {resetValue};");
            }
            sb.AppendLine($"{indent}    }}");

            sb.AppendLine($"{indent}}}");
        }

        private static string GetResetValue(string csType, bool isOptional)
        {
            if (isOptional) return "null";
            
            return csType switch
            {
                "string" => "\"\"",
                "bool" => "false",
                "int" or "uint" or "long" or "ulong" or "float" or "double" => "0",
                "byte[]" => "Array.Empty<byte>()",
                _ when csType.EndsWith("[]") => $"Array.Empty<{csType[..^2]}>()",
                _ when csType.StartsWith("Dictionary<") => $"new {csType}()",
                _ => "default!"
            };
        }

        #endregion

        #region Opcodes Class Generation

        private static void GenerateOpcodesClass(StringBuilder sb, ProtocolSpec spec, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>Opcode constants</summary>");
            sb.AppendLine($"{indent}public static class Opcodes");
            sb.AppendLine($"{indent}{{");

            foreach (var message in spec.Messages.OrderBy(m => m.Opcode))
            {
                sb.AppendLine($"{indent}    public const int {message.Name} = {message.Opcode};");
            }

            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region ProtobufWire Helper (Encode 전용)

        private static void GenerateProtobufWireHelper(StringBuilder sb, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>Protobuf wire format helper (Encode 전용)</summary>");
            sb.AppendLine($"{indent}private static class ProtobufWire");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    // Wire types");
            sb.AppendLine($"{indent}    public const int WireVarint = 0;");
            sb.AppendLine($"{indent}    public const int Wire64Bit = 1;");
            sb.AppendLine($"{indent}    public const int WireLengthDelimited = 2;");
            sb.AppendLine($"{indent}    public const int Wire32Bit = 5;");
            sb.AppendLine();

            // WriteTag
            sb.AppendLine($"{indent}    public static void WriteTag(MemoryStream ms, int fieldNumber, int wireType)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        WriteVarint(ms, (ulong)((fieldNumber << 3) | wireType));");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // WriteVarint
            sb.AppendLine($"{indent}    public static void WriteVarint(MemoryStream ms, ulong value)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        while (value >= 0x80)");
            sb.AppendLine($"{indent}        {{");
            sb.AppendLine($"{indent}            ms.WriteByte((byte)(value | 0x80));");
            sb.AppendLine($"{indent}            value >>= 7;");
            sb.AppendLine($"{indent}        }}");
            sb.AppendLine($"{indent}        ms.WriteByte((byte)value);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // WriteVarintSigned
            sb.AppendLine($"{indent}    public static void WriteVarintSigned(MemoryStream ms, long value)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        WriteVarint(ms, (ulong)value);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // WriteFixed32
            sb.AppendLine($"{indent}    public static void WriteFixed32(MemoryStream ms, uint value)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        ms.WriteByte((byte)value);");
            sb.AppendLine($"{indent}        ms.WriteByte((byte)(value >> 8));");
            sb.AppendLine($"{indent}        ms.WriteByte((byte)(value >> 16));");
            sb.AppendLine($"{indent}        ms.WriteByte((byte)(value >> 24));");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // WriteFixed64
            sb.AppendLine($"{indent}    public static void WriteFixed64(MemoryStream ms, ulong value)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        WriteFixed32(ms, (uint)value);");
            sb.AppendLine($"{indent}        WriteFixed32(ms, (uint)(value >> 32));");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // WriteFloat
            sb.AppendLine($"{indent}    public static void WriteFloat(MemoryStream ms, float value)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        WriteFixed32(ms, BitConverter.SingleToUInt32Bits(value));");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // WriteDouble
            sb.AppendLine($"{indent}    public static void WriteDouble(MemoryStream ms, double value)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        WriteFixed64(ms, BitConverter.DoubleToUInt64Bits(value));");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // WriteString
            sb.AppendLine($"{indent}    public static void WriteString(MemoryStream ms, string value)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        var bytes = Encoding.UTF8.GetBytes(value);");
            sb.AppendLine($"{indent}        WriteVarint(ms, (ulong)bytes.Length);");
            sb.AppendLine($"{indent}        ms.Write(bytes, 0, bytes.Length);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // WriteBytes
            sb.AppendLine($"{indent}    public static void WriteBytes(MemoryStream ms, byte[] value)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        WriteVarint(ms, (ulong)value.Length);");
            sb.AppendLine($"{indent}        ms.Write(value, 0, value.Length);");
            sb.AppendLine($"{indent}    }}");

            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region ICodec Generation

        private static void GenerateICodec(StringBuilder sb, string protocolName, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>Codec interface for {protocolName}</summary>");
            sb.AppendLine($"{indent}public interface ICodec");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    byte[] Encode<T>(T message) where T : class;");
            sb.AppendLine($"{indent}    T Decode<T>(byte[] payload) where T : class, new();");
            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region CodecJson Generation

        private static void GenerateCodecJson(StringBuilder sb, ProtocolSpec spec, string protocolName, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>JSON codec for {protocolName}</summary>");
            sb.AppendLine($"{indent}public sealed class CodecJson : ICodec");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    private static readonly JsonSerializerOptions _options = new()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,");
            sb.AppendLine($"{indent}        WriteIndented = false");
            sb.AppendLine($"{indent}    }};");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public byte[] Encode<T>(T message) where T : class");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        return JsonSerializer.SerializeToUtf8Bytes(message, _options);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public T Decode<T>(byte[] payload) where T : class, new()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        return JsonSerializer.Deserialize<T>(payload, _options) ?? new T();");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region CodecProtobuf Generation (ProtoReader 기반)

        private static void GenerateCodecProtobuf(StringBuilder sb, ProtocolSpec spec, string protocolName, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// Protobuf wire-format codec for {protocolName}.");
            sb.AppendLine($"{indent}/// Uses PacketPool&lt;T&gt; + ProtoReader (Span-based, zero-copy decode).");
            sb.AppendLine($"{indent}/// </summary>");
            sb.AppendLine($"{indent}public sealed class CodecProtobuf : ICodec");
            sb.AppendLine($"{indent}{{");

            // Per-message pools
            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                sb.AppendLine($"{indent}    private readonly PacketPool<{msg.Name}> _pool{msg.Name} = new(256);");
            }
            sb.AppendLine();

            // Encode<T> (기존 방식 유지 - MemoryStream)
            sb.AppendLine($"{indent}    public byte[] Encode<T>(T message) where T : class");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        using var ms = new MemoryStream();");
            sb.AppendLine();

            bool first = true;
            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                var ifKw = first ? "if" : "else if";
                first = false;
                sb.AppendLine($"{indent}        {ifKw} (message is {msg.Name} m{msg.Name})");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            Encode{msg.Name}(ms, m{msg.Name});");
                sb.AppendLine($"{indent}        }}");
            }
            if (spec.Messages.Count > 0)
            {
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            throw new ArgumentException($\"Unknown message type: {{typeof(T).Name}}\");");
                sb.AppendLine($"{indent}        }}");
            }
            sb.AppendLine();
            sb.AppendLine($"{indent}        return ms.ToArray();");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // Decode<T> (ProtoReader 기반)
            sb.AppendLine($"{indent}    public T Decode<T>(byte[] payload) where T : class, new()");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        var r = new ProtoReader(payload);");
            sb.AppendLine();

            first = true;
            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                var ifKw = first ? "if" : "else if";
                first = false;
                sb.AppendLine($"{indent}        {ifKw} (typeof(T) == typeof({msg.Name}))");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            var m = _pool{msg.Name}.Rent();");
                sb.AppendLine($"{indent}            m._Reset();");
                sb.AppendLine($"{indent}            Fill{msg.Name}(ref r, m);");
                sb.AppendLine($"{indent}            return (m as T)!;");
                sb.AppendLine($"{indent}        }}");
            }
            if (spec.Messages.Count > 0)
            {
                sb.AppendLine($"{indent}        else");
                sb.AppendLine($"{indent}        {{");
                sb.AppendLine($"{indent}            throw new ArgumentException($\"Unknown message type: {{typeof(T).Name}}\");");
                sb.AppendLine($"{indent}        }}");
            }
            else
            {
                sb.AppendLine($"{indent}        throw new ArgumentException($\"Unknown message type: {{typeof(T).Name}}\");");
            }
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // RentDecodeXxx methods (ProtoReader 기반 - ToArray/MemoryStream 제거)
            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                sb.AppendLine($"{indent}    /// <summary>Rent + Decode {msg.Name} (풀링, zero-copy)</summary>");
                sb.AppendLine($"{indent}    internal {msg.Name} RentDecode{msg.Name}(ReadOnlySpan<byte> payload)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        var m = _pool{msg.Name}.Rent();");
                sb.AppendLine($"{indent}        m._Reset();");
                sb.AppendLine($"{indent}        var r = new ProtoReader(payload);");
                sb.AppendLine($"{indent}        Fill{msg.Name}(ref r, m);");
                sb.AppendLine($"{indent}        return m;");
                sb.AppendLine($"{indent}    }}");
                sb.AppendLine();
            }

            // Return methods
            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                sb.AppendLine($"{indent}    /// <summary>Return {msg.Name} to pool</summary>");
                sb.AppendLine($"{indent}    internal void Return({msg.Name} m)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        m._Reset();");
                sb.AppendLine($"{indent}        _pool{msg.Name}.Return(m);");
                sb.AppendLine($"{indent}    }}");
                sb.AppendLine();
            }

            // Per-message encode methods (MemoryStream - 기존 유지)
            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                GenerateEncodeMethod(sb, msg, indent + "    ");
                sb.AppendLine();
            }

            // Per-message fill methods (ProtoReader 기반)
            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                GenerateFillMethod(sb, msg, indent + "    ");
                sb.AppendLine();
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateEncodeMethod(StringBuilder sb, MessageSpec msg, string indent)
        {
            sb.AppendLine($"{indent}private static void Encode{msg.Name}(MemoryStream ms, {msg.Name} m)");
            sb.AppendLine($"{indent}{{");

            foreach (var field in msg.Fields)
            {
                var tag = field.Tag!.Value;
                var propName = ToPascalCase(field.Name);

                if (field.Optional)
                {
                    sb.AppendLine($"{indent}    if (m.{propName} != null)");
                    sb.AppendLine($"{indent}    {{");
                    GenerateFieldEncode(sb, field, tag, $"m.{propName}", indent + "        ", true);
                    sb.AppendLine($"{indent}    }}");
                }
                else
                {
                    GenerateFieldEncode(sb, field, tag, $"m.{propName}", indent + "    ", false);
                }
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateFillMethod(StringBuilder sb, MessageSpec msg, string indent)
        {
            sb.AppendLine($"{indent}private static void Fill{msg.Name}(ref ProtoReader r, {msg.Name} m)");
            sb.AppendLine($"{indent}{{");

            // Generate temp lists for repeated fields
            foreach (var field in msg.Fields)
            {
                if (field.Type.EndsWith("[]"))
                {
                    var elemType = field.Type[..^2];
                    var csElemType = ProtocolTypeMapper.ToCSharp(elemType);
                    var propName = ToPascalCase(field.Name);
                    sb.AppendLine($"{indent}    var _{propName}List = new List<{csElemType}>();");
                }
                else if (field.Type.StartsWith("map<"))
                {
                    var propName = ToPascalCase(field.Name);
                    sb.AppendLine($"{indent}    var _{propName}Dict = new Dictionary<string, string>();");
                }
            }

            sb.AppendLine();
            sb.AppendLine($"{indent}    while (r.TryReadTag(out int field, out int wt))");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        switch (field)");
            sb.AppendLine($"{indent}        {{");

            foreach (var field in msg.Fields)
            {
                var tag = field.Tag!.Value;
                var propName = ToPascalCase(field.Name);
                sb.AppendLine($"{indent}            case {tag}:");
                GenerateFieldDecodeProtoReader(sb, field, propName, indent + "                ");
                sb.AppendLine($"{indent}                break;");
            }

            sb.AppendLine($"{indent}            default:");
            sb.AppendLine($"{indent}                r.SkipField(wt);");
            sb.AppendLine($"{indent}                break;");
            sb.AppendLine($"{indent}        }}");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // Assign lists to arrays
            foreach (var field in msg.Fields)
            {
                if (field.Type.EndsWith("[]"))
                {
                    var propName = ToPascalCase(field.Name);
                    sb.AppendLine($"{indent}    m.{propName} = _{propName}List.ToArray();");
                }
                else if (field.Type.StartsWith("map<"))
                {
                    var propName = ToPascalCase(field.Name);
                    sb.AppendLine($"{indent}    m.{propName} = _{propName}Dict;");
                }
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateFieldEncode(StringBuilder sb, FieldSpec field, int tag, string accessor, string indent, bool isNullable)
        {
            var baseType = field.Type;
            var suffix = isNullable ? ".Value" : "";

            // Arrays
            if (baseType.EndsWith("[]"))
            {
                var elemType = baseType[..^2];
                var isPrimitive = IsPrimitiveType(elemType);
                
                if (isPrimitive)
                {
                    sb.AppendLine($"{indent}if ({accessor} != null && {accessor}.Length > 0)");
                    sb.AppendLine($"{indent}{{");
                    sb.AppendLine($"{indent}    ProtobufWire.WriteTag(ms, {tag}, ProtobufWire.WireLengthDelimited);");
                    sb.AppendLine($"{indent}    using var packed = new MemoryStream();");
                    sb.AppendLine($"{indent}    foreach (var item in {accessor})");
                    sb.AppendLine($"{indent}    {{");
                    GeneratePrimitiveEncode(sb, elemType, "item", indent + "        ", "packed");
                    sb.AppendLine($"{indent}    }}");
                    sb.AppendLine($"{indent}    ProtobufWire.WriteBytes(ms, packed.ToArray());");
                    sb.AppendLine($"{indent}}}");
                }
                else
                {
                    sb.AppendLine($"{indent}if ({accessor} != null)");
                    sb.AppendLine($"{indent}{{");
                    sb.AppendLine($"{indent}    foreach (var item in {accessor})");
                    sb.AppendLine($"{indent}    {{");
                    sb.AppendLine($"{indent}        ProtobufWire.WriteTag(ms, {tag}, ProtobufWire.WireLengthDelimited);");
                    if (elemType == "string")
                        sb.AppendLine($"{indent}        ProtobufWire.WriteString(ms, item ?? \"\");");
                    else if (elemType == "bytes")
                        sb.AppendLine($"{indent}        ProtobufWire.WriteBytes(ms, item ?? Array.Empty<byte>());");
                    sb.AppendLine($"{indent}    }}");
                    sb.AppendLine($"{indent}}}");
                }
                return;
            }

            // Map<string, T>
            if (baseType.StartsWith("map<"))
            {
                sb.AppendLine($"{indent}if ({accessor} != null)");
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}    foreach (var kvp in {accessor})");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        ProtobufWire.WriteTag(ms, {tag}, ProtobufWire.WireLengthDelimited);");
                sb.AppendLine($"{indent}        using var entry = new MemoryStream();");
                sb.AppendLine($"{indent}        ProtobufWire.WriteTag(entry, 1, ProtobufWire.WireLengthDelimited);");
                sb.AppendLine($"{indent}        ProtobufWire.WriteString(entry, kvp.Key ?? \"\");");
                sb.AppendLine($"{indent}        ProtobufWire.WriteTag(entry, 2, ProtobufWire.WireLengthDelimited);");
                sb.AppendLine($"{indent}        ProtobufWire.WriteString(entry, kvp.Value ?? \"\");");
                sb.AppendLine($"{indent}        ProtobufWire.WriteBytes(ms, entry.ToArray());");
                sb.AppendLine($"{indent}    }}");
                sb.AppendLine($"{indent}}}");
                return;
            }

            // Scalar types
            GenerateScalarEncode(sb, baseType, tag, accessor, suffix, indent);
        }

        private static void GenerateScalarEncode(StringBuilder sb, string type, int tag, string accessor, string suffix, string indent)
        {
            switch (type)
            {
                case "bool":
                    sb.AppendLine($"{indent}ProtobufWire.WriteTag(ms, {tag}, ProtobufWire.WireVarint);");
                    sb.AppendLine($"{indent}ProtobufWire.WriteVarint(ms, {accessor}{suffix} ? 1UL : 0UL);");
                    break;
                case "int32":
                    sb.AppendLine($"{indent}ProtobufWire.WriteTag(ms, {tag}, ProtobufWire.WireVarint);");
                    sb.AppendLine($"{indent}ProtobufWire.WriteVarintSigned(ms, {accessor}{suffix});");
                    break;
                case "uint32":
                    sb.AppendLine($"{indent}ProtobufWire.WriteTag(ms, {tag}, ProtobufWire.WireVarint);");
                    sb.AppendLine($"{indent}ProtobufWire.WriteVarint(ms, {accessor}{suffix});");
                    break;
                case "int64":
                    sb.AppendLine($"{indent}ProtobufWire.WriteTag(ms, {tag}, ProtobufWire.WireVarint);");
                    sb.AppendLine($"{indent}ProtobufWire.WriteVarintSigned(ms, {accessor}{suffix});");
                    break;
                case "uint64":
                    sb.AppendLine($"{indent}ProtobufWire.WriteTag(ms, {tag}, ProtobufWire.WireVarint);");
                    sb.AppendLine($"{indent}ProtobufWire.WriteVarint(ms, {accessor}{suffix});");
                    break;
                case "float":
                    sb.AppendLine($"{indent}ProtobufWire.WriteTag(ms, {tag}, ProtobufWire.Wire32Bit);");
                    sb.AppendLine($"{indent}ProtobufWire.WriteFloat(ms, {accessor}{suffix});");
                    break;
                case "double":
                    sb.AppendLine($"{indent}ProtobufWire.WriteTag(ms, {tag}, ProtobufWire.Wire64Bit);");
                    sb.AppendLine($"{indent}ProtobufWire.WriteDouble(ms, {accessor}{suffix});");
                    break;
                case "string":
                    sb.AppendLine($"{indent}if (!string.IsNullOrEmpty({accessor}))");
                    sb.AppendLine($"{indent}{{");
                    sb.AppendLine($"{indent}    ProtobufWire.WriteTag(ms, {tag}, ProtobufWire.WireLengthDelimited);");
                    sb.AppendLine($"{indent}    ProtobufWire.WriteString(ms, {accessor});");
                    sb.AppendLine($"{indent}}}");
                    break;
                case "bytes":
                    sb.AppendLine($"{indent}if ({accessor} != null && {accessor}.Length > 0)");
                    sb.AppendLine($"{indent}{{");
                    sb.AppendLine($"{indent}    ProtobufWire.WriteTag(ms, {tag}, ProtobufWire.WireLengthDelimited);");
                    sb.AppendLine($"{indent}    ProtobufWire.WriteBytes(ms, {accessor});");
                    sb.AppendLine($"{indent}}}");
                    break;
            }
        }

        private static void GeneratePrimitiveEncode(StringBuilder sb, string type, string varName, string indent, string streamName)
        {
            switch (type)
            {
                case "bool":
                    sb.AppendLine($"{indent}ProtobufWire.WriteVarint({streamName}, {varName} ? 1UL : 0UL);");
                    break;
                case "int32":
                    sb.AppendLine($"{indent}ProtobufWire.WriteVarintSigned({streamName}, {varName});");
                    break;
                case "uint32":
                    sb.AppendLine($"{indent}ProtobufWire.WriteVarint({streamName}, {varName});");
                    break;
                case "int64":
                    sb.AppendLine($"{indent}ProtobufWire.WriteVarintSigned({streamName}, {varName});");
                    break;
                case "uint64":
                    sb.AppendLine($"{indent}ProtobufWire.WriteVarint({streamName}, {varName});");
                    break;
                case "float":
                    sb.AppendLine($"{indent}ProtobufWire.WriteFloat({streamName}, {varName});");
                    break;
                case "double":
                    sb.AppendLine($"{indent}ProtobufWire.WriteDouble({streamName}, {varName});");
                    break;
            }
        }

        private static void GenerateFieldDecodeProtoReader(StringBuilder sb, FieldSpec field, string propName, string indent)
        {
            var baseType = field.Type;

            // Arrays
            if (baseType.EndsWith("[]"))
            {
                var elemType = baseType[..^2];
                var isPrimitive = IsPrimitiveType(elemType);
                
                if (isPrimitive)
                {
                    // Packed encoding
                    sb.AppendLine($"{indent}{{");
                    sb.AppendLine($"{indent}    int len = r.ReadLength();");
                    sb.AppendLine($"{indent}    int end = r.Position + len;");
                    sb.AppendLine($"{indent}    while (r.Position < end)");
                    sb.AppendLine($"{indent}    {{");
                    GeneratePrimitiveDecodeProtoReader(sb, elemType, $"_{propName}List", indent + "        ");
                    sb.AppendLine($"{indent}    }}");
                    sb.AppendLine($"{indent}}}");
                }
                else
                {
                    // Non-packed (string/bytes)
                    if (elemType == "string")
                        sb.AppendLine($"{indent}_{propName}List.Add(r.ReadString());");
                    else if (elemType == "bytes")
                        sb.AppendLine($"{indent}_{propName}List.Add(r.ReadBytes());");
                }
                return;
            }

            // Map<string, T>
            if (baseType.StartsWith("map<"))
            {
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}    int len = r.ReadLength();");
                sb.AppendLine($"{indent}    var sub = r.CreateSubReader(len);");
                sb.AppendLine($"{indent}    string key = \"\";");
                sb.AppendLine($"{indent}    string value = \"\";");
                sb.AppendLine($"{indent}    while (sub.TryReadTag(out int f, out int w))");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        if (f == 1) key = sub.ReadString();");
                sb.AppendLine($"{indent}        else if (f == 2) value = sub.ReadString();");
                sb.AppendLine($"{indent}        else sub.SkipField(w);");
                sb.AppendLine($"{indent}    }}");
                sb.AppendLine($"{indent}    _{propName}Dict[key] = value;");
                sb.AppendLine($"{indent}}}");
                return;
            }

            // Scalar types
            GenerateScalarDecodeProtoReader(sb, baseType, propName, indent);
        }

        private static void GenerateScalarDecodeProtoReader(StringBuilder sb, string type, string propName, string indent)
        {
            switch (type)
            {
                case "bool":
                    sb.AppendLine($"{indent}m.{propName} = r.ReadVarint32() != 0;");
                    break;
                case "int32":
                    sb.AppendLine($"{indent}m.{propName} = (int)r.ReadVarint32();");
                    break;
                case "uint32":
                    sb.AppendLine($"{indent}m.{propName} = r.ReadVarint32();");
                    break;
                case "int64":
                    sb.AppendLine($"{indent}m.{propName} = (long)r.ReadVarint64();");
                    break;
                case "uint64":
                    sb.AppendLine($"{indent}m.{propName} = r.ReadVarint64();");
                    break;
                case "float":
                    sb.AppendLine($"{indent}m.{propName} = r.ReadFloat();");
                    break;
                case "double":
                    sb.AppendLine($"{indent}m.{propName} = r.ReadDouble();");
                    break;
                case "string":
                    sb.AppendLine($"{indent}m.{propName} = r.ReadString();");
                    break;
                case "bytes":
                    sb.AppendLine($"{indent}m.{propName} = r.ReadBytes();");
                    break;
            }
        }

        private static void GeneratePrimitiveDecodeProtoReader(StringBuilder sb, string type, string listVar, string indent)
        {
            switch (type)
            {
                case "bool":
                    sb.AppendLine($"{indent}{listVar}.Add(r.ReadVarint32() != 0);");
                    break;
                case "int32":
                    sb.AppendLine($"{indent}{listVar}.Add((int)r.ReadVarint32());");
                    break;
                case "uint32":
                    sb.AppendLine($"{indent}{listVar}.Add(r.ReadVarint32());");
                    break;
                case "int64":
                    sb.AppendLine($"{indent}{listVar}.Add((long)r.ReadVarint64());");
                    break;
                case "uint64":
                    sb.AppendLine($"{indent}{listVar}.Add(r.ReadVarint64());");
                    break;
                case "float":
                    sb.AppendLine($"{indent}{listVar}.Add(r.ReadFloat());");
                    break;
                case "double":
                    sb.AppendLine($"{indent}{listVar}.Add(r.ReadDouble());");
                    break;
            }
        }

        private static bool IsPrimitiveType(string type)
        {
            return type switch
            {
                "bool" or "int32" or "uint32" or "int64" or "uint64" or "float" or "double" => true,
                _ => false
            };
        }

        #endregion

        #region ISender Generation

        private static void GenerateISender(StringBuilder sb, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// Sender interface for protocol.");
            sb.AppendLine($"{indent}/// Proxy 1개 규칙: sessionId로 대상 지정.");
            sb.AppendLine($"{indent}/// </summary>");
            sb.AppendLine($"{indent}public interface ISender");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    void SendTo(int sessionId, ReadOnlySpan<byte> frame);");
            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region Stub Generation (abstract)

        private static void GenerateStub(StringBuilder sb, ProtocolSpec spec, string protocolName, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// Abstract stub for {protocolName} message handling.");
            sb.AppendLine($"{indent}/// 구현 클래스에서 각 OnXxx를 구현해야 함 (핸들러 구현 강제).");
            sb.AppendLine($"{indent}/// </summary>");
            sb.AppendLine($"{indent}public abstract class Stub");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    private readonly CodecProtobuf _codec;");
            sb.AppendLine();
            sb.AppendLine($"{indent}    protected Stub(CodecProtobuf codec)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        _codec = codec ?? throw new ArgumentNullException(nameof(codec));");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // Abstract OnXxx methods
            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                sb.AppendLine($"{indent}    /// <summary>Handle {msg.Name} message</summary>");
                sb.AppendLine($"{indent}    protected abstract void On{msg.Name}({msg.Name} msg, PacketEnvelope env);");
                sb.AppendLine();
            }

            // Virtual OnUnknownOpcode
            sb.AppendLine($"{indent}    /// <summary>Handle unknown opcode (기본: throw)</summary>");
            sb.AppendLine($"{indent}    protected virtual void OnUnknownOpcode(PacketEnvelope env)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        throw new InvalidOperationException($\"Unknown opcode: {{env.Opcode}}\");");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            // Dispatch method
            sb.AppendLine($"{indent}    /// <summary>");
            sb.AppendLine($"{indent}    /// Dispatch raw frame to appropriate handler.");
            sb.AppendLine($"{indent}    /// Frame format: [opcode:int32LE][payload...]");
            sb.AppendLine($"{indent}    /// </summary>");
            sb.AppendLine($"{indent}    public void Dispatch(ReadOnlySpan<byte> frame, EnvelopeMeta meta)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        var opcode = Frame.ReadOpcode(frame);");
            sb.AppendLine($"{indent}        var payload = Frame.ReadPayload(frame);");
            sb.AppendLine($"{indent}        var env = new PacketEnvelope(opcode, payload, meta);");
            sb.AppendLine();
            sb.AppendLine($"{indent}        switch (opcode)");
            sb.AppendLine($"{indent}        {{");

            foreach (var msg in spec.Messages.OrderBy(m => m.Opcode))
            {
                sb.AppendLine($"{indent}            case Opcodes.{msg.Name}:");
                sb.AppendLine($"{indent}            {{");
                sb.AppendLine($"{indent}                {msg.Name}? msg = null;");
                sb.AppendLine($"{indent}                try");
                sb.AppendLine($"{indent}                {{");
                sb.AppendLine($"{indent}                    msg = _codec.RentDecode{msg.Name}(payload);");
                sb.AppendLine($"{indent}                    On{msg.Name}(msg, env);");
                sb.AppendLine($"{indent}                }}");
                sb.AppendLine($"{indent}                finally");
                sb.AppendLine($"{indent}                {{");
                sb.AppendLine($"{indent}                    if (msg != null) _codec.Return(msg);");
                sb.AppendLine($"{indent}                }}");
                sb.AppendLine($"{indent}                return;");
                sb.AppendLine($"{indent}            }}");
            }

            sb.AppendLine($"{indent}            default:");
            sb.AppendLine($"{indent}                OnUnknownOpcode(env);");
            sb.AppendLine($"{indent}                return;");
            sb.AppendLine($"{indent}        }}");
            sb.AppendLine($"{indent}    }}");

            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region Proxy Generation (동기)

        private static void GenerateProxy(StringBuilder sb, ProtocolSpec spec, string protocolName, string indent)
        {
            sb.AppendLine($"{indent}/// <summary>");
            sb.AppendLine($"{indent}/// Proxy for {protocolName} (동기, sessionId 기반).");
            sb.AppendLine($"{indent}/// Proxy 1개 규칙: 연결별 인스턴스가 아닌 프로토콜당 1개.");
            sb.AppendLine($"{indent}/// </summary>");
            sb.AppendLine($"{indent}public sealed class Proxy");
            sb.AppendLine($"{indent}{{");
            sb.AppendLine($"{indent}    private readonly ISender _sender;");
            sb.AppendLine($"{indent}    private readonly CodecProtobuf _codec;");
            sb.AppendLine();
            sb.AppendLine($"{indent}    public Proxy(ISender sender, CodecProtobuf? codec = null)");
            sb.AppendLine($"{indent}    {{");
            sb.AppendLine($"{indent}        _sender = sender ?? throw new ArgumentNullException(nameof(sender));");
            sb.AppendLine($"{indent}        _codec = codec ?? new CodecProtobuf();");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();

            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                sb.AppendLine($"{indent}    /// <summary>Send {msg.Name}</summary>");
                sb.AppendLine($"{indent}    public void {msg.Name}(int sessionId, {msg.Name} msg)");
                sb.AppendLine($"{indent}    {{");
                sb.AppendLine($"{indent}        var payload = _codec.Encode(msg);");
                sb.AppendLine($"{indent}        var frame = Frame.Pack(Opcodes.{msg.Name}, payload);");
                sb.AppendLine($"{indent}        _sender.SendTo(sessionId, frame);");
                sb.AppendLine($"{indent}    }}");
                sb.AppendLine();
            }

            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region Utilities

        private static string ToPascalCase(string input)
        {
            if (string.IsNullOrEmpty(input)) return input;
            return char.ToUpper(input[0]) + (input.Length > 1 ? input[1..] : "");
        }

        private static string GetDefaultValue(string csType)
        {
            if (csType == "string") return "\"\"";
            if (csType.EndsWith("[]"))
            {
                var elementType = csType[..^2];
                return $"Array.Empty<{elementType}>()";
            }
            if (csType.StartsWith("Dictionary<")) return $"new {csType}()";
            return "";
        }

        #endregion
    }
}

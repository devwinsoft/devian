// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System
// </auto-generated>

using System.Text;
using System.Text.Json;

namespace Devian.Tools.Generators
{

    /// <summary>
    /// TypeScript Contract (enum/interface) 생성기
    /// contracts.json → TypeScript enum/interface
    /// </summary>
    public static class TypeScriptContractGenerator
    {
        /// <summary>
        /// Contract JSON → TypeScript 코드 생성
        /// </summary>
        public static string Generate(JsonDocument doc)
        {
            var sb = new StringBuilder();

            // Header
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// DO NOT EDIT - Generated by Devian Build System");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();

            var root = doc.RootElement;

            // enums
            if (root.TryGetProperty("enums", out var enums))
            {
                foreach (var enumDef in enums.EnumerateArray())
                {
                    generateEnum(sb, enumDef);
                    sb.AppendLine();
                }
            }

            // classes (→ interfaces in TS)
            if (root.TryGetProperty("classes", out var classes))
            {
                foreach (var classDef in classes.EnumerateArray())
                {
                    generateInterface(sb, classDef);
                    sb.AppendLine();
                }
            }

            return sb.ToString().TrimEnd();
        }

        private static void generateEnum(StringBuilder sb, JsonElement enumDef)
        {
            var name = enumDef.GetProperty("name").GetString();
            var values = enumDef.GetProperty("values");

            sb.AppendLine($"export enum {name} {{");

            foreach (var val in values.EnumerateArray())
            {
                var valName = val.GetProperty("name").GetString();
                var valValue = val.GetProperty("value").GetInt32();
                sb.AppendLine($"  {valName} = {valValue},");
            }

            sb.AppendLine("}");
        }

        private static void generateInterface(StringBuilder sb, JsonElement classDef)
        {
            var name = classDef.GetProperty("name").GetString();
            var fields = classDef.GetProperty("fields");

            sb.AppendLine($"export interface {name} {{");

            foreach (var field in fields.EnumerateArray())
            {
                var fieldName = field.GetProperty("name").GetString();
                var fieldType = field.GetProperty("type").GetString();
                var tsType = TypeMapper.ToTypeScriptType(fieldType!);
                var camelName = toCamelCase(fieldName!);
                sb.AppendLine($"  {camelName}: {tsType};");
            }

            sb.AppendLine("}");
        }

        private static string toCamelCase(string input)
        {
            if (string.IsNullOrEmpty(input)) return input;
            return char.ToLower(input[0]) + (input.Length > 1 ? input[1..] : "");
        }
    }
}

using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Devian.Tools.Models;

namespace Devian.Tools.Generators
{
    public static class TableLoaderCodegen
    {
        /// <summary>
        /// 테이블 로더 C# 코드 생성.
        /// 네임스페이스는 도메인에서 고정 결정 (하위 네임스페이스 금지).
        /// </summary>
        public static string GenerateCSharpLoader(List<TableSchema> schemas, string domain)
        {
            var csNamespace = DomainNamespace.GetCSharpNamespace(domain);
            DomainNamespace.ValidateNoSubNamespace(csNamespace);
            
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// DO NOT EDIT - Generated by Devian.Tools");
            sb.AppendLine(string.Format("// Domain: {0}", domain));
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
            sb.AppendLine("using Devian.Core;");
            sb.AppendLine();
            sb.AppendLine(string.Format("namespace {0}", csNamespace));
            sb.AppendLine("{");
            sb.AppendLine("    public static partial class Table");
            sb.AppendLine("    {");
            
            var tablesWithKey = schemas.Where(s => s.HasKey).ToList();
            
            foreach (var schema in tablesWithKey)
            {
                var tableName = GetTableName(schema.FileName);
                var rowType = tableName + "Row";
                var keyType = GetKeyType(schema);
                
                sb.AppendLine(string.Format("        /// <summary>{0} - Key: {1}</summary>", schema.FileName, schema.KeyColumnName));
                sb.AppendLine(string.Format("        public static Table<{0}, {1}> T_{2} {{ get; private set; }}", keyType, rowType, tableName));
                sb.AppendLine();
            }
            
            sb.AppendLine("        public static void Load(ILoaderTextJson loader)");
            sb.AppendLine("        {");
            
            foreach (var schema in tablesWithKey)
            {
                var tableName = GetTableName(schema.FileName);
                var rowType = tableName + "Row";
                var keyProp = TypeMapper.ToPascalCase(schema.KeyColumnName);
                sb.AppendLine(string.Format("            T_{0} = loader.Load<{1}>(\"{2}\", r => r.{3});", tableName, rowType, tableName.ToLower(), keyProp));
            }
            
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            
            return sb.ToString();
        }
        
        /// <summary>
        /// 테이블 로더 TypeScript 코드 생성 (legacy 방식).
        /// </summary>
        public static string GenerateTypeScriptLoader(List<TableSchema> schemas, string moduleName)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// DO NOT EDIT - Generated by Devian.Tools");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
            
            var tablesWithKey = schemas.Where(s => s.HasKey).ToList();
            
            foreach (var schema in schemas)
            {
                var tableName = GetTableName(schema.FileName);
                sb.AppendLine(string.Format("import type {{ {0}Row }} from './{1}.g';", tableName, tableName));
            }
            sb.AppendLine();
            
            foreach (var schema in tablesWithKey)
            {
                var tableName = GetTableName(schema.FileName);
                var rowType = tableName + "Row";
                var keyType = GetTypeScriptKeyType(schema);
                
                sb.AppendLine(string.Format("/** {0} - Key: {1} */", schema.FileName, schema.KeyColumnName));
                sb.AppendLine(string.Format("export let T_{0}: Map<{1}, {2}>;", tableName, keyType, rowType));
                sb.AppendLine();
            }
            
            sb.AppendLine("export function loadTables(loader: { load: <T>(name: string) => T[] }) {");
            
            foreach (var schema in tablesWithKey)
            {
                var tableName = GetTableName(schema.FileName);
                var rowType = tableName + "Row";
                var keyProp = TypeMapper.ToCamelCase(schema.KeyColumnName);
                
                sb.AppendLine(string.Format("  const {0}Data = loader.load<{1}>('{0}');", tableName.ToLower(), rowType));
                sb.AppendLine(string.Format("  T_{0} = new Map({1}Data.map(r => [r.{2}, r]));", tableName, tableName.ToLower(), keyProp));
                sb.AppendLine();
            }
            
            sb.AppendLine("}");
            return sb.ToString();
        }
        
        /// <summary>
        /// TypeScript 테이블 캐시 로더 생성.
        /// Node.js fs/promises 기반 비동기 로드.
        /// 
        /// API:
        /// - initializeTables(options: { baseDir: string }): Promise<void>
        /// - getTableRows<T>(tableName: string): readonly T[]
        /// - getTableMap<T>(tableName: string): Readonly<Record<string, T>>
        /// - reloadTables(tableName?: string): Promise<void>
        /// </summary>
        public static string GenerateTypeScriptCacheLoader(List<TableSchema> schemas, string domain)
        {
            var sb = new StringBuilder();
            
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// DO NOT EDIT - Generated by Devian.Tools");
            sb.AppendLine(string.Format("// Domain: {0}", domain));
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
            sb.AppendLine("import { readFile } from 'node:fs/promises';");
            sb.AppendLine("import { join } from 'node:path';");
            sb.AppendLine();
            
            // Import row types
            foreach (var schema in schemas)
            {
                var tableName = GetTableName(schema.FileName);
                sb.AppendLine(string.Format("import type {{ {0}Row }} from './{0}Row.g';", tableName));
            }
            sb.AppendLine();
            
            // Table metadata type
            sb.AppendLine("// === Table Metadata ===");
            sb.AppendLine("interface TableMeta {");
            sb.AppendLine("  name: string;");
            sb.AppendLine("  fileName: string;");
            sb.AppendLine("  keyColumn: string;");
            sb.AppendLine("}");
            sb.AppendLine();
            
            // Table definitions constant
            sb.AppendLine("const TABLE_DEFS: readonly TableMeta[] = [");
            foreach (var schema in schemas.Where(s => s.HasKey))
            {
                var tableName = GetTableName(schema.FileName);
                var keyProp = TypeMapper.ToCamelCase(schema.KeyColumnName);
                sb.AppendLine(string.Format("  {{ name: '{0}', fileName: '{1}', keyColumn: '{2}' }},", 
                    tableName, tableName.ToLower(), keyProp));
            }
            sb.AppendLine("] as const;");
            sb.AppendLine();
            
            // Cache storage
            sb.AppendLine("// === Cache Storage (module scope) ===");
            sb.AppendLine("let _baseDir: string | null = null;");
            sb.AppendLine("const _rowsCache = new Map<string, readonly unknown[]>();");
            sb.AppendLine("const _mapCache = new Map<string, Readonly<Record<string, unknown>>>();");
            sb.AppendLine();
            
            // initializeTables
            sb.AppendLine("/**");
            sb.AppendLine(" * Initialize tables from JSON files.");
            sb.AppendLine(" * @param options.baseDir - Base directory containing table JSON files");
            sb.AppendLine(" */");
            sb.AppendLine("export async function initializeTables(options: { baseDir: string }): Promise<void> {");
            sb.AppendLine("  _baseDir = options.baseDir;");
            sb.AppendLine("  await reloadTables();");
            sb.AppendLine("}");
            sb.AppendLine();
            
            // getTableRows
            sb.AppendLine("/**");
            sb.AppendLine(" * Get table rows as readonly array.");
            sb.AppendLine(" * @param tableName - Name of the table");
            sb.AppendLine(" * @returns Readonly array of rows");
            sb.AppendLine(" */");
            sb.AppendLine("export function getTableRows<T>(tableName: string): readonly T[] {");
            sb.AppendLine("  const rows = _rowsCache.get(tableName);");
            sb.AppendLine("  if (!rows) {");
            sb.AppendLine("    throw new Error(`Table '${tableName}' not loaded. Call initializeTables() first.`);");
            sb.AppendLine("  }");
            sb.AppendLine("  return rows as readonly T[];");
            sb.AppendLine("}");
            sb.AppendLine();
            
            // getTableMap
            sb.AppendLine("/**");
            sb.AppendLine(" * Get table as readonly key-value map.");
            sb.AppendLine(" * @param tableName - Name of the table");
            sb.AppendLine(" * @returns Readonly record keyed by row key");
            sb.AppendLine(" */");
            sb.AppendLine("export function getTableMap<T>(tableName: string): Readonly<Record<string, T>> {");
            sb.AppendLine("  const map = _mapCache.get(tableName);");
            sb.AppendLine("  if (!map) {");
            sb.AppendLine("    throw new Error(`Table '${tableName}' not loaded. Call initializeTables() first.`);");
            sb.AppendLine("  }");
            sb.AppendLine("  return map as Readonly<Record<string, T>>;");
            sb.AppendLine("}");
            sb.AppendLine();
            
            // reloadTables
            sb.AppendLine("/**");
            sb.AppendLine(" * Reload tables from disk.");
            sb.AppendLine(" * @param tableName - Optional. If provided, reload only this table. Otherwise reload all.");
            sb.AppendLine(" */");
            sb.AppendLine("export async function reloadTables(tableName?: string): Promise<void> {");
            sb.AppendLine("  if (!_baseDir) {");
            sb.AppendLine("    throw new Error('Tables not initialized. Call initializeTables() first.');");
            sb.AppendLine("  }");
            sb.AppendLine();
            sb.AppendLine("  const tablesToLoad = tableName");
            sb.AppendLine("    ? TABLE_DEFS.filter(t => t.name === tableName)");
            sb.AppendLine("    : TABLE_DEFS;");
            sb.AppendLine();
            sb.AppendLine("  if (tableName && tablesToLoad.length === 0) {");
            sb.AppendLine("    throw new Error(`Unknown table: '${tableName}'`);");
            sb.AppendLine("  }");
            sb.AppendLine();
            sb.AppendLine("  for (const table of tablesToLoad) {");
            sb.AppendLine("    const filePath = join(_baseDir, `${table.fileName}.json`);");
            sb.AppendLine("    ");
            sb.AppendLine("    let content: string;");
            sb.AppendLine("    try {");
            sb.AppendLine("      content = await readFile(filePath, 'utf8');");
            sb.AppendLine("    } catch (err) {");
            sb.AppendLine("      throw new Error(`Failed to read table file: ${filePath}. ${err}`);");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    let rows: unknown[];");
            sb.AppendLine("    try {");
            sb.AppendLine("      rows = JSON.parse(content);");
            sb.AppendLine("    } catch (err) {");
            sb.AppendLine("      throw new Error(`Failed to parse table JSON: ${filePath}. ${err}`);");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    if (!Array.isArray(rows)) {");
            sb.AppendLine("      throw new Error(`Table JSON must be an array: ${filePath}`);");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    // Build map keyed by keyColumn");
            sb.AppendLine("    const map: Record<string, unknown> = {};");
            sb.AppendLine("    for (const row of rows) {");
            sb.AppendLine("      const key = String((row as Record<string, unknown>)[table.keyColumn]);");
            sb.AppendLine("      map[key] = row;");
            sb.AppendLine("    }");
            sb.AppendLine();
            sb.AppendLine("    _rowsCache.set(table.name, Object.freeze(rows));");
            sb.AppendLine("    _mapCache.set(table.name, Object.freeze(map));");
            sb.AppendLine("  }");
            sb.AppendLine("}");
            sb.AppendLine();
            
            // Type-safe accessors for each table
            sb.AppendLine("// === Type-safe Table Accessors ===");
            foreach (var schema in schemas.Where(s => s.HasKey))
            {
                var tableName = GetTableName(schema.FileName);
                var rowType = tableName + "Row";
                var keyType = GetTypeScriptKeyType(schema);
                var keyProp = TypeMapper.ToCamelCase(schema.KeyColumnName);
                
                sb.AppendLine();
                sb.AppendLine(string.Format("/** Get {0} rows */", tableName));
                sb.AppendLine(string.Format("export function get{0}Rows(): readonly {1}[] {{", tableName, rowType));
                sb.AppendLine(string.Format("  return getTableRows<{0}>('{1}');", rowType, tableName));
                sb.AppendLine("}");
                sb.AppendLine();
                sb.AppendLine(string.Format("/** Get {0} by key */", tableName));
                sb.AppendLine(string.Format("export function get{0}(key: {1}): {2} | undefined {{", tableName, keyType, rowType));
                sb.AppendLine(string.Format("  return getTableMap<{0}>('{1}')[String(key)];", rowType, tableName));
                sb.AppendLine("}");
            }
            
            return sb.ToString();
        }
        
        private static string GetTableName(string fileName) 
        { 
            return Path.GetFileNameWithoutExtension(fileName); 
        }
        
        private static string GetKeyType(TableSchema schema) 
        { 
            return TypeMapper.ToCSharp(schema.Columns.First(c => c.IsKey).Type, false); 
        }
        
        private static string GetTypeScriptKeyType(TableSchema schema) 
        { 
            return TypeMapper.ToTypeScript(schema.Columns.First(c => c.IsKey).Type, false); 
        }
    }
}

// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System
// </auto-generated>

using System;
using System.Collections.Generic;

namespace Devian.Tools.Generators
{

    /// <summary>
    /// Excel 타입 → 언어별 타입 매핑
    /// 
    /// Scalar 타입 (10종):
    /// - byte, ubyte, short, ushort, int, uint, long, ulong, float, string
    /// 
    /// Reference 타입 (Strict Mode):
    /// - enum:{Name} / enum:{Name}[] (enum 타입)
    /// - class:{Name} / class:{Name}[] (message 타입)
    /// - enum:Common.{Name} / class:Common.{Name} (Common 도메인)
    /// 
    /// 금지:
    /// - ref:{Name} (deprecated, use enum: or class:)
    /// 
    /// 배열:
    /// - 모든 타입에 [] 허용
    /// </summary>
    public static class TypeMapper
    {
        // Excel → Proto 매핑
        private static readonly Dictionary<string, string> ExcelToProto = new()
        {
            ["byte"] = "int32",
            ["ubyte"] = "uint32",
            ["short"] = "int32",
            ["ushort"] = "uint32",
            ["int"] = "int32",
            ["uint"] = "uint32",
            ["long"] = "int64",
            ["ulong"] = "uint64",
            ["float"] = "float",
            ["string"] = "string",
        };

        // Excel → C# 매핑
        private static readonly Dictionary<string, string> ExcelToCSharp = new()
        {
            ["byte"] = "sbyte",
            ["ubyte"] = "byte",
            ["short"] = "short",
            ["ushort"] = "ushort",
            ["int"] = "int",
            ["uint"] = "uint",
            ["long"] = "long",
            ["ulong"] = "ulong",
            ["float"] = "float",
            ["string"] = "string",
        };

        // Excel → TypeScript 매핑
        private static readonly Dictionary<string, string> ExcelToTypeScript = new()
        {
            ["byte"] = "number",
            ["ubyte"] = "number",
            ["short"] = "number",
            ["ushort"] = "number",
            ["int"] = "number",
            ["uint"] = "number",
            ["long"] = "bigint",
            ["ulong"] = "bigint",
            ["float"] = "number",
            ["string"] = "string",
        };

        // 범위 검증용 (Generator/Loader 책임)
        public static readonly Dictionary<string, (long Min, long Max)> RangeValidation = new()
        {
            ["byte"] = (-128, 127),
            ["ubyte"] = (0, 255),
            ["short"] = (-32768, 32767),
            ["ushort"] = (0, 65535),
        };

        /// <summary>
        /// Excel 타입이 유효한 scalar인지 확인
        /// </summary>
        public static bool IsValidScalar(string excelType)
        {
            var baseType = excelType.TrimEnd('[', ']');
            return ExcelToProto.ContainsKey(baseType);
        }

        /// <summary>
        /// Reference 타입 정보
        /// </summary>
        public enum RefKind
        {
            None,
            Enum,
            Class
        }

        /// <summary>
        /// enum:/class: 타입 파싱 (Strict Mode)
        /// ref: 발견 시 예외 발생
        /// </summary>
        public static (RefKind Kind, bool IsCommon, string? TypeName) ParseRefType(string excelType)
        {
            var baseType = excelType.TrimEnd('[', ']');

            // ref: 금지 (Strict Mode) - 대소문자 무시
            if (baseType.StartsWith("ref:", StringComparison.OrdinalIgnoreCase))
            {
                throw new InvalidOperationException(
                    $"ref: is deprecated; use enum:{{X}} or class:{{Y}} instead. Found: '{excelType}'");
            }

            // enum:Common.{Name}
            if (baseType.StartsWith("enum:Common.", StringComparison.OrdinalIgnoreCase))
            {
                var typeName = baseType["enum:Common.".Length..];
                return (RefKind.Enum, true, typeName);
            }

            // enum:{Name}
            if (baseType.StartsWith("enum:", StringComparison.OrdinalIgnoreCase))
            {
                var typeName = baseType["enum:".Length..];
                return (RefKind.Enum, false, typeName);
            }

            // class:Common.{Name}
            if (baseType.StartsWith("class:Common.", StringComparison.OrdinalIgnoreCase))
            {
                var typeName = baseType["class:Common.".Length..];
                return (RefKind.Class, true, typeName);
            }

            // class:{Name}
            if (baseType.StartsWith("class:", StringComparison.OrdinalIgnoreCase))
            {
                var typeName = baseType["class:".Length..];
                return (RefKind.Class, false, typeName);
            }

            return (RefKind.None, false, null);
        }

        /// <summary>
        /// ref 타입인지 확인 (enum: 또는 class:)
        /// </summary>
        public static bool IsRefType(string excelType)
        {
            var (kind, _, _) = ParseRefType(excelType);
            return kind != RefKind.None;
        }

        /// <summary>
        /// 배열 타입인지 확인
        /// </summary>
        public static bool IsArray(string excelType) => excelType.EndsWith("[]");

        /// <summary>
        /// 배열 표기 제거
        /// </summary>
        public static string StripArray(string excelType) => excelType.TrimEnd('[', ']');

        /// <summary>
        /// Excel → Proto 타입 변환
        /// </summary>
        public static string ToProtoType(string excelType)
        {
            var isArray = IsArray(excelType);
            var baseType = StripArray(excelType);

            var (kind, _, typeName) = ParseRefType(baseType);
            if (kind != RefKind.None)
                return isArray ? $"repeated {typeName}" : typeName!;

            if (!ExcelToProto.TryGetValue(baseType, out var protoType))
                throw new ArgumentException($"Unknown Excel type: {excelType}");

            return isArray ? $"repeated {protoType}" : protoType;
        }

        /// <summary>
        /// Excel → C# 타입 변환
        /// </summary>
        public static string ToCSharpType(string excelType)
        {
            var isArray = IsArray(excelType);
            var baseType = StripArray(excelType);

            var (kind, _, typeName) = ParseRefType(baseType);
            if (kind != RefKind.None)
                return isArray ? $"List<{typeName}>" : typeName!;

            if (!ExcelToCSharp.TryGetValue(baseType, out var csType))
                throw new ArgumentException($"Unknown Excel type: {excelType}");

            return isArray ? $"List<{csType}>" : csType;
        }

        /// <summary>
        /// Excel → TypeScript 타입 변환
        /// </summary>
        public static string ToTypeScriptType(string excelType)
        {
            var isArray = IsArray(excelType);
            var baseType = StripArray(excelType);

            var (kind, _, typeName) = ParseRefType(baseType);
            if (kind != RefKind.None)
                return isArray ? $"{typeName}[]" : typeName!;

            if (!ExcelToTypeScript.TryGetValue(baseType, out var tsType))
                throw new ArgumentException($"Unknown Excel type: {excelType}");

            return isArray ? $"{tsType}[]" : tsType;
        }

        /// <summary>
        /// 타입 검증 (Row2 검증용, Strict Mode)
        /// </summary>
        /// <param name="excelType">검증할 타입 문자열</param>
        /// <param name="tableName">에러 메시지용 테이블 이름</param>
        /// <param name="columnIndex">에러 메시지용 컬럼 인덱스</param>
        /// <param name="columnName">에러 메시지용 컬럼 이름</param>
        public static (bool Valid, string? Error) ValidateType(
            string excelType, 
            string? tableName = null, 
            int? columnIndex = null, 
            string? columnName = null)
        {
            var baseType = StripArray(excelType);

            // ref: 금지 검사 (대소문자 무시)
            if (baseType.StartsWith("ref:", StringComparison.OrdinalIgnoreCase))
            {
                var context = BuildErrorContext(tableName, columnIndex, columnName, excelType);
                return (false, $"{context}ref: is deprecated; use enum:{{X}} or class:{{Y}}");
            }

            // enum:/class: 타입
            var (kind, _, typeName) = ParseRefType(baseType);
            if (kind != RefKind.None)
            {
                if (string.IsNullOrWhiteSpace(typeName))
                {
                    var context = BuildErrorContext(tableName, columnIndex, columnName, excelType);
                    return (false, $"{context}Invalid {kind.ToString().ToLower()} type: missing type name");
                }
                return (true, null);
            }

            // scalar 타입
            if (!ExcelToProto.ContainsKey(baseType))
            {
                var context = BuildErrorContext(tableName, columnIndex, columnName, excelType);
                return (false, $"{context}Unknown type: {baseType}");
            }

            return (true, null);
        }

        private static string BuildErrorContext(string? tableName, int? columnIndex, string? columnName, string typeStr)
        {
            var parts = new List<string>();
            if (!string.IsNullOrEmpty(tableName)) parts.Add($"table='{tableName}'");
            if (columnIndex.HasValue) parts.Add($"column={columnIndex.Value}");
            if (!string.IsNullOrEmpty(columnName)) parts.Add($"name='{columnName}'");
            parts.Add($"type='{typeStr}'");
            return parts.Count > 0 ? $"[{string.Join(", ", parts)}] " : "";
        }
    }
}

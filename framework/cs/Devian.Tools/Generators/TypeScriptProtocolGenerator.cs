// <auto-generated>
// Devian Build System - TypeScript Protocol Generator (v10)
// Generates: export namespace {ProtocolName}
// </auto-generated>

using System.Collections.Generic;
using System.Linq;
using System.Text;
using Devian.Tools.Models;

namespace Devian.Tools.Generators
{
    /// <summary>
    /// Protocol Spec → TypeScript 코드 생성 (v10)
    /// Namespace: export namespace {ProtocolName}
    /// 
    /// 중요: opcode/tag 할당은 BuildProtocol(Program.cs)에서 Registry를 통해 완료됨.
    /// 이 Generator는 검증만 수행.
    /// </summary>
    public static class TypeScriptProtocolGenerator
    {
        public static string Generate(ProtocolSpec spec, string protocolName)
        {
            // 검증 (할당은 BuildProtocol에서 이미 완료됨)
            ValidateOpcodes(spec);
            ValidateTags(spec);

            var sb = new StringBuilder();

            // Header
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("// DO NOT EDIT - Generated by Devian Build System v10");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();

            // Direction comment
            if (!string.IsNullOrEmpty(spec.Direction) && spec.Direction != "bidirectional")
            {
                sb.AppendLine($"// Direction: {spec.Direction}");
                sb.AppendLine();
            }

            // Namespace container
            sb.AppendLine($"export namespace {protocolName} {{");
            sb.AppendLine();

            // Message interfaces
            foreach (var message in spec.Messages)
            {
                GenerateMessageInterface(sb, message, "  ");
                sb.AppendLine();
            }

            // Opcodes object
            GenerateOpcodesObject(sb, spec, "  ");
            sb.AppendLine();

            // ICodec interface
            GenerateICodec(sb, "  ");
            sb.AppendLine();

            // ProtobufWire helper
            GenerateProtobufWireHelper(sb, "  ");
            sb.AppendLine();

            // CodecJson implementation
            GenerateCodecJson(sb, "  ");
            sb.AppendLine();

            // CodecProtobuf implementation
            GenerateCodecProtobuf(sb, spec, "  ");
            sb.AppendLine();

            // IHandler interface
            GenerateIHandler(sb, spec, "  ");
            sb.AppendLine();

            // IProxy interface
            GenerateIProxy(sb, spec, "  ");
            sb.AppendLine();

            // IPacketSender interface
            GenerateIPacketSender(sb, "  ");
            sb.AppendLine();

            // Proxy class
            GenerateProxy(sb, spec, "  ");
            sb.AppendLine();

            // Dispatcher class
            GenerateDispatcher(sb, spec, "  ");

            sb.AppendLine("}"); // end namespace

            return sb.ToString().TrimEnd();
        }

        #region Validation

        private static void ValidateOpcodes(ProtocolSpec spec)
        {
            var used = new HashSet<int>();

            foreach (var m in spec.Messages)
            {
                if (!m.Opcode.HasValue)
                    throw new System.Exception($"Opcode not assigned for {m.Name} (Registry 로직 오류)");
                if (m.Opcode.Value < 0)
                    throw new System.Exception($"Negative opcode not allowed: {m.Name}");
                if (used.Contains(m.Opcode.Value))
                    throw new System.Exception($"Duplicate opcode: {m.Opcode.Value}");
                used.Add(m.Opcode.Value);
            }
        }

        private static void ValidateTags(ProtocolSpec spec)
        {
            foreach (var message in spec.Messages)
            {
                var used = new HashSet<int>();

                foreach (var field in message.Fields)
                {
                    if (!field.Tag.HasValue)
                        throw new System.Exception($"Tag not assigned for {message.Name}.{field.Name} (Registry 로직 오류)");
                    var tag = field.Tag.Value;
                    if (tag < 1 || tag > 536870911)
                        throw new System.Exception($"Tag {tag} out of range for {message.Name}.{field.Name}");
                    if (tag >= 19000 && tag <= 19999)
                        throw new System.Exception($"Tag {tag} in reserved range for {message.Name}.{field.Name}");
                    if (used.Contains(tag))
                        throw new System.Exception($"Duplicate tag {tag} in {message.Name}");
                    used.Add(tag);
                }
            }
        }

        #endregion

        #region Message Interface

        private static void GenerateMessageInterface(StringBuilder sb, MessageSpec message, string indent)
        {
            sb.AppendLine($"{indent}/** {message.Name} message (opcode: {message.Opcode}) */");
            sb.AppendLine($"{indent}export interface {message.Name} {{");

            foreach (var field in message.Fields)
            {
                var tsType = ProtocolTypeMapper.ToTypeScript(field.Type);
                var optional = field.Optional ? "?" : "";
                var tag = field.Tag ?? 0;
                sb.AppendLine($"{indent}  /** Tag: {tag} */");
                sb.AppendLine($"{indent}  {field.Name}{optional}: {tsType};");
            }

            sb.AppendLine($"{indent}}}");
            sb.AppendLine();
            sb.AppendLine($"{indent}export const {message.Name}Opcode = {message.Opcode};");
        }

        #endregion

        #region Opcodes Object

        private static void GenerateOpcodesObject(StringBuilder sb, ProtocolSpec spec, string indent)
        {
            sb.AppendLine($"{indent}/** Opcode constants */");
            sb.AppendLine($"{indent}export const Opcodes = {{");

            var messages = spec.Messages.OrderBy(m => m.Opcode).ToList();
            for (int i = 0; i < messages.Count; i++)
            {
                var m = messages[i];
                var comma = i < messages.Count - 1 ? "," : "";
                sb.AppendLine($"{indent}  {m.Name}: {m.Opcode}{comma}");
            }

            sb.AppendLine($"{indent}}} as const;");
        }

        #endregion

        #region ICodec

        private static void GenerateICodec(StringBuilder sb, string indent)
        {
            sb.AppendLine($"{indent}/** Codec interface */");
            sb.AppendLine($"{indent}export interface ICodec {{");
            sb.AppendLine($"{indent}  encode<T>(message: T): Uint8Array;");
            sb.AppendLine($"{indent}  decode<T>(payload: Uint8Array): T;");
            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region ProtobufWire Helper

        private static void GenerateProtobufWireHelper(StringBuilder sb, string indent)
        {
            sb.AppendLine($"{indent}/** Protobuf wire format helper */");
            sb.AppendLine($"{indent}const ProtobufWire = {{");
            sb.AppendLine($"{indent}  WireVarint: 0,");
            sb.AppendLine($"{indent}  Wire64Bit: 1,");
            sb.AppendLine($"{indent}  WireLengthDelimited: 2,");
            sb.AppendLine($"{indent}  Wire32Bit: 5,");
            sb.AppendLine();

            // Writer class
            sb.AppendLine($"{indent}  Writer: class {{");
            sb.AppendLine($"{indent}    private buffer: number[] = [];");
            sb.AppendLine();
            sb.AppendLine($"{indent}    writeTag(fieldNumber: number, wireType: number): void {{");
            sb.AppendLine($"{indent}      this.writeVarint((fieldNumber << 3) | wireType);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    writeVarint(value: number): void {{");
            sb.AppendLine($"{indent}      if (!Number.isSafeInteger(value)) throw new Error('int64 value out of safe integer range');");
            sb.AppendLine($"{indent}      let v = value >>> 0; // Handle as unsigned");
            sb.AppendLine($"{indent}      if (value < 0) {{");
            sb.AppendLine($"{indent}        // For negative numbers, write as 10-byte varint");
            sb.AppendLine($"{indent}        for (let i = 0; i < 10; i++) {{");
            sb.AppendLine($"{indent}          this.buffer.push((value & 0x7F) | (i < 9 ? 0x80 : 0));");
            sb.AppendLine($"{indent}          value = Math.floor(value / 128);");
            sb.AppendLine($"{indent}        }}");
            sb.AppendLine($"{indent}        return;");
            sb.AppendLine($"{indent}      }}");
            sb.AppendLine($"{indent}      while (v >= 0x80) {{");
            sb.AppendLine($"{indent}        this.buffer.push((v & 0x7F) | 0x80);");
            sb.AppendLine($"{indent}        v >>>= 7;");
            sb.AppendLine($"{indent}      }}");
            sb.AppendLine($"{indent}      this.buffer.push(v);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    writeFixed32(value: number): void {{");
            sb.AppendLine($"{indent}      this.buffer.push(value & 0xFF);");
            sb.AppendLine($"{indent}      this.buffer.push((value >> 8) & 0xFF);");
            sb.AppendLine($"{indent}      this.buffer.push((value >> 16) & 0xFF);");
            sb.AppendLine($"{indent}      this.buffer.push((value >> 24) & 0xFF);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    writeFloat(value: number): void {{");
            sb.AppendLine($"{indent}      const buf = new ArrayBuffer(4);");
            sb.AppendLine($"{indent}      new DataView(buf).setFloat32(0, value, true);");
            sb.AppendLine($"{indent}      const bytes = new Uint8Array(buf);");
            sb.AppendLine($"{indent}      for (const b of bytes) this.buffer.push(b);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    writeDouble(value: number): void {{");
            sb.AppendLine($"{indent}      const buf = new ArrayBuffer(8);");
            sb.AppendLine($"{indent}      new DataView(buf).setFloat64(0, value, true);");
            sb.AppendLine($"{indent}      const bytes = new Uint8Array(buf);");
            sb.AppendLine($"{indent}      for (const b of bytes) this.buffer.push(b);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    writeString(value: string): void {{");
            sb.AppendLine($"{indent}      const bytes = new TextEncoder().encode(value);");
            sb.AppendLine($"{indent}      this.writeVarint(bytes.length);");
            sb.AppendLine($"{indent}      for (const b of bytes) this.buffer.push(b);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    writeBytes(value: Uint8Array): void {{");
            sb.AppendLine($"{indent}      this.writeVarint(value.length);");
            sb.AppendLine($"{indent}      for (const b of value) this.buffer.push(b);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    writeBool(value: boolean): void {{");
            sb.AppendLine($"{indent}      this.buffer.push(value ? 1 : 0);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    toArray(): Uint8Array {{");
            sb.AppendLine($"{indent}      return new Uint8Array(this.buffer);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}  }},");
            sb.AppendLine();

            // Reader class
            sb.AppendLine($"{indent}  Reader: class {{");
            sb.AppendLine($"{indent}    private pos = 0;");
            sb.AppendLine($"{indent}    constructor(private data: Uint8Array) {{}}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    get position(): number {{ return this.pos; }}");
            sb.AppendLine($"{indent}    get length(): number {{ return this.data.length; }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    readVarint(): number {{");
            sb.AppendLine($"{indent}      let result = 0;");
            sb.AppendLine($"{indent}      let shift = 0;");
            sb.AppendLine($"{indent}      while (true) {{");
            sb.AppendLine($"{indent}        if (this.pos >= this.data.length) throw new Error('Unexpected end of data');");
            sb.AppendLine($"{indent}        const b = this.data[this.pos++];");
            sb.AppendLine($"{indent}        result |= (b & 0x7F) << shift;");
            sb.AppendLine($"{indent}        if ((b & 0x80) === 0) break;");
            sb.AppendLine($"{indent}        shift += 7;");
            sb.AppendLine($"{indent}        if (shift > 35) throw new Error('Varint too long');");
            sb.AppendLine($"{indent}      }}");
            sb.AppendLine($"{indent}      if (!Number.isSafeInteger(result)) throw new Error('int64 value out of safe integer range');");
            sb.AppendLine($"{indent}      return result;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    readFixed32(): number {{");
            sb.AppendLine($"{indent}      const b0 = this.data[this.pos++];");
            sb.AppendLine($"{indent}      const b1 = this.data[this.pos++];");
            sb.AppendLine($"{indent}      const b2 = this.data[this.pos++];");
            sb.AppendLine($"{indent}      const b3 = this.data[this.pos++];");
            sb.AppendLine($"{indent}      return b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    readFloat(): number {{");
            sb.AppendLine($"{indent}      const buf = new ArrayBuffer(4);");
            sb.AppendLine($"{indent}      const bytes = new Uint8Array(buf);");
            sb.AppendLine($"{indent}      for (let i = 0; i < 4; i++) bytes[i] = this.data[this.pos++];");
            sb.AppendLine($"{indent}      return new DataView(buf).getFloat32(0, true);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    readDouble(): number {{");
            sb.AppendLine($"{indent}      const buf = new ArrayBuffer(8);");
            sb.AppendLine($"{indent}      const bytes = new Uint8Array(buf);");
            sb.AppendLine($"{indent}      for (let i = 0; i < 8; i++) bytes[i] = this.data[this.pos++];");
            sb.AppendLine($"{indent}      return new DataView(buf).getFloat64(0, true);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    readString(): string {{");
            sb.AppendLine($"{indent}      const length = this.readVarint();");
            sb.AppendLine($"{indent}      const bytes = this.data.slice(this.pos, this.pos + length);");
            sb.AppendLine($"{indent}      this.pos += length;");
            sb.AppendLine($"{indent}      return new TextDecoder().decode(bytes);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    readBytes(): Uint8Array {{");
            sb.AppendLine($"{indent}      const length = this.readVarint();");
            sb.AppendLine($"{indent}      const bytes = this.data.slice(this.pos, this.pos + length);");
            sb.AppendLine($"{indent}      this.pos += length;");
            sb.AppendLine($"{indent}      return bytes;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    readBool(): boolean {{");
            sb.AppendLine($"{indent}      return this.readVarint() !== 0;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}    skipField(wireType: number): void {{");
            sb.AppendLine($"{indent}      switch (wireType) {{");
            sb.AppendLine($"{indent}        case 0: this.readVarint(); break;");
            sb.AppendLine($"{indent}        case 1: this.pos += 8; break;");
            sb.AppendLine($"{indent}        case 2: this.pos += this.readVarint(); break;");
            sb.AppendLine($"{indent}        case 5: this.pos += 4; break;");
            sb.AppendLine($"{indent}        default: throw new Error(`Unknown wire type: ${{wireType}}`);");
            sb.AppendLine($"{indent}      }}");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}  }}");
            sb.AppendLine($"{indent}}};");
        }

        #endregion

        #region CodecJson

        private static void GenerateCodecJson(StringBuilder sb, string indent)
        {
            sb.AppendLine($"{indent}/** JSON codec implementation */");
            sb.AppendLine($"{indent}export class CodecJson implements ICodec {{");
            sb.AppendLine($"{indent}  private encoder = new TextEncoder();");
            sb.AppendLine($"{indent}  private decoder = new TextDecoder();");
            sb.AppendLine();
            sb.AppendLine($"{indent}  encode<T>(message: T): Uint8Array {{");
            sb.AppendLine($"{indent}    return this.encoder.encode(JSON.stringify(message));");
            sb.AppendLine($"{indent}  }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}  decode<T>(payload: Uint8Array): T {{");
            sb.AppendLine($"{indent}    return JSON.parse(this.decoder.decode(payload)) as T;");
            sb.AppendLine($"{indent}  }}");
            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region CodecProtobuf

        private static void GenerateCodecProtobuf(StringBuilder sb, ProtocolSpec spec, string indent)
        {
            sb.AppendLine($"{indent}/** Protobuf wire-format codec implementation */");
            sb.AppendLine($"{indent}export class CodecProtobuf implements ICodec {{");
            sb.AppendLine();

            // encode
            sb.AppendLine($"{indent}  encode<T>(message: T): Uint8Array {{");
            sb.AppendLine($"{indent}    const msg = message as Record<string, unknown>;");
            sb.AppendLine();

            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                sb.AppendLine($"{indent}    // Check if {msg.Name}");
                sb.AppendLine($"{indent}    if (this.is{msg.Name}(msg)) {{");
                sb.AppendLine($"{indent}      return this.encode{msg.Name}(msg as unknown as {msg.Name});");
                sb.AppendLine($"{indent}    }}");
            }

            sb.AppendLine();
            sb.AppendLine($"{indent}    throw new Error('Unknown message type');");
            sb.AppendLine($"{indent}  }}");
            sb.AppendLine();

            // decode (needs type hint)
            sb.AppendLine($"{indent}  decode<T>(payload: Uint8Array): T {{");
            sb.AppendLine($"{indent}    throw new Error('CodecProtobuf.decode requires type information. Use decodeAs<T>(opcode, payload) instead.');");
            sb.AppendLine($"{indent}  }}");
            sb.AppendLine();

            // decodeAs with opcode
            sb.AppendLine($"{indent}  decodeAs(opcode: number, payload: Uint8Array): unknown {{");
            sb.AppendLine($"{indent}    switch (opcode) {{");
            foreach (var msg in spec.Messages.OrderBy(m => m.Opcode))
            {
                sb.AppendLine($"{indent}      case Opcodes.{msg.Name}: return this.decode{msg.Name}(payload);");
            }
            sb.AppendLine($"{indent}      default: throw new Error(`Unknown opcode: ${{opcode}}`);");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}  }}");
            sb.AppendLine();

            // Type guards
            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                GenerateTypeGuard(sb, msg, indent + "  ");
            }
            sb.AppendLine();

            // Per-message encode methods
            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                GenerateTsEncodeMethod(sb, msg, indent + "  ");
                sb.AppendLine();
            }

            // Per-message decode methods
            foreach (var msg in spec.Messages.OrderBy(m => m.Name))
            {
                GenerateTsDecodeMethod(sb, msg, indent + "  ");
                sb.AppendLine();
            }

            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateTypeGuard(StringBuilder sb, MessageSpec msg, string indent)
        {
            // Simple type guard based on having expected fields
            var firstField = msg.Fields.FirstOrDefault();
            if (firstField != null)
            {
                sb.AppendLine($"{indent}private is{msg.Name}(obj: Record<string, unknown>): boolean {{");
                sb.AppendLine($"{indent}  return '{firstField.Name}' in obj;");
                sb.AppendLine($"{indent}}}");
            }
            else
            {
                sb.AppendLine($"{indent}private is{msg.Name}(_obj: Record<string, unknown>): boolean {{");
                sb.AppendLine($"{indent}  return true; // Empty message");
                sb.AppendLine($"{indent}}}");
            }
        }

        private static void GenerateTsEncodeMethod(StringBuilder sb, MessageSpec msg, string indent)
        {
            sb.AppendLine($"{indent}private encode{msg.Name}(m: {msg.Name}): Uint8Array {{");
            sb.AppendLine($"{indent}  const w = new ProtobufWire.Writer();");

            foreach (var field in msg.Fields)
            {
                var tag = field.Tag!.Value;
                GenerateTsFieldEncode(sb, field, tag, indent + "  ");
            }

            sb.AppendLine($"{indent}  return w.toArray();");
            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateTsFieldEncode(StringBuilder sb, FieldSpec field, int tag, string indent)
        {
            var name = field.Name;
            var type = field.Type;

            // Handle optional
            if (field.Optional)
            {
                sb.AppendLine($"{indent}if (m.{name} != null) {{");
                GenerateTsFieldEncodeInner(sb, field, tag, indent + "  ", true);
                sb.AppendLine($"{indent}}}");
            }
            else
            {
                GenerateTsFieldEncodeInner(sb, field, tag, indent, false);
            }
        }

        private static void GenerateTsFieldEncodeInner(StringBuilder sb, FieldSpec field, int tag, string indent, bool isOptional)
        {
            var name = field.Name;
            var type = field.Type;
            var accessor = $"m.{name}";
            var suffix = isOptional ? "!" : "";

            // Arrays
            if (type.EndsWith("[]"))
            {
                var elemType = type[..^2];
                var isPrimitive = IsTsPrimitiveType(elemType);

                if (isPrimitive)
                {
                    // Packed encoding
                    sb.AppendLine($"{indent}if ({accessor}{suffix}.length > 0) {{");
                    sb.AppendLine($"{indent}  w.writeTag({tag}, ProtobufWire.WireLengthDelimited);");
                    sb.AppendLine($"{indent}  const packed = new ProtobufWire.Writer();");
                    sb.AppendLine($"{indent}  for (const item of {accessor}{suffix}) {{");
                    GenerateTsPrimitiveEncode(sb, elemType, "item", indent + "    ", "packed");
                    sb.AppendLine($"{indent}  }}");
                    sb.AppendLine($"{indent}  w.writeBytes(packed.toArray());");
                    sb.AppendLine($"{indent}}}");
                }
                else
                {
                    // String/bytes arrays
                    sb.AppendLine($"{indent}for (const item of {accessor}{suffix}) {{");
                    sb.AppendLine($"{indent}  w.writeTag({tag}, ProtobufWire.WireLengthDelimited);");
                    if (elemType == "string")
                        sb.AppendLine($"{indent}  w.writeString(item ?? '');");
                    else if (elemType == "bytes")
                        sb.AppendLine($"{indent}  w.writeBytes(item ?? new Uint8Array());");
                    sb.AppendLine($"{indent}}}");
                }
                return;
            }

            // Map<string, T>
            if (type.StartsWith("map<"))
            {
                sb.AppendLine($"{indent}for (const [key, value] of Object.entries({accessor}{suffix})) {{");
                sb.AppendLine($"{indent}  w.writeTag({tag}, ProtobufWire.WireLengthDelimited);");
                sb.AppendLine($"{indent}  const entry = new ProtobufWire.Writer();");
                sb.AppendLine($"{indent}  entry.writeTag(1, ProtobufWire.WireLengthDelimited);");
                sb.AppendLine($"{indent}  entry.writeString(key);");
                sb.AppendLine($"{indent}  entry.writeTag(2, ProtobufWire.WireLengthDelimited);");
                sb.AppendLine($"{indent}  entry.writeString(value);");
                sb.AppendLine($"{indent}  w.writeBytes(entry.toArray());");
                sb.AppendLine($"{indent}}}");
                return;
            }

            // Scalar types
            GenerateTsScalarEncode(sb, type, tag, accessor + suffix, indent);
        }

        private static void GenerateTsScalarEncode(StringBuilder sb, string type, int tag, string accessor, string indent)
        {
            switch (type)
            {
                case "bool":
                    sb.AppendLine($"{indent}w.writeTag({tag}, ProtobufWire.WireVarint);");
                    sb.AppendLine($"{indent}w.writeBool({accessor});");
                    break;
                case "int32":
                case "uint32":
                case "int64":
                case "uint64":
                    sb.AppendLine($"{indent}w.writeTag({tag}, ProtobufWire.WireVarint);");
                    sb.AppendLine($"{indent}w.writeVarint({accessor});");
                    break;
                case "float":
                    sb.AppendLine($"{indent}w.writeTag({tag}, ProtobufWire.Wire32Bit);");
                    sb.AppendLine($"{indent}w.writeFloat({accessor});");
                    break;
                case "double":
                    sb.AppendLine($"{indent}w.writeTag({tag}, ProtobufWire.Wire64Bit);");
                    sb.AppendLine($"{indent}w.writeDouble({accessor});");
                    break;
                case "string":
                    sb.AppendLine($"{indent}if ({accessor}) {{");
                    sb.AppendLine($"{indent}  w.writeTag({tag}, ProtobufWire.WireLengthDelimited);");
                    sb.AppendLine($"{indent}  w.writeString({accessor});");
                    sb.AppendLine($"{indent}}}");
                    break;
                case "bytes":
                    sb.AppendLine($"{indent}if ({accessor} && {accessor}.length > 0) {{");
                    sb.AppendLine($"{indent}  w.writeTag({tag}, ProtobufWire.WireLengthDelimited);");
                    sb.AppendLine($"{indent}  w.writeBytes({accessor});");
                    sb.AppendLine($"{indent}}}");
                    break;
            }
        }

        private static void GenerateTsPrimitiveEncode(StringBuilder sb, string type, string accessor, string indent, string writerVar)
        {
            switch (type)
            {
                case "bool":
                    sb.AppendLine($"{indent}{writerVar}.writeBool({accessor});");
                    break;
                case "int32":
                case "uint32":
                case "int64":
                case "uint64":
                    sb.AppendLine($"{indent}{writerVar}.writeVarint({accessor});");
                    break;
                case "float":
                    sb.AppendLine($"{indent}{writerVar}.writeFloat({accessor});");
                    break;
                case "double":
                    sb.AppendLine($"{indent}{writerVar}.writeDouble({accessor});");
                    break;
            }
        }

        private static void GenerateTsDecodeMethod(StringBuilder sb, MessageSpec msg, string indent)
        {
            sb.AppendLine($"{indent}private decode{msg.Name}(payload: Uint8Array): {msg.Name} {{");
            sb.AppendLine($"{indent}  const r = new ProtobufWire.Reader(payload);");
            sb.AppendLine($"{indent}  const m: Partial<{msg.Name}> = {{}};");

            // Init arrays and maps
            foreach (var field in msg.Fields)
            {
                var name = field.Name;
                if (field.Type.EndsWith("[]"))
                {
                    var elemType = field.Type[..^2];
                    var tsElemType = ProtocolTypeMapper.ToTypeScript(elemType);
                    sb.AppendLine($"{indent}  const _{name}: {tsElemType}[] = [];");
                }
                else if (field.Type.StartsWith("map<"))
                {
                    sb.AppendLine($"{indent}  const _{name}: Record<string, string> = {{}};");
                }
            }

            sb.AppendLine();
            sb.AppendLine($"{indent}  while (r.position < r.length) {{");
            sb.AppendLine($"{indent}    const tagBits = r.readVarint();");
            sb.AppendLine($"{indent}    const fieldNumber = tagBits >>> 3;");
            sb.AppendLine($"{indent}    const wireType = tagBits & 0x7;");
            sb.AppendLine();
            sb.AppendLine($"{indent}    switch (fieldNumber) {{");

            foreach (var field in msg.Fields)
            {
                var tag = field.Tag!.Value;
                var name = field.Name;
                sb.AppendLine($"{indent}      case {tag}:");
                GenerateTsFieldDecode(sb, field, indent + "        ");
                sb.AppendLine($"{indent}        break;");
            }

            sb.AppendLine($"{indent}      default:");
            sb.AppendLine($"{indent}        r.skipField(wireType);");
            sb.AppendLine($"{indent}        break;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}  }}");
            sb.AppendLine();

            // Assign arrays and maps
            foreach (var field in msg.Fields)
            {
                var name = field.Name;
                if (field.Type.EndsWith("[]"))
                {
                    sb.AppendLine($"{indent}  m.{name} = _{name};");
                }
                else if (field.Type.StartsWith("map<"))
                {
                    sb.AppendLine($"{indent}  m.{name} = _{name};");
                }
            }

            // Default values for missing required fields
            foreach (var field in msg.Fields.Where(f => !f.Optional))
            {
                var name = field.Name;
                var type = field.Type;
                if (!type.EndsWith("[]") && !type.StartsWith("map<"))
                {
                    var defaultVal = GetTsDefaultValue(type);
                    sb.AppendLine($"{indent}  if (m.{name} === undefined) m.{name} = {defaultVal};");
                }
            }

            sb.AppendLine();
            sb.AppendLine($"{indent}  return m as {msg.Name};");
            sb.AppendLine($"{indent}}}");
        }

        private static void GenerateTsFieldDecode(StringBuilder sb, FieldSpec field, string indent)
        {
            var name = field.Name;
            var type = field.Type;

            // Arrays
            if (type.EndsWith("[]"))
            {
                var elemType = type[..^2];
                var isPrimitive = IsTsPrimitiveType(elemType);

                if (isPrimitive)
                {
                    // Packed encoding
                    sb.AppendLine($"{indent}{{");
                    sb.AppendLine($"{indent}  const packedBytes = r.readBytes();");
                    sb.AppendLine($"{indent}  const packed = new ProtobufWire.Reader(packedBytes);");
                    sb.AppendLine($"{indent}  while (packed.position < packed.length) {{");
                    GenerateTsPrimitiveDecode(sb, elemType, $"_{name}", indent + "    ");
                    sb.AppendLine($"{indent}  }}");
                    sb.AppendLine($"{indent}}}");
                }
                else
                {
                    // String/bytes
                    if (elemType == "string")
                        sb.AppendLine($"{indent}_{name}.push(r.readString());");
                    else if (elemType == "bytes")
                        sb.AppendLine($"{indent}_{name}.push(r.readBytes());");
                }
                return;
            }

            // Map<string, T>
            if (type.StartsWith("map<"))
            {
                sb.AppendLine($"{indent}{{");
                sb.AppendLine($"{indent}  const entryBytes = r.readBytes();");
                sb.AppendLine($"{indent}  const entry = new ProtobufWire.Reader(entryBytes);");
                sb.AppendLine($"{indent}  let key = '';");
                sb.AppendLine($"{indent}  let value = '';");
                sb.AppendLine($"{indent}  while (entry.position < entry.length) {{");
                sb.AppendLine($"{indent}    const entryTag = entry.readVarint();");
                sb.AppendLine($"{indent}    const entryField = entryTag >>> 3;");
                sb.AppendLine($"{indent}    if (entryField === 1) key = entry.readString();");
                sb.AppendLine($"{indent}    else if (entryField === 2) value = entry.readString();");
                sb.AppendLine($"{indent}    else entry.skipField(entryTag & 0x7);");
                sb.AppendLine($"{indent}  }}");
                sb.AppendLine($"{indent}  _{name}[key] = value;");
                sb.AppendLine($"{indent}}}");
                return;
            }

            // Scalar types
            GenerateTsScalarDecode(sb, type, name, indent);
        }

        private static void GenerateTsScalarDecode(StringBuilder sb, string type, string name, string indent)
        {
            switch (type)
            {
                case "bool":
                    sb.AppendLine($"{indent}m.{name} = r.readBool();");
                    break;
                case "int32":
                case "uint32":
                case "int64":
                case "uint64":
                    sb.AppendLine($"{indent}m.{name} = r.readVarint();");
                    break;
                case "float":
                    sb.AppendLine($"{indent}m.{name} = r.readFloat();");
                    break;
                case "double":
                    sb.AppendLine($"{indent}m.{name} = r.readDouble();");
                    break;
                case "string":
                    sb.AppendLine($"{indent}m.{name} = r.readString();");
                    break;
                case "bytes":
                    sb.AppendLine($"{indent}m.{name} = r.readBytes();");
                    break;
            }
        }

        private static void GenerateTsPrimitiveDecode(StringBuilder sb, string type, string listVar, string indent)
        {
            switch (type)
            {
                case "bool":
                    sb.AppendLine($"{indent}{listVar}.push(packed.readBool());");
                    break;
                case "int32":
                case "uint32":
                case "int64":
                case "uint64":
                    sb.AppendLine($"{indent}{listVar}.push(packed.readVarint());");
                    break;
                case "float":
                    sb.AppendLine($"{indent}{listVar}.push(packed.readFloat());");
                    break;
                case "double":
                    sb.AppendLine($"{indent}{listVar}.push(packed.readDouble());");
                    break;
            }
        }

        private static bool IsTsPrimitiveType(string type)
        {
            return type switch
            {
                "bool" or "int32" or "uint32" or "int64" or "uint64" or "float" or "double" => true,
                _ => false
            };
        }

        private static string GetTsDefaultValue(string type)
        {
            return type switch
            {
                "bool" => "false",
                "int32" or "uint32" or "int64" or "uint64" or "float" or "double" => "0",
                "string" => "''",
                "bytes" => "new Uint8Array()",
                _ => "undefined as any"
            };
        }

        #endregion

        #region IHandler

        private static void GenerateIHandler(StringBuilder sb, ProtocolSpec spec, string indent)
        {
            sb.AppendLine($"{indent}/** Handler interface */");
            sb.AppendLine($"{indent}export interface IHandler {{");

            foreach (var message in spec.Messages.OrderBy(m => m.Name))
            {
                sb.AppendLine($"{indent}  on{message.Name}(msg: {message.Name}, opcode: number, sessionId: number): Promise<void>;");
            }

            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region IProxy

        private static void GenerateIProxy(StringBuilder sb, ProtocolSpec spec, string indent)
        {
            sb.AppendLine($"{indent}/** Proxy interface */");
            sb.AppendLine($"{indent}export interface IProxy {{");

            foreach (var message in spec.Messages.OrderBy(m => m.Name))
            {
                sb.AppendLine($"{indent}  send{message.Name}(msg: {message.Name}, sessionId?: number): Promise<void>;");
            }

            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region IPacketSender

        private static void GenerateIPacketSender(StringBuilder sb, string indent)
        {
            sb.AppendLine($"{indent}/** Packet sender interface */");
            sb.AppendLine($"{indent}export interface IPacketSender {{");
            sb.AppendLine($"{indent}  send(opcode: number, payload: Uint8Array, sessionId: number): Promise<void>;");
            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region Proxy

        private static void GenerateProxy(StringBuilder sb, ProtocolSpec spec, string indent)
        {
            sb.AppendLine($"{indent}/** Proxy implementation */");
            sb.AppendLine($"{indent}export class Proxy implements IProxy {{");
            sb.AppendLine($"{indent}  private codec: ICodec;");
            sb.AppendLine();
            sb.AppendLine($"{indent}  constructor(");
            sb.AppendLine($"{indent}    private sender: IPacketSender,");
            sb.AppendLine($"{indent}    codec?: ICodec");
            sb.AppendLine($"{indent}  ) {{");
            sb.AppendLine($"{indent}    this.codec = codec ?? new CodecProtobuf();");
            sb.AppendLine($"{indent}  }}");
            sb.AppendLine();

            foreach (var message in spec.Messages.OrderBy(m => m.Name))
            {
                sb.AppendLine($"{indent}  async send{message.Name}(msg: {message.Name}, sessionId: number = 0): Promise<void> {{");
                sb.AppendLine($"{indent}    const payload = this.codec.encode(msg);");
                sb.AppendLine($"{indent}    await this.sender.send(Opcodes.{message.Name}, payload, sessionId);");
                sb.AppendLine($"{indent}  }}");
                sb.AppendLine();
            }

            sb.AppendLine($"{indent}}}");
        }

        #endregion

        #region Dispatcher

        private static void GenerateDispatcher(StringBuilder sb, ProtocolSpec spec, string indent)
        {
            sb.AppendLine($"{indent}/** Dispatcher implementation */");
            sb.AppendLine($"{indent}export class Dispatcher {{");
            sb.AppendLine($"{indent}  private codec: ICodec;");
            sb.AppendLine();
            sb.AppendLine($"{indent}  constructor(");
            sb.AppendLine($"{indent}    private handler: IHandler,");
            sb.AppendLine($"{indent}    codec?: ICodec");
            sb.AppendLine($"{indent}  ) {{");
            sb.AppendLine($"{indent}    this.codec = codec ?? new CodecProtobuf();");
            sb.AppendLine($"{indent}  }}");
            sb.AppendLine();
            sb.AppendLine($"{indent}  async dispatch(opcode: number, payload: Uint8Array, sessionId: number = 0): Promise<void> {{");
            sb.AppendLine($"{indent}    switch (opcode) {{");

            foreach (var message in spec.Messages.OrderBy(m => m.Opcode))
            {
                sb.AppendLine($"{indent}      case Opcodes.{message.Name}:");
                sb.AppendLine($"{indent}        await this.handler.on{message.Name}(this.codec.decodeAs(opcode, payload) as {message.Name}, opcode, sessionId);");
                sb.AppendLine($"{indent}        break;");
            }

            sb.AppendLine($"{indent}      default:");
            sb.AppendLine($"{indent}        // Unknown opcode - ignore or log");
            sb.AppendLine($"{indent}        break;");
            sb.AppendLine($"{indent}    }}");
            sb.AppendLine($"{indent}  }}");
            sb.AppendLine($"{indent}}}");
        }

        #endregion
    }
}

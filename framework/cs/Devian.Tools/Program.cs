// <auto-generated>
// Devian Build System - CLI Entry Point (v10)
// </auto-generated>

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using Devian.Tools.Generators;
using Devian.Tools.Models;

namespace Devian.Tools
{
    /// <summary>
    /// Devian Build Tools CLI (v10)
    /// 
    /// 빌드 파이프라인 (63-build-runner):
    /// 1. Phase 1: Generate to staging (tempDir)
    /// 2. Phase 2: UPM scaffold to staging
    /// 3. Phase 3: Clean & Copy to targetDirs
    /// </summary>
    public class Program
    {
        private static readonly JsonSerializerOptions _jsonOptions = new()
        {
            WriteIndented = true,
            PropertyNamingPolicy = null,
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
        };

        public static async Task<int> Main(string[] args)
        {
            if (args.Length == 0)
            {
                PrintUsage();
                return 1;
            }

            var command = args[0].ToLowerInvariant();

            try
            {
                return command switch
                {
                    "build" => await BuildCommand(args[1..]),
                    "validate" => ValidateCommand(args[1..]),
                    "help" => Help(),
                    _ => UnknownCommand(command)
                };
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Error: {ex.Message}");
                if (ex.InnerException != null)
                {
                    Console.Error.WriteLine($"  Caused by: {ex.InnerException.Message}");
                }
                return 1;
            }
        }

        private static void PrintUsage()
        {
            Console.WriteLine("Devian Build Tools (v10)");
            Console.WriteLine();
            Console.WriteLine("Usage: devian-tools <command> [options]");
            Console.WriteLine();
            Console.WriteLine("Commands:");
            Console.WriteLine("  build     Build from build.json");
            Console.WriteLine("  validate  Validate build configuration");
            Console.WriteLine("  help      Show this help");
        }

        private static int Help()
        {
            PrintUsage();
            return 0;
        }

        private static int UnknownCommand(string command)
        {
            Console.Error.WriteLine($"Unknown command: {command}");
            PrintUsage();
            return 1;
        }

        #region Build Command

        private static async Task<int> BuildCommand(string[] args)
        {
            var configPath = Path.GetFullPath(args.Length > 0 ? args[0] : "input/build.json");

            if (!File.Exists(configPath))
            {
                Console.Error.WriteLine($"Config file not found: {configPath}");
                return 1;
            }

            // configDir = directory containing build.json
            // All relative paths in build.json are relative to configDir
            var configDir = Path.GetDirectoryName(configPath);
            if (string.IsNullOrEmpty(configDir))
            {
                Console.Error.WriteLine("Failed to determine config directory from config path");
                return 1;
            }

            var json = await File.ReadAllTextAsync(configPath);
            var config = JsonSerializer.Deserialize<BuildConfig>(json);

            if (config == null)
            {
                Console.Error.WriteLine("Failed to parse build.json");
                return 1;
            }

            if (config.Version != "10")
            {
                Console.Error.WriteLine($"Build failed: expected version '10', got '{config.Version}'");
                return 1;
            }

            // Set configDir for path resolution
            config.ConfigDir = configDir;

            // Normalize tempDir to absolute path based on configDir
            if (!Path.IsPathRooted(config.TempDir))
            {
                config.TempDir = Path.Combine(configDir, config.TempDir);
            }

            Console.WriteLine($"Devian Build - Version {config.Version}");
            Console.WriteLine($"ConfigDir: {config.ConfigDir}");
            Console.WriteLine($"TempDir: {config.TempDir}");
            Console.WriteLine();

            // Phase 1: Generate to staging
            Console.WriteLine("=== Phase 1: Generate to staging ===");

            if (config.Domains != null)
            {
                foreach (var (name, domain) in config.Domains)
                {
                    Console.WriteLine($"  Building domain: {name}");
                    await BuildDomain(config, name, domain);
                }
            }

            if (config.Protocols != null)
            {
                foreach (var protocolGroup in config.Protocols)
                {
                    Console.WriteLine($"  Building protocol group: {protocolGroup.Group}");
                    await BuildProtocolGroup(config, protocolGroup);
                }
            }

            // Phase 2: UPM scaffold (if applicable)
            Console.WriteLine();
            Console.WriteLine("=== Phase 2: UPM scaffold ===");

            if (config.Domains != null)
            {
                foreach (var (name, domain) in config.Domains)
                {
                    if (domain.UpmTargetDirs.Count > 0)
                    {
                        Console.WriteLine($"  UPM scaffold for: {name}");
                        GenerateUpmScaffold(config, name, domain);
                    }
                }
            }

            // Phase 3: Clean & Copy to targets
            Console.WriteLine();
            Console.WriteLine("=== Phase 3: Clean & Copy to targets ===");

            if (config.Domains != null)
            {
                foreach (var (name, domain) in config.Domains)
                {
                    Console.WriteLine($"  Copying domain: {name}");
                    CopyDomainToTargets(config, name, domain);
                }
            }

            if (config.Protocols != null)
            {
                foreach (var protocolGroup in config.Protocols)
                {
                    Console.WriteLine($"  Copying protocol group: {protocolGroup.Group}");
                    CopyProtocolGroupToTargets(config, protocolGroup);
                }
            }

            Console.WriteLine();
            Console.WriteLine("Build completed.");
            return 0;
        }

        #endregion

        #region Path Resolution

        /// <summary>
        /// Resolve relative path based on configDir
        /// </summary>
        private static string ResolvePath(BuildConfig config, string relativePath)
        {
            if (string.IsNullOrEmpty(relativePath)) return relativePath;
            if (Path.IsPathRooted(relativePath)) return relativePath;
            return Path.GetFullPath(Path.Combine(config.ConfigDir, relativePath));
        }

        #endregion

        #region Domain Build

        private static async Task BuildDomain(BuildConfig config, string name, DomainConfig domain)
        {
            var stagingCs = Path.Combine(config.TempDir, name, "cs", "generated");
            var stagingTs = Path.Combine(config.TempDir, name, "ts", "generated");
            var stagingData = Path.Combine(config.TempDir, name, "data", "json");

            Directory.CreateDirectory(stagingCs);
            Directory.CreateDirectory(stagingTs);
            Directory.CreateDirectory(stagingData);

            // Resolve paths relative to configDir
            var contractsDir = ResolvePath(config, domain.ContractsDir);
            var tablesDir = ResolvePath(config, domain.TablesDir);

            // Build contracts
            if (!string.IsNullOrEmpty(contractsDir) && Directory.Exists(contractsDir))
            {
                var files = CollectFiles(contractsDir, domain.ContractFiles);
                foreach (var file in files)
                {
                    Console.WriteLine($"    Contract: {Path.GetFileName(file)}");
                    await BuildContract(file, name, stagingCs, stagingTs);
                }
            }

            // Build tables
            if (!string.IsNullOrEmpty(tablesDir) && Directory.Exists(tablesDir))
            {
                var files = CollectFiles(tablesDir, domain.TableFiles);
                foreach (var file in files)
                {
                    Console.WriteLine($"    Table: {Path.GetFileName(file)}");
                    await BuildTable(file, name, stagingCs, stagingTs, stagingData);
                }
            }
        }

        private static async Task BuildContract(string file, string domain, string stagingCs, string stagingTs)
        {
            var json = await File.ReadAllTextAsync(file);
            var spec = JsonSerializer.Deserialize<ContractSpec>(json);
            if (spec == null) return;

            var baseName = Path.GetFileNameWithoutExtension(file);

            // C#
            var csCode = CSharpContractGenerator.Generate(spec, domain);
            await File.WriteAllTextAsync(Path.Combine(stagingCs, $"{baseName}.g.cs"), csCode);

            // TypeScript
            var tsCode = TypeScriptContractGenerator.Generate(spec, domain);
            await File.WriteAllTextAsync(Path.Combine(stagingTs, $"{baseName}.g.ts"), tsCode);
        }

        private static async Task BuildTable(string file, string domain, string stagingCs, string stagingTs, string stagingData)
        {
            var tables = TableSchemaParser.ParseXlsx(file, domain);

            foreach (var table in tables)
            {
                // C# Entity
                var entityCode = CSharpTableGenerator.GenerateEntity(table);
                await File.WriteAllTextAsync(Path.Combine(stagingCs, $"{table.TableName}.g.cs"), entityCode);

                // C# Container (if has primary key)
                if (table.PrimaryKeyIndex >= 0)
                {
                    var containerCode = CSharpTableGenerator.GenerateContainer(table);
                    await File.WriteAllTextAsync(Path.Combine(stagingCs, $"TB_{table.TableName}.g.cs"), containerCode);
                }

                // TypeScript Entity
                var tsCode = TypeScriptTableGenerator.GenerateEntity(table);
                await File.WriteAllTextAsync(Path.Combine(stagingTs, $"{table.TableName}.g.ts"), tsCode);

                // NDJSON Data
                var ndjson = TableDataGenerator.Generate(table);
                await File.WriteAllTextAsync(Path.Combine(stagingData, $"{table.TableName.ToLowerInvariant()}.ndjson"), ndjson);
            }
        }

        #endregion

        #region Protocol Build

        private static async Task BuildProtocolGroup(BuildConfig config, ProtocolGroupConfig groupConfig)
        {
            var groupName = groupConfig.Group;
            var protocolDir = ResolvePath(config, groupConfig.ProtocolDir);
            var csProjectName = $"Devian.Protocol.{groupName}";
            
            // Staging paths
            var stagingCs = Path.Combine(config.TempDir, csProjectName);
            var stagingTs = Path.Combine(config.TempDir, groupName);

            Directory.CreateDirectory(stagingCs);
            Directory.CreateDirectory(stagingTs);

            // Collect protocol names for index.ts
            var protocolNames = new List<string>();

            // Process each protocol file
            foreach (var protocolFileName in groupConfig.ProtocolFiles)
            {
                var protocolPath = Path.Combine(protocolDir, protocolFileName);
                var protocolName = Path.GetFileNameWithoutExtension(protocolFileName);

                if (!File.Exists(protocolPath))
                {
                    Console.Error.WriteLine($"    Protocol file not found: {protocolPath}");
                    continue;
                }

                Console.WriteLine($"    Protocol: {protocolName}");
                protocolNames.Add(protocolName);

                var json = await File.ReadAllTextAsync(protocolPath);
                var spec = JsonSerializer.Deserialize<ProtocolSpec>(json);
                if (spec == null) continue;

                // === Registry 로직 (SSOT) ===
                var generatedDir = Path.Combine(protocolDir, "generated");
                Directory.CreateDirectory(generatedDir);
                var opcodesPath = Path.Combine(generatedDir, $"{protocolName}.opcodes.json");
                var tagsPath = Path.Combine(generatedDir, $"{protocolName}.tags.json");

                // 1. Opcode Registry 로드/적용/저장
                var opcodeRegistry = await LoadRegistry(opcodesPath);
                ApplyOpcodes(spec, opcodeRegistry);
                await SaveRegistry(opcodesPath, opcodeRegistry);

                // 2. Tag Registry 로드/적용/저장
                var tagRegistry = await LoadRegistry(tagsPath);
                ApplyTags(spec, tagRegistry);
                await SaveRegistry(tagsPath, tagRegistry);

                // C#
                var csCode = CSharpProtocolGenerator.Generate(spec, protocolName);
                await File.WriteAllTextAsync(Path.Combine(stagingCs, $"{protocolName}.g.cs"), csCode);

                // TypeScript
                var tsCode = TypeScriptProtocolGenerator.Generate(spec, protocolName);
                await File.WriteAllTextAsync(Path.Combine(stagingTs, $"{protocolName}.g.ts"), tsCode);
            }

            // Generate .csproj for C#
            var csprojContent = GenerateCsproj(groupName);
            await File.WriteAllTextAsync(Path.Combine(stagingCs, $"{csProjectName}.csproj"), csprojContent);

            // Generate index.ts for TypeScript
            var indexTsContent = GenerateIndexTs(protocolNames);
            await File.WriteAllTextAsync(Path.Combine(stagingTs, "index.ts"), indexTsContent);
        }

        private static string GenerateCsproj(string groupName)
        {
            return $@"<Project Sdk=""Microsoft.NET.Sdk"">
  <PropertyGroup>
    <TargetFramework>netstandard2.1</TargetFramework>
    <LangVersion>9.0</LangVersion>
    <Nullable>enable</Nullable>
    <RootNamespace>Devian.Protocol.{groupName}</RootNamespace>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include=""..\Devian.Core\Devian.Core.csproj"" />
    <ProjectReference Include=""..\Devian.Network\Devian.Network.csproj"" />
  </ItemGroup>
</Project>
";
        }

        private static string GenerateIndexTs(List<string> protocolNames)
        {
            return string.Join("\n", protocolNames.Select(name => $"export * from './{name}.g';")) + "\n";
        }

        #endregion

        #region Registry Logic

        /// <summary>
        /// Registry 파일 로드 (없으면 빈 dict)
        /// </summary>
        private static async Task<Dictionary<string, int>> LoadRegistry(string path)
        {
            if (!File.Exists(path))
            {
                return new Dictionary<string, int>();
            }

            var json = await File.ReadAllTextAsync(path);
            return JsonSerializer.Deserialize<Dictionary<string, int>>(json) 
                   ?? new Dictionary<string, int>();
        }

        /// <summary>
        /// Registry 파일 저장 (키 정렬, 결정적)
        /// </summary>
        private static async Task SaveRegistry(string path, Dictionary<string, int> registry)
        {
            // 키 정렬 (Ordinal)
            var sorted = registry
                .OrderBy(kv => kv.Key, StringComparer.Ordinal)
                .ToDictionary(kv => kv.Key, kv => kv.Value);

            var json = JsonSerializer.Serialize(sorted, _jsonOptions);
            await File.WriteAllTextAsync(path, json);
        }

        /// <summary>
        /// Opcode 적용 로직
        /// 1. spec에 opcode가 있으면 최우선 + registry 반영
        /// 2. registry에 있으면 registry 값 사용
        /// 3. 둘 다 없으면 신규 할당 (max + 1, 최소 1000)
        /// </summary>
        private static void ApplyOpcodes(ProtocolSpec spec, Dictionary<string, int> registry)
        {
            var used = new HashSet<int>();
            const int minOpcode = 1000;

            // Phase 1: 이미 사용 중인 opcode 수집 + spec에 명시된 값 반영
            foreach (var m in spec.Messages)
            {
                if (m.Opcode.HasValue)
                {
                    // spec에 명시된 값 최우선
                    ValidateOpcode(m.Opcode.Value, m.Name);
                    if (used.Contains(m.Opcode.Value))
                        throw new Exception($"Duplicate opcode {m.Opcode.Value} for {m.Name}");
                    used.Add(m.Opcode.Value);
                    registry[m.Name] = m.Opcode.Value;
                }
                else if (registry.TryGetValue(m.Name, out var regOpcode))
                {
                    // registry에 있으면 사용
                    ValidateOpcode(regOpcode, m.Name);
                    if (used.Contains(regOpcode))
                        throw new Exception($"Duplicate opcode {regOpcode} for {m.Name} (from registry)");
                    m.Opcode = regOpcode;
                    used.Add(regOpcode);
                }
            }

            // Phase 2: 미지정 메시지에 신규 opcode 할당
            // 결정적: 이름순 정렬 후 max+1
            var unassigned = spec.Messages
                .Where(m => !m.Opcode.HasValue)
                .OrderBy(m => m.Name, StringComparer.Ordinal)
                .ToList();

            int next = Math.Max(minOpcode, (used.Count > 0 ? used.Max() : minOpcode - 1) + 1);

            foreach (var m in unassigned)
            {
                while (used.Contains(next)) next++;
                m.Opcode = next;
                registry[m.Name] = next;
                used.Add(next);
                next++;
            }

            // 검증: 모든 message에 opcode가 할당됨
            foreach (var m in spec.Messages)
            {
                if (!m.Opcode.HasValue)
                    throw new Exception($"Opcode not assigned for {m.Name}");
            }
        }

        private static void ValidateOpcode(int opcode, string messageName)
        {
            if (opcode < 0)
                throw new Exception($"Negative opcode {opcode} for {messageName}");
        }

        /// <summary>
        /// Tag 적용 로직
        /// 1. spec에 tag가 있으면 최우선 + registry 반영
        /// 2. registry에 있으면 registry 값 사용
        /// 3. 둘 다 없으면 신규 할당 (메시지별 max + 1, 19000-19999 스킵)
        /// </summary>
        private static void ApplyTags(ProtocolSpec spec, Dictionary<string, int> registry)
        {
            foreach (var message in spec.Messages)
            {
                var used = new HashSet<int>();

                // Phase 1: 이미 사용 중인 tag 수집 + spec에 명시된 값 반영
                foreach (var field in message.Fields)
                {
                    var key = $"{message.Name}.{field.Name}";

                    if (field.Tag.HasValue)
                    {
                        // spec에 명시된 값 최우선
                        ValidateTag(field.Tag.Value, message.Name, field.Name);
                        if (used.Contains(field.Tag.Value))
                            throw new Exception($"Duplicate tag {field.Tag.Value} in {message.Name}");
                        used.Add(field.Tag.Value);
                        registry[key] = field.Tag.Value;
                    }
                    else if (registry.TryGetValue(key, out var regTag))
                    {
                        // registry에 있으면 사용
                        ValidateTag(regTag, message.Name, field.Name);
                        if (used.Contains(regTag))
                            throw new Exception($"Duplicate tag {regTag} in {message.Name} (from registry)");
                        field.Tag = regTag;
                        used.Add(regTag);
                    }
                }

                // Phase 2: 미지정 field에 신규 tag 할당
                int next = (used.Count > 0 ? used.Max() : 0) + 1;

                foreach (var field in message.Fields)
                {
                    if (!field.Tag.HasValue)
                    {
                        while (used.Contains(next) || IsReservedTag(next)) next++;
                        field.Tag = next;
                        registry[$"{message.Name}.{field.Name}"] = next;
                        used.Add(next);
                        next++;
                    }
                }

                // 검증: 모든 field에 tag가 할당됨
                foreach (var field in message.Fields)
                {
                    if (!field.Tag.HasValue)
                        throw new Exception($"Tag not assigned for {message.Name}.{field.Name}");
                }
            }
        }

        private static void ValidateTag(int tag, string messageName, string fieldName)
        {
            if (tag < 1 || tag > 536870911)
                throw new Exception($"Tag {tag} out of range (1..536870911) for {messageName}.{fieldName}");
            if (IsReservedTag(tag))
                throw new Exception($"Tag {tag} in reserved range (19000..19999) for {messageName}.{fieldName}");
        }

        private static bool IsReservedTag(int tag) => tag >= 19000 && tag <= 19999;

        #endregion

        #region UPM Scaffold

        private static void GenerateUpmScaffold(BuildConfig config, string name, DomainConfig domain)
        {
            var stagingUpm = Path.Combine(config.TempDir, name, "upm");
            var stagingRuntime = Path.Combine(stagingUpm, "Runtime");
            var stagingEditor = Path.Combine(stagingUpm, "Editor");

            Directory.CreateDirectory(stagingRuntime);
            Directory.CreateDirectory(stagingEditor);

            // package.json
            var packageJson = $$"""
{
  "name": "com.devian.{{name.ToLowerInvariant()}}",
  "version": "1.0.0",
  "displayName": "Devian {{name}}",
  "description": "Generated by Devian Build System",
  "unity": "2021.3"
}
""";
            File.WriteAllText(Path.Combine(stagingUpm, "package.json"), packageJson);

            // Runtime.asmdef
            var runtimeAsmdef = $$"""
{
  "name": "Devian.{{name}}",
  "references": ["Devian.Core"],
  "includePlatforms": [],
  "excludePlatforms": []
}
""";
            File.WriteAllText(Path.Combine(stagingRuntime, $"Devian.{name}.asmdef"), runtimeAsmdef);

            // Editor.asmdef
            var editorAsmdef = $$"""
{
  "name": "Devian.{{name}}.Editor",
  "references": ["Devian.{{name}}"],
  "includePlatforms": ["Editor"],
  "excludePlatforms": []
}
""";
            File.WriteAllText(Path.Combine(stagingEditor, $"Devian.{name}.Editor.asmdef"), editorAsmdef);

            // Copy C# generated files to Runtime
            var stagingCs = Path.Combine(config.TempDir, name, "cs", "generated");
            if (Directory.Exists(stagingCs))
            {
                foreach (var file in Directory.GetFiles(stagingCs, "*.cs"))
                {
                    File.Copy(file, Path.Combine(stagingRuntime, Path.GetFileName(file)), true);
                }
            }
        }

        #endregion

        #region Copy to Targets

        private static void CopyDomainToTargets(BuildConfig config, string name, DomainConfig domain)
        {
            var stagingCs = Path.Combine(config.TempDir, name, "cs", "generated");
            var stagingTs = Path.Combine(config.TempDir, name, "ts", "generated");
            var stagingData = Path.Combine(config.TempDir, name, "data", "json");
            var stagingUpm = Path.Combine(config.TempDir, name, "upm");

            // C# targets
            foreach (var target in domain.CsTargetDirs)
            {
                var resolvedTarget = ResolvePath(config, target);
                var targetGenerated = Path.Combine(resolvedTarget, "generated");
                CleanAndCopy(stagingCs, targetGenerated);
            }

            // TS targets
            foreach (var target in domain.TsTargetDirs)
            {
                var resolvedTarget = ResolvePath(config, target);
                var targetGenerated = Path.Combine(resolvedTarget, "generated");
                CleanAndCopy(stagingTs, targetGenerated);
            }

            // Data targets
            foreach (var target in domain.DataTargetDirs)
            {
                var resolvedTarget = ResolvePath(config, target);
                var targetJson = Path.Combine(resolvedTarget, "json");
                CleanAndCopy(stagingData, targetJson);
            }

            // UPM targets
            foreach (var target in domain.UpmTargetDirs)
            {
                var resolvedTarget = ResolvePath(config, target);
                CopyUpmToTarget(stagingUpm, resolvedTarget);
            }
        }

        private static void CopyProtocolGroupToTargets(BuildConfig config, ProtocolGroupConfig groupConfig)
        {
            var groupName = groupConfig.Group;
            var csProjectName = $"Devian.Protocol.{groupName}";
            
            var stagingCs = Path.Combine(config.TempDir, csProjectName);
            var stagingTs = Path.Combine(config.TempDir, groupName);

            // C# target: {csTargetDir}/Devian.Protocol.{ProtocolGroup}/
            if (!string.IsNullOrEmpty(groupConfig.CsTargetDir))
            {
                var resolvedTarget = ResolvePath(config, groupConfig.CsTargetDir);
                var targetDir = Path.Combine(resolvedTarget, csProjectName);
                CleanAndCopy(stagingCs, targetDir);
            }

            // TS target: {tsTargetDir}/{ProtocolGroup}/
            if (!string.IsNullOrEmpty(groupConfig.TsTargetDir))
            {
                var resolvedTarget = ResolvePath(config, groupConfig.TsTargetDir);
                var targetDir = Path.Combine(resolvedTarget, groupName);
                CleanAndCopy(stagingTs, targetDir);
            }
        }

        private static void CopyUpmToTarget(string stagingUpm, string targetDir)
        {
            if (!Directory.Exists(stagingUpm)) return;

            Directory.CreateDirectory(targetDir);

            // Scaffold files (don't overwrite if exist)
            var packageJsonSrc = Path.Combine(stagingUpm, "package.json");
            var packageJsonDest = Path.Combine(targetDir, "package.json");
            if (File.Exists(packageJsonSrc) && !File.Exists(packageJsonDest))
            {
                File.Copy(packageJsonSrc, packageJsonDest);
            }

            // Editor folder (don't overwrite if exist)
            var stagingEditor = Path.Combine(stagingUpm, "Editor");
            var targetEditor = Path.Combine(targetDir, "Editor");
            if (Directory.Exists(stagingEditor))
            {
                Directory.CreateDirectory(targetEditor);
                foreach (var file in Directory.GetFiles(stagingEditor))
                {
                    var dest = Path.Combine(targetEditor, Path.GetFileName(file));
                    if (!File.Exists(dest)) File.Copy(file, dest);
                }
            }

            // Runtime folder (clean & copy)
            var stagingRuntime = Path.Combine(stagingUpm, "Runtime");
            var targetRuntime = Path.Combine(targetDir, "Runtime");
            CleanAndCopy(stagingRuntime, targetRuntime);
        }

        private static void CleanAndCopy(string source, string target)
        {
            if (!Directory.Exists(source)) return;

            // Clean target
            if (Directory.Exists(target))
            {
                Directory.Delete(target, true);
            }
            Directory.CreateDirectory(target);

            // Copy files
            foreach (var file in Directory.GetFiles(source))
            {
                File.Copy(file, Path.Combine(target, Path.GetFileName(file)));
            }

            // Copy subdirectories
            foreach (var dir in Directory.GetDirectories(source))
            {
                CleanAndCopy(dir, Path.Combine(target, Path.GetFileName(dir)));
            }
        }

        #endregion

        #region Validate Command

        private static int ValidateCommand(string[] args)
        {
            var configPath = args.Length > 0 ? args[0] : "input/build/build.json";

            if (!File.Exists(configPath))
            {
                Console.Error.WriteLine($"Config file not found: {configPath}");
                return 1;
            }

            var json = File.ReadAllText(configPath);

            try
            {
                var config = JsonSerializer.Deserialize<BuildConfig>(json);
                if (config == null)
                {
                    Console.Error.WriteLine("Validation failed: could not parse build.json");
                    return 1;
                }

                if (config.Version != "10")
                {
                    Console.Error.WriteLine($"Validation failed: expected version '10', got '{config.Version}'");
                    return 1;
                }

                Console.WriteLine("Validation passed.");
                Console.WriteLine($"  Version: {config.Version}");
                Console.WriteLine($"  TempDir: {config.TempDir}");
                Console.WriteLine($"  Domains: {config.Domains?.Count ?? 0}");
                Console.WriteLine($"  Protocols: {(config.Protocols != null ? "configured" : "not configured")}");
                return 0;
            }
            catch (JsonException ex)
            {
                Console.Error.WriteLine($"Validation failed: JSON parse error - {ex.Message}");
                return 1;
            }
        }

        #endregion

        #region Utilities

        private static List<string> CollectFiles(string dir, List<string> patterns)
        {
            if (string.IsNullOrEmpty(dir) || !Directory.Exists(dir))
                return new List<string>();

            var files = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            foreach (var pattern in patterns)
            {
                foreach (var file in Directory.EnumerateFiles(dir, pattern, SearchOption.TopDirectoryOnly))
                {
                    files.Add(file);
                }
            }

            return files.OrderBy(f => f).ToList();
        }

        #endregion
    }
}

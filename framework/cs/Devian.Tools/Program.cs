// <auto-generated>
// DO NOT EDIT - Generated by Devian Build System
// </auto-generated>

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Text.Json;
using Devian.Tools.Generators;
using Devian.Tools.Models;

namespace Devian.Tools
{

    /// <summary>
    /// Devian Build Tools CLI (v9)
    /// </summary>
    public class Program
    {
        public static async Task<int> Main(string[] args)
        {
            if (args.Length == 0)
            {
                printUsage();
                return 1;
            }

            var command = args[0].ToLowerInvariant();

            try
            {
                return command switch
                {
                    "build" => await buildCommand(args[1..]),
                    "validate" => validateCommand(args[1..]),
                    "help" => help(),
                    _ => unknownCommand(command)
                };
            }
            catch (Exception ex)
            {
                Console.Error.WriteLine($"Error: {ex.Message}");
                
                // Inner exception 출력
                var inner = ex.InnerException;
                while (inner != null)
                {
                    Console.Error.WriteLine($"  Caused by: {inner.Message}");
                    inner = inner.InnerException;
                }
                
                return 1;
            }
        }

        private static void printUsage()
        {
            Console.WriteLine("Devian Build Tools (v9)");
            Console.WriteLine();
            Console.WriteLine("Usage: devian-tools <command> [options]");
            Console.WriteLine();
            Console.WriteLine("Commands:");
            Console.WriteLine("  build     Build domain(s) from build.json");
            Console.WriteLine("  validate  Validate build configuration");
            Console.WriteLine("  help      Show this help");
        }

        private static int help()
        {
            printUsage();
            return 0;
        }

        private static int unknownCommand(string command)
        {
            Console.Error.WriteLine($"Unknown command: {command}");
            printUsage();
            return 1;
        }

        #region File Collection

        /// <summary>
        /// Dir + Files patterns로 파일 수집
        /// </summary>
        private static List<string> collectFiles(string dir, List<string> patterns)
        {
            if (string.IsNullOrEmpty(dir) || !Directory.Exists(dir))
                return new List<string>();

            var files = new HashSet<string>(StringComparer.OrdinalIgnoreCase);

            foreach (var pattern in patterns)
            {
                foreach (var file in Directory.EnumerateFiles(dir, pattern, SearchOption.TopDirectoryOnly))
                {
                    files.Add(file);
                }
            }

            return files
                .OrderBy(f => f, StringComparer.OrdinalIgnoreCase)
                .ToList();
        }

        #endregion

        #region Build Command

        /// <summary>
        /// Build command (v9)
        /// </summary>
        private static async Task<int> buildCommand(string[] args)
        {
            var configPath = args.Length > 0 ? args[0] : "input/build/build.json";

            if (!File.Exists(configPath))
            {
                Console.Error.WriteLine($"Config file not found: {configPath}");
                return 1;
            }

            var json = await File.ReadAllTextAsync(configPath);
            var config = JsonSerializer.Deserialize<BuildConfig>(json);

            if (config == null)
            {
                Console.Error.WriteLine("Failed to parse build.json");
                return 1;
            }

            // v9 강제
            if (config.Version != "9")
            {
                Console.Error.WriteLine($"Build failed: expected version '9', got '{config.Version}'");
                return 1;
            }

            Console.WriteLine($"Devian Build - Version {config.Version}");
            Console.WriteLine($"Temp: {config.TempDir}");
            
            var domainNames = config.Domains?.Keys.ToList() ?? new List<string>();
            var protocolNames = config.Protocols?.Keys.ToList() ?? new List<string>();
            
            Console.WriteLine($"Domains: {(domainNames.Count > 0 ? string.Join(", ", domainNames) : "(none)")}");
            Console.WriteLine($"Protocols: {(protocolNames.Count > 0 ? string.Join(", ", protocolNames) : "(none)")}");
            Console.WriteLine();

            // (A) domains 처리 (tables + contracts)
            if (config.Domains != null)
            {
                foreach (var (domain, domainConfig) in config.Domains)
                {
                    Console.WriteLine($"Building domain: {domain}");
                    await buildDomain(config, domain, domainConfig);
                }
            }

            // (B) protocols 처리 (IDL)
            if (config.Protocols != null)
            {
                foreach (var (name, protocolConfig) in config.Protocols)
                {
                    Console.WriteLine($"Building protocol: {name}");
                    await buildProtocol(config, name, protocolConfig);
                }
            }

            Console.WriteLine();
            Console.WriteLine("Build completed.");
            return 0;
        }

        /// <summary>
        /// Build single domain (v9 - data domain only)
        /// tables + contracts 처리
        /// </summary>
        private static async Task buildDomain(BuildConfig config, string domain, DomainConfig domainConfig)
        {
            // Contracts
            if (!string.IsNullOrEmpty(domainConfig.ContractsDir) && domainConfig.ContractFiles?.Count > 0)
            {
                var contractFiles = collectFiles(domainConfig.ContractsDir, domainConfig.ContractFiles);
                foreach (var contractFile in contractFiles)
                {
                    await processContractFile(config, domain, domainConfig, contractFile);
                }
            }

            // Tables
            if (!string.IsNullOrEmpty(domainConfig.TablesDir) && domainConfig.TableFiles?.Count > 0)
            {
                var tableFiles = collectFiles(domainConfig.TablesDir, domainConfig.TableFiles);
                foreach (var tableFile in tableFiles)
                {
                    await processTableFile(config, domain, domainConfig, tableFile);
                }
            }
        }

        /// <summary>
        /// Build single protocol (v9 - IDL link domain)
        /// protocolsDir + protocolFile (단일 파일)
        /// </summary>
        private static async Task buildProtocol(BuildConfig config, string name, ProtocolConfig protocolConfig)
        {
            if (string.IsNullOrEmpty(protocolConfig.ProtocolsDir) || string.IsNullOrEmpty(protocolConfig.ProtocolFile))
            {
                Console.Error.WriteLine($"  Error: protocolsDir and protocolFile are required for protocol '{name}'");
                return;
            }

            var protocolFilePath = Path.Combine(protocolConfig.ProtocolsDir, protocolConfig.ProtocolFile);
            if (!File.Exists(protocolFilePath))
            {
                Console.Error.WriteLine($"  Warning: Protocol file not found: {protocolFilePath}");
                return;
            }

            // 현재는 .proto 파싱 미지원 - JSON 폴백 또는 placeholder
            var ext = Path.GetExtension(protocolFilePath).ToLowerInvariant();
            if (ext == ".proto")
            {
                // TODO: Phase 5에서 protoc 연동 구현
                Console.WriteLine($"  Note: .proto parsing not yet implemented for: {protocolFilePath}");
                Console.WriteLine($"  Skipping protocol code generation for '{name}'");
            }
            else if (ext == ".json")
            {
                await processProtocolJsonForProtocol(config, name, protocolConfig, protocolFilePath);
            }
        }

        #endregion

        #region Contract Processing

        private static async Task processContractFile(BuildConfig config, string domain, DomainConfig domainConfig, string filePath)
        {
            var ext = Path.GetExtension(filePath).ToLowerInvariant();

            switch (ext)
            {
                case ".json":
                    Console.WriteLine($"  Processing contract (json): {Path.GetFileName(filePath)}");
                    await processContractJson(config, domain, domainConfig, filePath);
                    break;
                case ".proto":
                    Console.WriteLine($"  Processing contract (proto-json): {Path.GetFileName(filePath)}");
                    await processContractProtoJson(config, domain, domainConfig, filePath);
                    break;
                default:
                    throw new NotSupportedException(
                        $"[domain='{domain}'] Contract input '{ext}' is not supported. file='{filePath}'");
            }
        }

        private static async Task processContractProtoJson(BuildConfig config, string domain, DomainConfig domainConfig, string filePath)
        {
            var text = await File.ReadAllTextAsync(filePath);
            
            JsonDocument doc;
            try
            {
                doc = JsonDocument.Parse(text);
            }
            catch (JsonException)
            {
                throw new NotSupportedException(
                    $"[domain='{domain}'] Contract '.proto' is not JSON (proto-json). Protobuf IDL .proto is not supported yet (Phase 4). file='{filePath}'");
            }

            // 이후 기존 로직 수행
            await generateContractCode(config, domain, domainConfig, doc, filePath);
        }

        private static async Task processContractJson(BuildConfig config, string domain, DomainConfig domainConfig, string contractFile)
        {
            var json = await File.ReadAllTextAsync(contractFile);
            var doc = JsonDocument.Parse(json);

            await generateContractCode(config, domain, domainConfig, doc, contractFile);
        }

        private static async Task generateContractCode(BuildConfig config, string domain, DomainConfig domainConfig, JsonDocument doc, string contractFile)
        {
            var ns = DomainNamespace.ToCSharpNamespace(domain);

            // Generate C#
            foreach (var targetDir in domainConfig.CsTargetDirs)
            {
                var generatedDir = Path.Combine(targetDir, "generated");
                Directory.CreateDirectory(generatedDir);

                var code = CSharpContractGenerator.Generate(doc, ns);
                var fileName = Path.GetFileNameWithoutExtension(contractFile);
                var path = Path.Combine(generatedDir, $"{fileName}.g.cs");
                await File.WriteAllTextAsync(path, code);
            }

            // Generate TS
            foreach (var targetDir in domainConfig.TsTargetDirs)
            {
                var generatedDir = Path.Combine(targetDir, "generated");
                Directory.CreateDirectory(generatedDir);

                var code = TypeScriptContractGenerator.Generate(doc);
                var fileName = Path.GetFileNameWithoutExtension(contractFile);
                var path = Path.Combine(generatedDir, $"{fileName}.g.ts");
                await File.WriteAllTextAsync(path, code);
            }
        }

        #endregion

        #region Table Processing

        private static async Task processTableFile(BuildConfig config, string domain, DomainConfig domainConfig, string filePath)
        {
            var ext = Path.GetExtension(filePath).ToLowerInvariant();

            switch (ext)
            {
                case ".json":
                    Console.WriteLine($"  Processing table (json): {Path.GetFileName(filePath)}");
                    await processTableJson(config, domain, domainConfig, filePath);
                    break;
                case ".xlsx":
                    Console.WriteLine($"  Processing table (xlsx): {Path.GetFileName(filePath)}");
                    await processTableXlsx(config, domain, domainConfig, filePath);
                    break;
                default:
                    throw new NotSupportedException(
                        $"[domain='{domain}'] Table input '{ext}' is not supported. file='{filePath}'");
            }
        }

        private static async Task processTableXlsx(BuildConfig config, string domain, DomainConfig domainConfig, string xlsxPath)
        {
            List<TableSpec> tables;
            
            try
            {
                tables = TableSchemaParser.ParseTablesXlsx(xlsxPath, domain);
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"[domain='{domain}'] Failed to parse xlsx: {ex.Message}", ex);
            }

            if (tables.Count == 0)
            {
                Console.WriteLine($"    No tables found in xlsx");
                return;
            }

            await generateTablesCode(config, domain, domainConfig, tables);
        }

        private static async Task processTableJson(BuildConfig config, string domain, DomainConfig domainConfig, string tablesJsonPath)
        {
            var json = await File.ReadAllTextAsync(tablesJsonPath);
            List<TableSpec> tables;
            
            try
            {
                tables = TableSchemaParser.ParseTablesJson(json, domain);
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"[domain='{domain}'] Failed to parse tables.json: {ex.Message}", ex);
            }

            await generateTablesCode(config, domain, domainConfig, tables);
        }

        private static async Task generateTablesCode(BuildConfig config, string domain, DomainConfig domainConfig, List<TableSpec> tables)
        {
            var ns = DomainNamespace.ToCSharpNamespace(domain);

            foreach (var table in tables)
            {
                Console.WriteLine($"    Table: {table.TableName} ({table.Columns.Count} columns)");
                
                // Validate
                var errors = TableSchemaParser.ValidateTableSpec(table);
                if (errors.Count > 0)
                {
                    foreach (var error in errors)
                        Console.Error.WriteLine($"      Validation error: {error}");
                    throw new InvalidOperationException($"[domain='{domain}', table='{table.TableName}'] Table validation failed");
                }

                try
                {
                    // Generate C# Row
                    foreach (var targetDir in domainConfig.CsTargetDirs)
                    {
                        var generatedDir = Path.Combine(targetDir, "generated");
                        Directory.CreateDirectory(generatedDir);

                        var rowCode = CSharpTableGenerator.Generate(table, ns);
                        var rowPath = Path.Combine(generatedDir, $"{table.RowTypeName}.g.cs");
                        await File.WriteAllTextAsync(rowPath, rowCode);

                        var tableCode = CSharpTableGenerator.GenerateTable(table, ns);
                        var tablePath = Path.Combine(generatedDir, $"{table.TableName}Table.g.cs");
                        await File.WriteAllTextAsync(tablePath, tableCode);
                    }
                }
                catch (Exception ex)
                {
                    throw new InvalidOperationException($"[domain='{domain}', table='{table.TableName}'] C# generation failed: {ex.Message}", ex);
                }

                try
                {
                    // Generate TS Row
                    foreach (var targetDir in domainConfig.TsTargetDirs)
                    {
                        var generatedDir = Path.Combine(targetDir, "generated");
                        Directory.CreateDirectory(generatedDir);

                        var rowCode = TypeScriptTableGenerator.Generate(table);
                        var rowPath = Path.Combine(generatedDir, $"{table.RowTypeName}.g.ts");
                        await File.WriteAllTextAsync(rowPath, rowCode);

                        var tableCode = TypeScriptTableGenerator.GenerateTable(table);
                        var tablePath = Path.Combine(generatedDir, $"{table.TableName}Table.g.ts");
                        await File.WriteAllTextAsync(tablePath, tableCode);
                    }
                }
                catch (Exception ex)
                {
                    throw new InvalidOperationException($"[domain='{domain}', table='{table.TableName}'] TypeScript generation failed: {ex.Message}", ex);
                }
            }

            // Generate Bootstrap
            if (tables.Count > 0)
            {
                try
                {
                    foreach (var targetDir in domainConfig.CsTargetDirs)
                    {
                        var generatedDir = Path.Combine(targetDir, "generated");

                        var bootstrapCode = CSharpBootstrapGenerator.Generate(tables, ns);
                        var bootstrapPath = Path.Combine(generatedDir, "Bootstrap.g.cs");
                        await File.WriteAllTextAsync(bootstrapPath, bootstrapCode);
                    }
                }
                catch (Exception ex)
                {
                    throw new InvalidOperationException($"[domain='{domain}'] Bootstrap generation failed: {ex.Message}", ex);
                }
            }
        }

        #endregion

        #region Protocol Processing

        private static async Task processProtocolFile(BuildConfig config, string domain, DomainConfig domainConfig, string filePath)
        {
            var ext = Path.GetExtension(filePath).ToLowerInvariant();

            switch (ext)
            {
                case ".json":
                    Console.WriteLine($"  Processing protocol (json): {Path.GetFileName(filePath)}");
                    await processProtocolJson(config, domain, domainConfig, filePath);
                    break;
                case ".proto":
                    Console.WriteLine($"  Processing protocol (proto-json): {Path.GetFileName(filePath)}");
                    await processProtocolProtoJson(config, domain, domainConfig, filePath);
                    break;
                default:
                    throw new NotSupportedException(
                        $"[domain='{domain}'] Protocol input '{ext}' is not supported. file='{filePath}'");
            }
        }

        private static async Task processProtocolProtoJson(BuildConfig config, string domain, DomainConfig domainConfig, string filePath)
        {
            var text = await File.ReadAllTextAsync(filePath);
            
            ProtocolSpec? spec;
            try
            {
                spec = JsonSerializer.Deserialize<ProtocolSpec>(text);
            }
            catch (JsonException)
            {
                throw new NotSupportedException(
                    $"[domain='{domain}'] Protocol '.proto' is not JSON (proto-json). Protobuf IDL .proto is not supported yet (Phase 4). file='{filePath}'");
            }

            if (spec == null)
            {
                throw new InvalidOperationException($"[domain='{domain}'] Failed to parse protocol: {filePath}");
            }

            // 이후 기존 로직 수행
            await generateProtocolCode(config, domain, domainConfig, spec, filePath);
        }

        private static async Task processProtocolJson(BuildConfig config, string domain, DomainConfig domainConfig, string protocolFile)
        {
            var json = await File.ReadAllTextAsync(protocolFile);
            var spec = JsonSerializer.Deserialize<ProtocolSpec>(json);

            if (spec == null)
            {
                Console.Error.WriteLine($"    Failed to parse: {protocolFile}");
                return;
            }

            await generateProtocolCode(config, domain, domainConfig, spec, protocolFile);
        }

        private static async Task generateProtocolCode(BuildConfig config, string domain, DomainConfig domainConfig, ProtocolSpec spec, string protocolFile)
        {
            // Auto-allocate opcodes
            OpcodeAllocator.AllocateOpcodes(spec);

            var ns = DomainNamespace.ToCSharpNamespace(domain);

            // Generate C#
            foreach (var targetDir in domainConfig.CsTargetDirs)
            {
                var generatedDir = Path.Combine(targetDir, "generated");
                Directory.CreateDirectory(generatedDir);

                var code = CSharpProtocolGenerator.Generate(spec, ns);
                var fileName = Path.GetFileNameWithoutExtension(protocolFile);
                var path = Path.Combine(generatedDir, $"{fileName}.g.cs");
                await File.WriteAllTextAsync(path, code);
            }

            // Generate TS
            foreach (var targetDir in domainConfig.TsTargetDirs)
            {
                var generatedDir = Path.Combine(targetDir, "generated");
                Directory.CreateDirectory(generatedDir);

                var code = TypeScriptProtocolGenerator.Generate(spec);
                var fileName = Path.GetFileNameWithoutExtension(protocolFile);
                var path = Path.Combine(generatedDir, $"{fileName}.g.ts");
                await File.WriteAllTextAsync(path, code);
            }
        }

        /// <summary>
        /// Process protocol JSON for ProtocolConfig (v9)
        /// </summary>
        private static async Task processProtocolJsonForProtocol(BuildConfig config, string name, ProtocolConfig protocolConfig, string protocolFile)
        {
            var json = await File.ReadAllTextAsync(protocolFile);
            var spec = JsonSerializer.Deserialize<ProtocolSpec>(json);

            if (spec == null)
            {
                Console.Error.WriteLine($"    Failed to parse: {protocolFile}");
                return;
            }

            // Auto-allocate opcodes
            OpcodeAllocator.AllocateOpcodes(spec);

            var ns = DomainNamespace.ToCSharpNamespace(name);

            // Generate C#
            foreach (var targetDir in protocolConfig.CsTargetDirs)
            {
                var generatedDir = Path.Combine(targetDir, "generated");
                Directory.CreateDirectory(generatedDir);

                var code = CSharpProtocolGenerator.Generate(spec, ns);
                var fileName = Path.GetFileNameWithoutExtension(protocolFile);
                var path = Path.Combine(generatedDir, $"{fileName}.g.cs");
                await File.WriteAllTextAsync(path, code);
            }

            // Generate TS
            foreach (var targetDir in protocolConfig.TsTargetDirs)
            {
                var generatedDir = Path.Combine(targetDir, "generated");
                Directory.CreateDirectory(generatedDir);

                var code = TypeScriptProtocolGenerator.Generate(spec);
                var fileName = Path.GetFileNameWithoutExtension(protocolFile);
                var path = Path.Combine(generatedDir, $"{fileName}.g.ts");
                await File.WriteAllTextAsync(path, code);
            }
        }

        #endregion

        #region Validate Command

        /// <summary>
        /// Validate command (v9)
        /// </summary>
        private static int validateCommand(string[] args)
        {
            var configPath = args.Length > 0 ? args[0] : "input/build/build.json";

            if (!File.Exists(configPath))
            {
                Console.Error.WriteLine($"Config file not found: {configPath}");
                return 1;
            }

            var json = File.ReadAllText(configPath);
            
            // (A) JSON 파싱 및 deprecated 필드 감지
            try
            {
                var doc = JsonDocument.Parse(json);
                var root = doc.RootElement;
                
                // root 레벨 deprecated 키 감지
                if (root.TryGetProperty("inputDir", out _))
                {
                    Console.Error.WriteLine("Validation failed: deprecated field 'inputDir' detected.");
                    Console.Error.WriteLine("  Use domains[domain].contractsDir/tablesDir or protocols[name].protocolsDir instead.");
                    return 1;
                }
                
                if (root.TryGetProperty("inputDirs", out _))
                {
                    Console.Error.WriteLine("Validation failed: deprecated field 'inputDirs' detected.");
                    Console.Error.WriteLine("  Use domains[domain].contractsDir/tablesDir or protocols[name].protocolsDir instead.");
                    return 1;
                }

                // domains 내부에 protocols 관련 키가 있으면 v8 혼합 흔적
                if (root.TryGetProperty("domains", out var domains))
                {
                    foreach (var domainProp in domains.EnumerateObject())
                    {
                        var domainName = domainProp.Name;
                        var domainObj = domainProp.Value;

                        // v8 혼합 흔적: domains 아래에 protocolsDir/protocolFile
                        if (domainObj.TryGetProperty("protocolsDir", out _) || domainObj.TryGetProperty("protocolFile", out _))
                        {
                            Console.Error.WriteLine($"Validation failed: domains['{domainName}'] has protocolsDir/protocolFile.");
                            Console.Error.WriteLine("  In v9, protocols must be in the top-level 'protocols' section, not 'domains'.");
                            return 1;
                        }

                        // v7 레거시 키 감지
                        if (domainObj.TryGetProperty("tableDir", out _))
                        {
                            Console.Error.WriteLine($"Validation failed: deprecated field 'tableDir' in domains['{domainName}'].");
                            Console.Error.WriteLine("  Use tablesDir/tableFiles instead.");
                            return 1;
                        }
                        if (domainObj.TryGetProperty("contractDir", out _))
                        {
                            Console.Error.WriteLine($"Validation failed: deprecated field 'contractDir' in domains['{domainName}'].");
                            Console.Error.WriteLine("  Use contractsDir/contractFiles instead.");
                            return 1;
                        }
                        if (domainObj.TryGetProperty("protocolDir", out _))
                        {
                            Console.Error.WriteLine($"Validation failed: deprecated field 'protocolDir' in domains['{domainName}'].");
                            Console.Error.WriteLine("  Use protocols section with protocolsDir/protocolFile instead.");
                            return 1;
                        }
                        if (domainObj.TryGetProperty("protocolFiles", out _))
                        {
                            Console.Error.WriteLine($"Validation failed: deprecated field 'protocolFiles' in domains['{domainName}'].");
                            Console.Error.WriteLine("  Use protocols section with protocolFile (singular) instead.");
                            return 1;
                        }
                    }
                }

                // protocols 섹션 내부 deprecated 키 감지
                if (root.TryGetProperty("protocols", out var protocols))
                {
                    foreach (var protocolProp in protocols.EnumerateObject())
                    {
                        var protocolName = protocolProp.Name;
                        var protocolObj = protocolProp.Value;

                        if (protocolObj.TryGetProperty("protocolFiles", out _))
                        {
                            Console.Error.WriteLine($"Validation failed: deprecated field 'protocolFiles' in protocols['{protocolName}'].");
                            Console.Error.WriteLine("  Use protocolFile (singular) instead.");
                            return 1;
                        }
                        if (protocolObj.TryGetProperty("protocolDir", out _))
                        {
                            Console.Error.WriteLine($"Validation failed: deprecated field 'protocolDir' in protocols['{protocolName}'].");
                            Console.Error.WriteLine("  Use protocolsDir instead.");
                            return 1;
                        }
                    }
                }
            }
            catch (JsonException ex)
            {
                Console.Error.WriteLine($"Failed to parse build.json: {ex.Message}");
                return 1;
            }
            
            var config = JsonSerializer.Deserialize<BuildConfig>(json);

            if (config == null)
            {
                Console.Error.WriteLine("Failed to parse build.json");
                return 1;
            }

            // (B) Version 검증 - v9 강제
            if (config.Version != "9")
            {
                Console.Error.WriteLine($"Validation failed: expected version '9', got '{config.Version}'");
                return 1;
            }

            var hasErrors = false;

            // (C) domains 검증
            if (config.Domains != null)
            {
                foreach (var (domain, domainConfig) in config.Domains)
                {
                    var hasTables = !string.IsNullOrEmpty(domainConfig.TablesDir) || 
                                    (domainConfig.TableFiles?.Count > 0);
                    var hasContracts = !string.IsNullOrEmpty(domainConfig.ContractsDir) || 
                                       (domainConfig.ContractFiles?.Count > 0);

                    // Data domain: tables 또는 contracts 중 하나 이상 필요
                    if (!hasTables && !hasContracts)
                    {
                        Console.Error.WriteLine($"Validation failed: domains['{domain}'] must have tablesDir/tableFiles or contractsDir/contractFiles.");
                        Console.Error.WriteLine("  Data domains require at least one of tables or contracts.");
                        hasErrors = true;
                    }

                    // tablesDir/tableFiles 쌍 검증
                    var hasTablesDir = !string.IsNullOrEmpty(domainConfig.TablesDir);
                    var hasTableFiles = domainConfig.TableFiles?.Count > 0;
                    if (hasTablesDir != hasTableFiles)
                    {
                        Console.Error.WriteLine($"Validation failed: domains['{domain}'] has tablesDir but no tableFiles (or vice versa).");
                        Console.Error.WriteLine("  Both tablesDir and tableFiles must be present together.");
                        hasErrors = true;
                    }

                    // contractsDir/contractFiles 쌍 검증
                    var hasContractsDir = !string.IsNullOrEmpty(domainConfig.ContractsDir);
                    var hasContractFiles = domainConfig.ContractFiles?.Count > 0;
                    if (hasContractsDir != hasContractFiles)
                    {
                        Console.Error.WriteLine($"Validation failed: domains['{domain}'] has contractsDir but no contractFiles (or vice versa).");
                        Console.Error.WriteLine("  Both contractsDir and contractFiles must be present together.");
                        hasErrors = true;
                    }
                    
                    // 경로 존재 여부는 경고만
                    if (!string.IsNullOrEmpty(domainConfig.ContractsDir) && !Directory.Exists(domainConfig.ContractsDir))
                    {
                        Console.WriteLine($"Warning: domains['{domain}'].contractsDir does not exist: {domainConfig.ContractsDir}");
                    }
                    if (!string.IsNullOrEmpty(domainConfig.TablesDir) && !Directory.Exists(domainConfig.TablesDir))
                    {
                        Console.WriteLine($"Warning: domains['{domain}'].tablesDir does not exist: {domainConfig.TablesDir}");
                    }
                }
            }

            // (D) protocols 검증
            if (config.Protocols != null)
            {
                foreach (var (name, protocolConfig) in config.Protocols)
                {
                    // protocolsDir 필수
                    if (string.IsNullOrEmpty(protocolConfig.ProtocolsDir))
                    {
                        Console.Error.WriteLine($"Validation failed: protocols['{name}'].protocolsDir is required");
                        hasErrors = true;
                    }

                    // protocolFile 필수
                    if (string.IsNullOrEmpty(protocolConfig.ProtocolFile))
                    {
                        Console.Error.WriteLine($"Validation failed: protocols['{name}'].protocolFile is required");
                        hasErrors = true;
                    }
                    else
                    {
                        // protocolFile은 파일명만 허용 (경로 구분자 금지)
                        if (protocolConfig.ProtocolFile.Contains('/') || protocolConfig.ProtocolFile.Contains('\\'))
                        {
                            Console.Error.WriteLine($"Validation failed: protocols['{name}'].protocolFile must be a filename only, not a path.");
                            Console.Error.WriteLine($"  Got: {protocolConfig.ProtocolFile}");
                            hasErrors = true;
                        }
                    }

                    // 경로 존재 여부는 경고만
                    if (!string.IsNullOrEmpty(protocolConfig.ProtocolsDir) && !Directory.Exists(protocolConfig.ProtocolsDir))
                    {
                        Console.WriteLine($"Warning: protocols['{name}'].protocolsDir does not exist: {protocolConfig.ProtocolsDir}");
                    }
                    if (!string.IsNullOrEmpty(protocolConfig.ProtocolsDir) && !string.IsNullOrEmpty(protocolConfig.ProtocolFile))
                    {
                        var fullPath = Path.Combine(protocolConfig.ProtocolsDir, protocolConfig.ProtocolFile);
                        if (!File.Exists(fullPath))
                        {
                            Console.WriteLine($"Warning: protocols['{name}'] file does not exist: {fullPath}");
                        }
                    }
                }
            }

            if (hasErrors)
            {
                return 1;
            }

            Console.WriteLine("Validation passed.");
            return 0;
        }

        #endregion
    }
}

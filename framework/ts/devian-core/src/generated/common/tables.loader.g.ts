// <auto-generated>
// DO NOT EDIT - Generated by Devian.Tools
// Domain: common
// </auto-generated>

import { readFile } from 'node:fs/promises';
import { join } from 'node:path';

import type { TestTableRow } from './TestTableRow.g';

// === Table Metadata ===
interface TableMeta {
  name: string;
  fileName: string;
  keyColumn: string;
}

const TABLE_DEFS: readonly TableMeta[] = [
  { name: 'TestTable', fileName: 'testtable', keyColumn: 'number' },
] as const;

// === Cache Storage (module scope) ===
let _baseDir: string | null = null;
const _rowsCache = new Map<string, readonly unknown[]>();
const _mapCache = new Map<string, Readonly<Record<string, unknown>>>();

/**
 * Initialize tables from JSON files.
 * @param options.baseDir - Base directory containing table JSON files
 */
export async function initializeTables(options: { baseDir: string }): Promise<void> {
  _baseDir = options.baseDir;
  await reloadTables();
}

/**
 * Get table rows as readonly array.
 * @param tableName - Name of the table
 * @returns Readonly array of rows
 */
export function getTableRows<T>(tableName: string): readonly T[] {
  const rows = _rowsCache.get(tableName);
  if (!rows) {
    throw new Error(`Table '${tableName}' not loaded. Call initializeTables() first.`);
  }
  return rows as readonly T[];
}

/**
 * Get table as readonly key-value map.
 * @param tableName - Name of the table
 * @returns Readonly record keyed by row key
 */
export function getTableMap<T>(tableName: string): Readonly<Record<string, T>> {
  const map = _mapCache.get(tableName);
  if (!map) {
    throw new Error(`Table '${tableName}' not loaded. Call initializeTables() first.`);
  }
  return map as Readonly<Record<string, T>>;
}

/**
 * Reload tables from disk.
 * @param tableName - Optional. If provided, reload only this table. Otherwise reload all.
 */
export async function reloadTables(tableName?: string): Promise<void> {
  if (!_baseDir) {
    throw new Error('Tables not initialized. Call initializeTables() first.');
  }

  const tablesToLoad = tableName
    ? TABLE_DEFS.filter(t => t.name === tableName)
    : TABLE_DEFS;

  if (tableName && tablesToLoad.length === 0) {
    throw new Error(`Unknown table: '${tableName}'`);
  }

  for (const table of tablesToLoad) {
    const filePath = join(_baseDir, `${table.fileName}.json`);
    
    let content: string;
    try {
      content = await readFile(filePath, 'utf8');
    } catch (err) {
      throw new Error(`Failed to read table file: ${filePath}. ${err}`);
    }

    let rows: unknown[];
    try {
      rows = JSON.parse(content);
    } catch (err) {
      throw new Error(`Failed to parse table JSON: ${filePath}. ${err}`);
    }

    if (!Array.isArray(rows)) {
      throw new Error(`Table JSON must be an array: ${filePath}`);
    }

    // Build map keyed by keyColumn
    const map: Record<string, unknown> = {};
    for (const row of rows) {
      const key = String((row as Record<string, unknown>)[table.keyColumn]);
      map[key] = row;
    }

    _rowsCache.set(table.name, Object.freeze(rows));
    _mapCache.set(table.name, Object.freeze(map));
  }
}

// === Type-safe Table Accessors ===

/** Get TestTable rows */
export function getTestTableRows(): readonly TestTableRow[] {
  return getTableRows<TestTableRow>('TestTable');
}

/** Get TestTable by key */
export function getTestTable(key: number): TestTableRow | undefined {
  return getTableMap<TestTableRow>('TestTable')[String(key)];
}

#!/usr/bin/env node
// <auto-generated>
// Devian Build System v10 - Node.js Build Runner
// SSOT: skills/devian/03-ssot/SKILL.md
// </auto-generated>

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

// Generators
import { generateCSharpProtocol } from './generators/protocol-cs.js';
import { generateTypeScriptProtocol } from './generators/protocol-ts.js';
import { generateCSharpContract } from './generators/contract-cs.js';
import { generateTypeScriptContract } from './generators/contract-ts.js';
import { generateCSharpTable, generateTableData, parseXlsx } from './generators/table.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ============================================================================
// Build Runner
// ============================================================================

class BuildRunner {
    constructor(buildJsonPath) {
        this.buildJsonPath = path.resolve(buildJsonPath);
        // input/build/build.json -> input/build -> input -> devian (project root)
        // buildJsonDir = directory containing build.json
        this.buildJsonDir = path.dirname(this.buildJsonPath);
        this.rootDir = path.dirname(path.dirname(this.buildJsonDir));
        this.config = null;
        this.tempDir = null;
    }

    async run() {
        console.log('='.repeat(60));
        console.log('Devian Build System v10');
        console.log('='.repeat(60));
        console.log(`Build config: ${this.buildJsonPath}`);
        console.log(`Root dir: ${this.rootDir}`);
        console.log();

        // 1. Load config
        this.config = JSON.parse(fs.readFileSync(this.buildJsonPath, 'utf-8'));
        // tempDir is relative to build.json directory
        this.tempDir = path.join(this.buildJsonDir, this.config.tempDir || 'temp');

        // 2. Clean temp dir
        console.log('[Phase 0] Cleaning temp directory...');
        if (fs.existsSync(this.tempDir)) {
            fs.rmSync(this.tempDir, { recursive: true });
        }
        fs.mkdirSync(this.tempDir, { recursive: true });

        // 3. Generate to staging
        console.log('[Phase 1] Generating to staging...');
        
        // Process domains (contracts + tables)
        if (this.config.domains) {
            for (const [domainName, domainConfig] of Object.entries(this.config.domains)) {
                await this.processDomain(domainName, domainConfig);
            }
        }

        // Process protocols
        if (this.config.protocols) {
            for (const [protocolName, protocolConfig] of Object.entries(this.config.protocols)) {
                await this.processProtocol(protocolName, protocolConfig);
            }
        }

        // 4. Clean & Copy to targets
        console.log('[Phase 2] Clean & Copy to targets...');
        
        if (this.config.domains) {
            for (const [domainName, domainConfig] of Object.entries(this.config.domains)) {
                await this.copyDomainToTargets(domainName, domainConfig);
            }
        }

        if (this.config.protocols) {
            for (const [protocolName, protocolConfig] of Object.entries(this.config.protocols)) {
                await this.copyProtocolToTargets(protocolName, protocolConfig);
            }
        }

        console.log();
        console.log('='.repeat(60));
        console.log('Build completed successfully!');
        console.log('='.repeat(60));
    }

    // ========================================================================
    // Domain Processing (Contracts + Tables)
    // ========================================================================

    async processDomain(domainName, config) {
        console.log(`  [Domain] ${domainName}`);

        const stagingCs = path.join(this.tempDir, domainName, 'cs', 'generated');
        const stagingTs = path.join(this.tempDir, domainName, 'ts', 'generated');
        const stagingData = path.join(this.tempDir, domainName, 'data', 'json');

        fs.mkdirSync(stagingCs, { recursive: true });
        fs.mkdirSync(stagingTs, { recursive: true });
        fs.mkdirSync(stagingData, { recursive: true });

        // Process contracts
        if (config.contractsDir && config.contractFiles) {
            const contractsDir = path.join(this.rootDir, config.contractsDir);
            const files = this.globFiles(contractsDir, config.contractFiles);

            for (const file of files) {
                console.log(`    [Contract] ${path.basename(file)}`);
                const spec = JSON.parse(fs.readFileSync(file, 'utf-8'));

                // C# Contract
                const csCode = generateCSharpContract(spec, domainName);
                const csFileName = path.basename(file, '.json') + '.g.cs';
                fs.writeFileSync(path.join(stagingCs, csFileName), csCode);

                // TypeScript Contract
                const tsCode = generateTypeScriptContract(spec, domainName);
                const tsFileName = path.basename(file, '.json') + '.g.ts';
                fs.writeFileSync(path.join(stagingTs, tsFileName), tsCode);
            }
        }

        // Process tables
        if (config.tablesDir && config.tableFiles) {
            const tablesDir = path.join(this.rootDir, config.tablesDir);
            const files = this.globFiles(tablesDir, config.tableFiles);

            for (const file of files) {
                console.log(`    [Table] ${path.basename(file)}`);
                const tables = parseXlsx(file);

                for (const table of tables) {
                    // C# Table Container
                    const csCode = generateCSharpTable(table, domainName);
                    const csFileName = `TB_${table.name}.g.cs`;
                    fs.writeFileSync(path.join(stagingCs, csFileName), csCode);

                    // NDJSON Data
                    const ndjson = generateTableData(table);
                    const dataFileName = `${table.name}.ndjson`;
                    fs.writeFileSync(path.join(stagingData, dataFileName), ndjson);
                }
            }
        }
    }

    async copyDomainToTargets(domainName, config) {
        const stagingCs = path.join(this.tempDir, domainName, 'cs', 'generated');
        const stagingTs = path.join(this.tempDir, domainName, 'ts', 'generated');
        const stagingData = path.join(this.tempDir, domainName, 'data', 'json');

        // Copy to CS targets
        if (config.csTargetDirs) {
            for (const targetDir of config.csTargetDirs) {
                const target = path.join(this.rootDir, targetDir, 'generated');
                this.cleanAndCopy(stagingCs, target);
                console.log(`    [Copy] ${stagingCs} -> ${target}`);
            }
        }

        // Copy to TS targets
        if (config.tsTargetDirs) {
            for (const targetDir of config.tsTargetDirs) {
                const target = path.join(this.rootDir, targetDir, 'generated');
                this.cleanAndCopy(stagingTs, target);
                console.log(`    [Copy] ${stagingTs} -> ${target}`);
            }
        }

        // Copy to Data targets
        if (config.dataTargetDirs) {
            for (const targetDir of config.dataTargetDirs) {
                const target = path.join(this.rootDir, targetDir, 'json');
                this.cleanAndCopy(stagingData, target);
                console.log(`    [Copy] ${stagingData} -> ${target}`);
            }
        }
    }

    // ========================================================================
    // Protocol Processing
    // ========================================================================

    async processProtocol(protocolName, config) {
        console.log(`  [Protocol] ${protocolName}`);

        const stagingCs = path.join(this.tempDir, protocolName, 'cs', 'generated');
        const stagingTs = path.join(this.tempDir, protocolName, 'ts', 'generated');

        fs.mkdirSync(stagingCs, { recursive: true });
        fs.mkdirSync(stagingTs, { recursive: true });

        // Load protocol spec
        const protocolFile = path.join(this.rootDir, config.protocolsDir, config.protocolFile);
        const spec = JSON.parse(fs.readFileSync(protocolFile, 'utf-8'));

        // Load or create opcode registry
        const opcodeRegistry = this.loadOrCreateRegistry(protocolName, 'opcodes');
        const tagRegistry = this.loadOrCreateRegistry(protocolName, 'tags');

        // Assign opcodes and tags
        this.assignOpcodes(spec, opcodeRegistry);
        this.assignTags(spec, tagRegistry);

        // Save registries
        this.saveRegistry(protocolName, 'opcodes', opcodeRegistry);
        this.saveRegistry(protocolName, 'tags', tagRegistry);

        // C# Protocol
        const csCode = generateCSharpProtocol(spec, protocolName);
        fs.writeFileSync(path.join(stagingCs, `${protocolName}.g.cs`), csCode);

        // TypeScript Protocol
        const tsCode = generateTypeScriptProtocol(spec, protocolName);
        fs.writeFileSync(path.join(stagingTs, `${protocolName}.g.ts`), tsCode);
    }

    async copyProtocolToTargets(protocolName, config) {
        const stagingCs = path.join(this.tempDir, protocolName, 'cs', 'generated');
        const stagingTs = path.join(this.tempDir, protocolName, 'ts', 'generated');

        // Copy to CS targets
        if (config.csTargetDirs) {
            for (const targetDir of config.csTargetDirs) {
                const target = path.join(this.rootDir, targetDir, 'generated');
                this.cleanAndCopy(stagingCs, target);
                console.log(`    [Copy] ${stagingCs} -> ${target}`);
            }
        }

        // Copy to TS targets
        if (config.tsTargetDirs) {
            for (const targetDir of config.tsTargetDirs) {
                const target = path.join(this.rootDir, targetDir, 'generated');
                this.cleanAndCopy(stagingTs, target);
                console.log(`    [Copy] ${stagingTs} -> ${target}`);
            }
        }
    }

    // ========================================================================
    // Opcode/Tag Registry Management
    // ========================================================================

    loadOrCreateRegistry(protocolName, type) {
        const registryPath = path.join(this.rootDir, 'input', protocolName, 'protocols', `${protocolName}.${type}.json`);
        if (fs.existsSync(registryPath)) {
            return JSON.parse(fs.readFileSync(registryPath, 'utf-8'));
        }
        return {};
    }

    saveRegistry(protocolName, type, registry) {
        const registryDir = path.join(this.rootDir, 'input', protocolName, 'protocols');
        const registryPath = path.join(registryDir, `${protocolName}.${type}.json`);
        fs.mkdirSync(registryDir, { recursive: true });
        
        // Deterministic save: sort keys (ordinal) + trailing newline
        const sortedKeys = Object.keys(registry).sort((a, b) => a.localeCompare(b));
        const sorted = {};
        for (const key of sortedKeys) {
            sorted[key] = registry[key];
        }
        fs.writeFileSync(registryPath, JSON.stringify(sorted, null, 2) + '\n');
    }

    assignOpcodes(spec, registry) {
        const MIN_OPCODE = 1000;
        const usedOpcodes = new Set();

        // Phase 1: Apply explicit opcodes from spec (highest priority)
        for (const msg of spec.messages) {
            if (msg.opcode !== undefined) {
                if (msg.opcode < 0) {
                    throw new Error(`Negative opcode not allowed: ${msg.name} = ${msg.opcode}`);
                }
                if (usedOpcodes.has(msg.opcode)) {
                    throw new Error(`Duplicate opcode: ${msg.opcode} for ${msg.name}`);
                }
                usedOpcodes.add(msg.opcode);
                registry[msg.name] = msg.opcode;
            }
        }

        // Phase 2: Apply registry values for messages without explicit opcode
        for (const msg of spec.messages) {
            if (msg.opcode === undefined && registry[msg.name] !== undefined) {
                const regOpcode = registry[msg.name];
                if (usedOpcodes.has(regOpcode)) {
                    throw new Error(`Duplicate opcode from registry: ${regOpcode} for ${msg.name}`);
                }
                usedOpcodes.add(regOpcode);
                msg.opcode = regOpcode;
            }
        }

        // Phase 3: Auto-assign remaining messages (sorted by name for determinism)
        const unassigned = spec.messages
            .filter(m => m.opcode === undefined)
            .sort((a, b) => a.name.localeCompare(b.name));

        // Find max opcode to start auto-assign
        let nextOpcode = MIN_OPCODE;
        for (const oc of usedOpcodes) {
            if (oc >= nextOpcode) {
                nextOpcode = oc + 1;
            }
        }

        for (const msg of unassigned) {
            // Find next available opcode
            while (usedOpcodes.has(nextOpcode)) {
                nextOpcode++;
            }
            msg.opcode = nextOpcode;
            registry[msg.name] = nextOpcode;
            usedOpcodes.add(nextOpcode);
            nextOpcode++;
        }
    }

    assignTags(spec, registry) {
        const MIN_TAG = 1;
        const MAX_TAG = 536870911; // 2^29 - 1 (protobuf limit)
        const RESERVED_START = 19000;
        const RESERVED_END = 19999;

        for (const msg of spec.messages) {
            const usedTags = new Set();

            // Phase 1: Apply explicit tags from spec (highest priority)
            for (const field of msg.fields || []) {
                if (field.tag !== undefined) {
                    this.validateTag(field.tag, msg.name, field.name);
                    if (usedTags.has(field.tag)) {
                        throw new Error(`Duplicate tag in ${msg.name}: ${field.tag} for ${field.name}`);
                    }
                    usedTags.add(field.tag);
                    const key = `${msg.name}.${field.name}`;
                    registry[key] = field.tag;
                }
            }

            // Phase 2: Apply registry values for fields without explicit tag
            for (const field of msg.fields || []) {
                const key = `${msg.name}.${field.name}`;
                if (field.tag === undefined && registry[key] !== undefined) {
                    const regTag = registry[key];
                    this.validateTag(regTag, msg.name, field.name);
                    if (usedTags.has(regTag)) {
                        throw new Error(`Duplicate tag from registry in ${msg.name}: ${regTag} for ${field.name}`);
                    }
                    usedTags.add(regTag);
                    field.tag = regTag;
                }
            }

            // Phase 3: Auto-assign remaining fields (in order for determinism)
            let nextTag = MIN_TAG;
            for (const field of msg.fields || []) {
                if (field.tag === undefined) {
                    // Find next available tag, skipping reserved range
                    while (usedTags.has(nextTag) || 
                           (nextTag >= RESERVED_START && nextTag <= RESERVED_END)) {
                        nextTag++;
                        // Skip reserved range
                        if (nextTag >= RESERVED_START && nextTag <= RESERVED_END) {
                            nextTag = RESERVED_END + 1;
                        }
                    }
                    
                    if (nextTag > MAX_TAG) {
                        throw new Error(`Tag overflow in ${msg.name}.${field.name}`);
                    }

                    field.tag = nextTag;
                    const key = `${msg.name}.${field.name}`;
                    registry[key] = nextTag;
                    usedTags.add(nextTag);
                    nextTag++;
                }
            }
        }
    }

    validateTag(tag, msgName, fieldName) {
        const MIN_TAG = 1;
        const MAX_TAG = 536870911;
        const RESERVED_START = 19000;
        const RESERVED_END = 19999;

        if (tag < MIN_TAG || tag > MAX_TAG) {
            throw new Error(`Tag out of range in ${msgName}.${fieldName}: ${tag} (valid: ${MIN_TAG}-${MAX_TAG})`);
        }
        if (tag >= RESERVED_START && tag <= RESERVED_END) {
            throw new Error(`Tag in reserved range in ${msgName}.${fieldName}: ${tag} (reserved: ${RESERVED_START}-${RESERVED_END})`);
        }
    }

    // ========================================================================
    // Utilities
    // ========================================================================

    globFiles(dir, patterns) {
        if (!fs.existsSync(dir)) return [];

        const files = fs.readdirSync(dir);
        const result = [];

        for (const pattern of patterns) {
            const regex = new RegExp('^' + pattern.replace(/\*/g, '.*') + '$');
            for (const file of files) {
                if (regex.test(file)) {
                    result.push(path.join(dir, file));
                }
            }
        }

        return result;
    }

    cleanAndCopy(src, dest) {
        // Clean target
        if (fs.existsSync(dest)) {
            fs.rmSync(dest, { recursive: true });
        }
        fs.mkdirSync(dest, { recursive: true });

        // Copy files
        if (!fs.existsSync(src)) return;

        const files = fs.readdirSync(src);
        for (const file of files) {
            const srcFile = path.join(src, file);
            const destFile = path.join(dest, file);
            fs.copyFileSync(srcFile, destFile);
        }
    }
}

// ============================================================================
// Main Entry Point
// ============================================================================

async function main() {
    const args = process.argv.slice(2);

    if (args.length < 1) {
        console.log('Usage: node build.js <build.json>');
        console.log('Example: node build.js ../../input/build/build.json');
        process.exit(1);
    }

    const buildJsonPath = args[0];

    try {
        const runner = new BuildRunner(buildJsonPath);
        await runner.run();
    } catch (error) {
        console.error('Build failed:', error.message);
        console.error(error.stack);
        process.exit(1);
    }
}

main();

// <auto-generated>
// Devian Build System v10 - TypeScript Protocol Generator
// SSOT: skills/devian/03-ssot/SKILL.md
// Namespace: export namespace {ProtocolName}
// </auto-generated>

/**
 * Generate TypeScript protocol code from protocol spec
 * @param {Object} spec - Protocol specification
 * @param {string} protocolName - Protocol name (e.g., "C2Game")
 * @returns {string} Generated TypeScript code
 */
export function generateTypeScriptProtocol(spec, protocolName) {
    const lines = [];

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push('// </auto-generated>');
    lines.push('');

    // Direction comment
    if (spec.direction && spec.direction !== 'bidirectional') {
        lines.push(`// Direction: ${spec.direction}`);
        lines.push('');
    }

    // Namespace
    lines.push(`export namespace ${protocolName} {`);
    lines.push('');

    // Message interfaces
    for (const message of spec.messages || []) {
        generateMessageInterface(lines, message);
        lines.push('');
    }

    // Opcodes
    generateOpcodesObject(lines, spec.messages || []);
    lines.push('');

    // ICodec interface
    generateICodecInterface(lines);
    lines.push('');

    // CodecJson
    generateCodecJson(lines, spec.messages || []);
    lines.push('');

    // CodecProtobuf
    generateCodecProtobuf(lines, spec.messages || []);
    lines.push('');

    // Stub class
    generateStub(lines, spec.messages || [], protocolName);
    lines.push('');

    // Proxy class
    generateProxy(lines, spec.messages || [], protocolName);

    lines.push('}'); // end namespace

    return lines.join('\n');
}

// ============================================================================
// Generator Functions
// ============================================================================

function generateMessageInterface(lines, message) {
    lines.push(`    /** ${message.name} message */`);
    lines.push(`    export interface ${message.name} {`);

    for (const field of message.fields || []) {
        const tsType = mapToTypeScriptType(field.type);
        const optional = field.optional ? '?' : '';
        lines.push(`        ${field.name}${optional}: ${tsType};`);
    }

    lines.push('    }');
}

function generateOpcodesObject(lines, messages) {
    lines.push('    /** Opcode constants */');
    lines.push('    export const Opcodes = {');
    for (const msg of messages) {
        lines.push(`        ${msg.name}: ${msg.opcode},`);
    }
    lines.push('    } as const;');
    lines.push('');
    lines.push('    export type OpcodeType = typeof Opcodes[keyof typeof Opcodes];');
    lines.push('');
    lines.push('    export function getOpcodeName(opcode: number): string | undefined {');
    lines.push('        const entries = Object.entries(Opcodes);');
    lines.push('        const found = entries.find(([_, v]) => v === opcode);');
    lines.push('        return found?.[0];');
    lines.push('    }');
}

function generateICodecInterface(lines) {
    lines.push('    /** Codec interface */');
    lines.push('    export interface ICodec {');
    lines.push('        encode<T>(message: T): Uint8Array;');
    lines.push('        decode<T>(data: Uint8Array): T;');
    lines.push('        decodeByOpcode(opcode: number, data: Uint8Array): unknown;');
    lines.push('    }');
}

function generateCodecJson(lines, messages) {
    lines.push('    /** JSON Codec implementation */');
    lines.push('    export class CodecJson implements ICodec {');
    lines.push('        private encoder = new TextEncoder();');
    lines.push('        private decoder = new TextDecoder();');
    lines.push('');
    lines.push('        encode<T>(message: T): Uint8Array {');
    lines.push('            const json = JSON.stringify(message);');
    lines.push('            return this.encoder.encode(json);');
    lines.push('        }');
    lines.push('');
    lines.push('        decode<T>(data: Uint8Array): T {');
    lines.push('            const json = this.decoder.decode(data);');
    lines.push('            return JSON.parse(json) as T;');
    lines.push('        }');
    lines.push('');
    lines.push('        decodeByOpcode(opcode: number, data: Uint8Array): unknown {');
    lines.push('            return this.decode(data);');
    lines.push('        }');
    lines.push('    }');
}

function generateCodecProtobuf(lines, messages) {
    lines.push('    /**');
    lines.push('     * Protobuf Codec implementation.');
    lines.push('     * Requires message encoders/decoders to be registered.');
    lines.push('     */');
    lines.push('    export class CodecProtobuf implements ICodec {');
    lines.push('        private encoders = new Map<number, (message: unknown) => Uint8Array>();');
    lines.push('        private decoders = new Map<number, (data: Uint8Array) => unknown>();');
    lines.push('        private fallbackCodec = new CodecJson();');
    lines.push('');
    lines.push('        /**');
    lines.push('         * Register encoder for a specific opcode.');
    lines.push('         */');
    lines.push('        registerEncoder(opcode: number, encoder: (message: unknown) => Uint8Array): void {');
    lines.push('            this.encoders.set(opcode, encoder);');
    lines.push('        }');
    lines.push('');
    lines.push('        /**');
    lines.push('         * Register decoder for a specific opcode.');
    lines.push('         */');
    lines.push('        registerDecoder(opcode: number, decoder: (data: Uint8Array) => unknown): void {');
    lines.push('            this.decoders.set(opcode, decoder);');
    lines.push('        }');
    lines.push('');
    lines.push('        encode<T>(message: T): Uint8Array {');
    lines.push('            // Generic encode falls back to JSON');
    lines.push('            return this.fallbackCodec.encode(message);');
    lines.push('        }');
    lines.push('');
    lines.push('        /**');
    lines.push('         * Encode message by opcode using registered encoder.');
    lines.push('         */');
    lines.push('        encodeByOpcode<T>(opcode: number, message: T): Uint8Array {');
    lines.push('            const encoder = this.encoders.get(opcode);');
    lines.push('            if (encoder) {');
    lines.push('                return encoder(message);');
    lines.push('            }');
    lines.push('            return this.fallbackCodec.encode(message);');
    lines.push('        }');
    lines.push('');
    lines.push('        decode<T>(data: Uint8Array): T {');
    lines.push('            // Generic decode falls back to JSON');
    lines.push('            return this.fallbackCodec.decode(data);');
    lines.push('        }');
    lines.push('');
    lines.push('        decodeByOpcode(opcode: number, data: Uint8Array): unknown {');
    lines.push('            const decoder = this.decoders.get(opcode);');
    lines.push('            if (decoder) {');
    lines.push('                return decoder(data);');
    lines.push('            }');
    lines.push('            return this.fallbackCodec.decode(data);');
    lines.push('        }');
    lines.push('    }');
}

function generateStub(lines, messages, protocolName) {
    lines.push('    /** Message handler type */');
    lines.push('    export type MessageHandler<T> = (sessionId: number, message: T) => void | Promise<void>;');
    lines.push('');
    lines.push('    /**');
    lines.push(`     * Stub for ${protocolName} handlers.`);
    lines.push('     * Register handlers with on{MessageName}() methods.');
    lines.push('     */');
    lines.push('    export class Stub {');
    lines.push('        private codec: ICodec;');
    lines.push('        private handlers = new Map<number, Set<MessageHandler<unknown>>>();');
    lines.push('');
    lines.push('        constructor(codec?: ICodec) {');
    lines.push('            this.codec = codec ?? new CodecJson();');
    lines.push('        }');
    lines.push('');

    // Dispatch method
    lines.push('        async dispatch(sessionId: number, opcode: number, payload: Uint8Array): Promise<void> {');
    lines.push('            const handlerSet = this.handlers.get(opcode);');
    lines.push('            if (!handlerSet || handlerSet.size === 0) return;');
    lines.push('');
    lines.push('            const message = this.codec.decodeByOpcode(opcode, payload);');
    lines.push('            for (const handler of handlerSet) {');
    lines.push('                await handler(sessionId, message);');
    lines.push('            }');
    lines.push('        }');
    lines.push('');

    // Register/unregister per message
    for (const msg of messages) {
        lines.push(`        on${msg.name}(handler: MessageHandler<${msg.name}>): () => void {`);
        lines.push(`            return this.register(Opcodes.${msg.name}, handler as MessageHandler<unknown>);`);
        lines.push('        }');
        lines.push('');
    }

    // Private register method
    lines.push('        private register(opcode: number, handler: MessageHandler<unknown>): () => void {');
    lines.push('            if (!this.handlers.has(opcode)) {');
    lines.push('                this.handlers.set(opcode, new Set());');
    lines.push('            }');
    lines.push('            this.handlers.get(opcode)!.add(handler);');
    lines.push('');
    lines.push('            // Return unsubscribe function');
    lines.push('            return () => {');
    lines.push('                this.handlers.get(opcode)?.delete(handler);');
    lines.push('            };');
    lines.push('        }');
    lines.push('    }');
}

function generateProxy(lines, messages, protocolName) {
    lines.push('    /** Send function type */');
    lines.push('    export type SendFn = (sessionId: number, frame: Uint8Array) => void | Promise<void>;');
    lines.push('');
    lines.push('    /**');
    lines.push(`     * Proxy for sending ${protocolName} messages.`);
    lines.push('     */');
    lines.push('    export class Proxy {');
    lines.push('        private sendFn: SendFn;');
    lines.push('        private codec: ICodec;');
    lines.push('');
    lines.push('        constructor(sendFn: SendFn, codec?: ICodec) {');
    lines.push('            this.sendFn = sendFn;');
    lines.push('            this.codec = codec ?? new CodecJson();');
    lines.push('        }');
    lines.push('');

    // Frame helper
    lines.push('        private packFrame(opcode: number, payload: Uint8Array): Uint8Array {');
    lines.push('            const frame = new Uint8Array(4 + payload.length);');
    lines.push('            const view = new DataView(frame.buffer);');
    lines.push('            view.setInt32(0, opcode, true); // little-endian');
    lines.push('            frame.set(payload, 4);');
    lines.push('            return frame;');
    lines.push('        }');
    lines.push('');

    // Send methods per message
    for (const msg of messages) {
        lines.push(`        async send${msg.name}(sessionId: number, message: ${msg.name}): Promise<void> {`);
        lines.push('            const payload = this.codec.encode(message);');
        lines.push(`            const frame = this.packFrame(Opcodes.${msg.name}, payload);`);
        lines.push('            await this.sendFn(sessionId, frame);');
        lines.push('        }');
        lines.push('');
    }

    lines.push('    }');
}

// ============================================================================
// Type Mapping
// ============================================================================

function mapToTypeScriptType(type) {
    const isArray = type.endsWith('[]');
    const baseType = isArray ? type.slice(0, -2) : type;

    // Handle map<K,V> type
    const mapMatch = baseType.match(/^map<\s*(\w+)\s*,\s*(\w+)\s*>$/);
    if (mapMatch) {
        const keyType = mapToTypeScriptType(mapMatch[1]);
        const valueType = mapToTypeScriptType(mapMatch[2]);
        const recordType = `Record<${keyType}, ${valueType}>`;
        return isArray ? `${recordType}[]` : recordType;
    }

    const typeMap = {
        'int32': 'number',
        'int64': 'bigint',
        'uint32': 'number',
        'uint64': 'bigint',
        'sint32': 'number',
        'sint64': 'bigint',
        'float': 'number',
        'double': 'number',
        'bool': 'boolean',
        'string': 'string',
        'bytes': 'Uint8Array',
    };

    const tsBase = typeMap[baseType] || baseType;
    return isArray ? `${tsBase}[]` : tsBase;
}

// <auto-generated>
// Devian Build System v10 - Table Generator
// SSOT: skills/devian/03-ssot/SKILL.md
// Namespace: Devian.Tables, Container: Table.TB_{TableName}
// </auto-generated>

import XLSX from 'xlsx';

/**
 * Parse XLSX file and extract table definitions
 * @param {string} filePath - Path to XLSX file
 * @returns {Array} Array of table definitions
 */
export function parseXlsx(filePath) {
    const workbook = XLSX.readFile(filePath);
    const tables = [];

    for (const sheetName of workbook.SheetNames) {
        const sheet = workbook.Sheets[sheetName];
        const table = parseSheet(sheet, sheetName);
        if (table) {
            tables.push(table);
        }
    }

    return tables;
}

/**
 * Parse a single sheet into table definition
 * @param {Object} sheet - XLSX sheet object
 * @param {string} sheetName - Sheet name
 * @returns {Object|null} Table definition or null if invalid
 */
function parseSheet(sheet, sheetName) {
    const range = XLSX.utils.decode_range(sheet['!ref'] || 'A1');
    const fields = [];
    let keyField = null;

    // Parse header (4 rows fixed per SSOT)
    // Row 1: FieldName, Row 2: Type, Row 3: Options, Row 4: Comment
    for (let col = range.s.c; col <= range.e.c; col++) {
        const fieldName = getCellValue(sheet, 0, col);
        let fieldType = getCellValue(sheet, 1, col);
        if (!fieldType) fieldType = 'string';

        // Header Stop Rule: Empty FieldName → stop scanning
        if (!fieldName) break

        const options = parseOptions(getCellValue(sheet, 2, col));
        const comment = getCellValue(sheet, 3, col);

        const field = {
            name: fieldName,
            type: fieldType,
            optional: options.optional === 'true',
            isKey: options.key === 'true',
            comment: comment || '',
        };

        fields.push(field);

        if (field.isKey) {
            if (keyField) {
                throw new Error(`Multiple key fields not allowed: ${sheetName}`);
            }
            keyField = field;
        }
    }

    if (fields.length === 0) return null;

    // Parse data rows (Row 5+, 0-indexed: row 4+)
    const rows = [];
    for (let row = 4; row <= range.e.r; row++) {
        const rowData = {};
        let isEmpty = true;
        let keyValue = null;

        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            const value = getCellValue(sheet, row, i);

            if (value !== null && value !== undefined && value !== '') {
                isEmpty = false;
            }

            // Parse value based on type
            rowData[field.name] = parseValue(value, field.type);

            if (field.isKey) {
                keyValue = rowData[field.name];
            }
        }

        // Data Stop Rule: Empty key → stop loading
        if (keyField && (keyValue === null || keyValue === undefined || keyValue === '')) {
            break;
        }

        // Empty row: skip (do not terminate)
        if (isEmpty) {
            continue;
        }

        rows.push(rowData);
    }

    return {
        name: sheetName,
        fields: fields,
        keyField: keyField,
        rows: rows,
    };
}

/**
 * Get cell value from sheet
 */
function getCellValue(sheet, row, col) {
    const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
    const cell = sheet[cellAddress];
    return cell ? cell.v : null;
}

/**
 * Parse options string (comma-separated key:value pairs)
 *
 * SSOT: skills/devian/24-table-authoring-rules/SKILL.md
 * Example: "key:true, optional:true"
 */
function parseOptions(optionStr) {
    const options = {};
    if (!optionStr) return options;

    // Split by comma, allow extra spaces
    const parts = String(optionStr)
        .split(',')
        .map(p => p.trim())
        .filter(p => p.length > 0);

    for (const part of parts) {
        const idx = part.indexOf(':');
        if (idx <= 0) continue;
        const key = part.slice(0, idx).trim();
        const value = part.slice(idx + 1).trim();
        if (key && value !== undefined) {
            options[key] = value;
        }
    }
    return options;
}

/**
 * Parse value based on type
 */
function parseValue(value, type) {
    if (value === null || value === undefined || value === '') {
        return getDefaultForType(type);
    }

    const baseType = type.replace('[]', '');
    const isArray = type.endsWith('[]');

    if (isArray) {
        // Parse array value (DFF format: "a,b,c" or "{a,b,c}" or "[a,b,c]")
        let arrayStr = String(value);
        arrayStr = arrayStr.replace(/^[\[{]/, '').replace(/[\]}]$/, '');
        const items = arrayStr.split(',').map(s => s.trim()).filter(s => s !== '');
        return items.map(item => parseSingleValue(item, baseType));
    }

    return parseSingleValue(value, baseType);
}

function parseSingleValue(value, type) {
    if (value === null || value === undefined) return null;

    switch (type) {
        case 'byte':
        case 'ubyte':
        case 'short':
        case 'ushort':
        case 'int':
        case 'uint':
            return parseInt(value, 10);
        case 'long':
        case 'ulong':
            return String(value); // 64-bit as string for JSON
        case 'float':
        case 'double':
            return parseFloat(value);
        case 'bool':
            return value === true || value === 'true' || value === '1';
        case 'string':
            return String(value);
        default:
            // enum:Name or class:Name
            if (type.startsWith('enum:')) {
                return String(value); // enum stored as name string
            }
            return value;
    }
}

function getDefaultForType(type) {
    if (type.endsWith('[]')) return [];
    switch (type) {
        case 'byte':
        case 'ubyte':
        case 'short':
        case 'ushort':
        case 'int':
        case 'uint':
        case 'float':
        case 'double':
            return 0;
        case 'long':
        case 'ulong':
            return '0';
        case 'bool':
            return false;
        case 'string':
            return '';
        default:
            return null;
    }
}

// ============================================================================
// C# Table Generator
// ============================================================================

/**
 * Generate C# table container code
 * @param {Object} table - Table definition from parseXlsx
 * @param {string} domainName - Domain name
 * @returns {string} Generated C# code
 */
export function generateCSharpTable(table, domainName) {
    const lines = [];
    const tableName = table.name;
    const rowClassName = `${tableName}Row`;

    // Header
    lines.push('// <auto-generated>');
    lines.push('// DO NOT EDIT - Generated by Devian Build System v10');
    lines.push('// </auto-generated>');
    lines.push('');
    lines.push('#nullable enable');
    lines.push('');
    lines.push('using System;');
    lines.push('using System.Collections.Generic;');
    lines.push('using System.IO;');
    lines.push('using System.Text.Json;');
    lines.push('');

    // Namespace: Devian.Tables (SSOT A안)
    lines.push('namespace Devian.Tables');
    lines.push('{');

    // Row class
    generateRowClass(lines, table, rowClassName);
    lines.push('');

    // Container: public static partial class Table
    lines.push('    public static partial class Table');
    lines.push('    {');

    // Table container: TB_{TableName}
    generateTableContainer(lines, table, tableName, rowClassName);

    lines.push('    }'); // end Table
    lines.push('}'); // end namespace

    return lines.join('\n');
}

function generateRowClass(lines, table, rowClassName) {
    lines.push(`    /// <summary>${table.name} row</summary>`);
    lines.push(`    public sealed class ${rowClassName}`);
    lines.push('    {');

    for (const field of table.fields) {
        const csType = mapTableTypeToCSharp(field.type, field.optional);
        const propName = capitalize(field.name);
        const defaultValue = getTableDefaultValue(field.type);
        lines.push(`        public ${csType} ${propName} { get; set; }${defaultValue}`);
    }

    // GetKey method if key field exists
    if (table.keyField) {
        lines.push('');
        lines.push(`        public object GetKey() => ${capitalize(table.keyField.name)};`);
    }

    lines.push('    }');
}

function generateTableContainer(lines, table, tableName, rowClassName) {
    const keyType = table.keyField ? mapTableTypeToCSharp(table.keyField.type, false) : 'int';
    const keyProp = table.keyField ? capitalize(table.keyField.name) : 'Id';

    lines.push(`        /// <summary>TB_${tableName} container</summary>`);
    lines.push(`        public static class TB_${tableName}`);
    lines.push('        {');

    // Storage
    if (table.keyField) {
        lines.push(`            private static readonly Dictionary<${keyType}, ${rowClassName}> _dict = new();`);
    }
    lines.push(`            private static readonly List<${rowClassName}> _list = new();`);
    lines.push('');

    // Count property
    lines.push('            public static int Count => _list.Count;');
    lines.push('');

    // Clear
    lines.push('            public static void Clear()');
    lines.push('            {');
    if (table.keyField) {
        lines.push('                _dict.Clear();');
    }
    lines.push('                _list.Clear();');
    lines.push('            }');
    lines.push('');

    // GetAll
    lines.push(`            public static IReadOnlyList<${rowClassName}> GetAll() => _list;`);
    lines.push('');

    // Get/TryGet (if key exists)
    if (table.keyField) {
        lines.push(`            public static ${rowClassName}? Get(${keyType} key)`);
        lines.push('            {');
        lines.push('                return _dict.TryGetValue(key, out var row) ? row : null;');
        lines.push('            }');
        lines.push('');
        lines.push(`            public static bool TryGet(${keyType} key, out ${rowClassName}? row)`);
        lines.push('            {');
        lines.push('                return _dict.TryGetValue(key, out row);');
        lines.push('            }');
        lines.push('');
    }

    // LoadFromJson
    lines.push('            public static void LoadFromJson(string json)');
    lines.push('            {');
    lines.push('                Clear();');
    lines.push('                using var doc = JsonDocument.Parse(json);');
    lines.push('                foreach (var element in doc.RootElement.EnumerateArray())');
    lines.push('                {');
    lines.push(`                    var row = JsonSerializer.Deserialize<${rowClassName}>(element.GetRawText());`);
    lines.push('                    if (row == null) continue;');
    lines.push('                    _list.Add(row);');
    if (table.keyField) {
        lines.push(`                    _dict[row.${keyProp}] = row;`);
    }
    lines.push('                }');
    lines.push('            }');
    lines.push('');

    // LoadFromNdjson
    lines.push('            public static void LoadFromNdjson(string ndjson)');
    lines.push('            {');
    lines.push('                Clear();');
    lines.push('                using var reader = new StringReader(ndjson);');
    lines.push('                string? line;');
    lines.push('                while ((line = reader.ReadLine()) != null)');
    lines.push('                {');
    lines.push('                    if (string.IsNullOrWhiteSpace(line)) continue;');
    lines.push(`                    var row = JsonSerializer.Deserialize<${rowClassName}>(line);`);
    lines.push('                    if (row == null) continue;');
    lines.push('                    _list.Add(row);');
    if (table.keyField) {
        lines.push(`                    _dict[row.${keyProp}] = row;`);
    }
    lines.push('                }');
    lines.push('            }');

    lines.push('        }');
}

function mapTableTypeToCSharp(type, optional) {
    const isArray = type.endsWith('[]');
    const baseType = isArray ? type.slice(0, -2) : type;

    const typeMap = {
        'byte': 'sbyte',
        'ubyte': 'byte',
        'short': 'short',
        'ushort': 'ushort',
        'int': 'int',
        'uint': 'uint',
        'long': 'long',
        'ulong': 'ulong',
        'float': 'float',
        'double': 'double',
        'string': 'string',
        'bool': 'bool',
    };

    let csType = typeMap[baseType];

    if (!csType) {
        // enum:Name or class:Name
        if (baseType.startsWith('enum:')) {
            csType = baseType.slice(5);
            if (csType.includes('.')) {
                const [ns, name] = csType.split('.');
                csType = `Devian.${ns}.${name}`;
            }
        } else if (baseType.startsWith('class:')) {
            csType = baseType.slice(6);
            if (csType.includes('.')) {
                const [ns, name] = csType.split('.');
                csType = `Devian.${ns}.${name}`;
            }
        } else {
            csType = baseType;
        }
    }

    if (isArray) {
        return `List<${csType}>`;
    }

    if (optional && ['string'].includes(baseType)) {
        return `${csType}?`;
    }

    return csType;
}

function getTableDefaultValue(type) {
    if (type.endsWith('[]')) return ' = new();';
    if (type === 'string') return ' = string.Empty;';
    return '';
}

function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}

// ============================================================================
// NDJSON Data Generator
// ============================================================================

/**
 * Generate NDJSON data from table
 * @param {Object} table - Table definition from parseXlsx
 * @returns {string} NDJSON string (one JSON per line)
 */
export function generateTableData(table) {
    const lines = [];

    for (const row of table.rows) {
        // Convert row to JSON with proper property order (SSOT: Excel column order)
        const orderedRow = {};
        for (const field of table.fields) {
            const value = row[field.name];
            // SSOT: 64-bit integers → string, enum → name string
            if (['long', 'ulong'].includes(field.type)) {
                orderedRow[capitalize(field.name)] = String(value);
            } else {
                orderedRow[capitalize(field.name)] = value;
            }
        }
        lines.push(JSON.stringify(orderedRow));
    }

    return lines.join('\n');
}
